{"version":3,"sources":["/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/cell_editors.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/cell_formatters.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/data_table.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/index.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/main.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/table_column.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/tables/table_widget.js","/home/drew/bokeh_dev/bokeh/bokehjs/build/js/tree/models/widgets/widget.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/jquery/dist/jquery.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/lib/jquery.event.drag-2.3.0.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/lib/jquery.event.drop-2.3.0.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/plugins/slick.checkboxselectcolumn.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/plugins/slick.rowselectionmodel.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/slick.core.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/slick.grid.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/slickgrid/slick.jquery.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/underscore.template/lib/index.js","/home/drew/bokeh_dev/bokeh/bokehjs/node_modules/underscore.template/lib/underscore.template.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC71GA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["/* models/widgets/tables/cell_editors */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    var p = require(15) /* core/properties */;\n    var dom_1 = require(5) /* core/dom */;\n    var dom_view_1 = require(6) /* core/dom_view */;\n    var model_1 = require(57) /* ../../../model */;\n    var data_table_1 = require(432) /* ./data_table */;\n    var CellEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(CellEditorView, _super);\n        function CellEditorView(options) {\n            return _super.call(this, tslib_1.__assign({ model: options.column.model }, options)) || this;\n        }\n        Object.defineProperty(CellEditorView.prototype, \"emptyValue\", {\n            get: function () {\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        CellEditorView.prototype.initialize = function (options) {\n            _super.prototype.initialize.call(this, options);\n            this.inputEl = this._createInput();\n            this.defaultValue = null;\n            this.args = options;\n            this.render();\n        };\n        CellEditorView.prototype.css_classes = function () {\n            return _super.prototype.css_classes.call(this).concat(\"bk-cell-editor\");\n        };\n        CellEditorView.prototype.render = function () {\n            _super.prototype.render.call(this);\n            this.args.container.appendChild(this.el);\n            this.el.appendChild(this.inputEl);\n            this.renderEditor();\n            this.disableNavigation();\n        };\n        CellEditorView.prototype.renderEditor = function () { };\n        CellEditorView.prototype.disableNavigation = function () {\n            this.inputEl.addEventListener(\"keydown\", function (event) {\n                switch (event.keyCode) {\n                    case dom_1.Keys.Left:\n                    case dom_1.Keys.Right:\n                    case dom_1.Keys.Up:\n                    case dom_1.Keys.Down:\n                    case dom_1.Keys.PageUp:\n                    case dom_1.Keys.PageDown:\n                        event.stopImmediatePropagation();\n                }\n            });\n        };\n        CellEditorView.prototype.destroy = function () {\n            this.remove();\n        };\n        CellEditorView.prototype.focus = function () {\n            this.inputEl.focus();\n        };\n        CellEditorView.prototype.show = function () { };\n        CellEditorView.prototype.hide = function () { };\n        CellEditorView.prototype.position = function () { };\n        CellEditorView.prototype.getValue = function () {\n            return this.inputEl.value;\n        };\n        CellEditorView.prototype.setValue = function (val) {\n            this.inputEl.value = val;\n        };\n        CellEditorView.prototype.serializeValue = function () {\n            return this.getValue();\n        };\n        CellEditorView.prototype.isValueChanged = function () {\n            return !(this.getValue() == \"\" && this.defaultValue == null) && this.getValue() !== this.defaultValue;\n        };\n        CellEditorView.prototype.applyValue = function (item, state) {\n            this.args.grid.getData().setField(item[data_table_1.DTINDEX_NAME], this.args.column.field, state);\n        };\n        CellEditorView.prototype.loadValue = function (item) {\n            var value = item[this.args.column.field];\n            this.defaultValue = value != null ? value : this.emptyValue;\n            this.setValue(this.defaultValue);\n        };\n        CellEditorView.prototype.validateValue = function (value) {\n            if (this.args.column.validator) {\n                var result = this.args.column.validator(value);\n                if (!result.valid) {\n                    return result;\n                }\n            }\n            return { valid: true, msg: null };\n        };\n        CellEditorView.prototype.validate = function () {\n            return this.validateValue(this.getValue());\n        };\n        return CellEditorView;\n    }(dom_view_1.DOMView));\n    exports.CellEditorView = CellEditorView;\n    var CellEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(CellEditor, _super);\n        function CellEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CellEditor.initClass = function () {\n            this.prototype.type = \"CellEditor\";\n        };\n        return CellEditor;\n    }(model_1.Model));\n    exports.CellEditor = CellEditor;\n    CellEditor.initClass();\n    var StringEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(StringEditorView, _super);\n        function StringEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Object.defineProperty(StringEditorView.prototype, \"emptyValue\", {\n            get: function () {\n                return \"\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StringEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"text\" });\n        };\n        StringEditorView.prototype.renderEditor = function () {\n            //completions = @model.completions\n            //if completions.length != 0\n            //  @inputEl.classList.add(\"bk-cell-editor-completion\")\n            //  $(@inputEl).autocomplete({source: completions})\n            //  $(@inputEl).autocomplete(\"widget\")\n            this.inputEl.focus();\n            this.inputEl.select();\n        };\n        StringEditorView.prototype.loadValue = function (item) {\n            _super.prototype.loadValue.call(this, item);\n            this.inputEl.defaultValue = this.defaultValue;\n            this.inputEl.select();\n        };\n        return StringEditorView;\n    }(CellEditorView));\n    exports.StringEditorView = StringEditorView;\n    var StringEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(StringEditor, _super);\n        function StringEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        StringEditor.initClass = function () {\n            this.prototype.type = 'StringEditor';\n            this.prototype.default_view = StringEditorView;\n            this.define({\n                completions: [p.Array, []],\n            });\n        };\n        return StringEditor;\n    }(CellEditor));\n    exports.StringEditor = StringEditor;\n    StringEditor.initClass();\n    var TextEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(TextEditorView, _super);\n        function TextEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TextEditorView.prototype._createInput = function () {\n            return dom_1.textarea();\n        };\n        return TextEditorView;\n    }(CellEditorView));\n    exports.TextEditorView = TextEditorView;\n    var TextEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(TextEditor, _super);\n        function TextEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TextEditor.initClass = function () {\n            this.prototype.type = 'TextEditor';\n            this.prototype.default_view = TextEditorView;\n        };\n        return TextEditor;\n    }(CellEditor));\n    exports.TextEditor = TextEditor;\n    TextEditor.initClass();\n    var SelectEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(SelectEditorView, _super);\n        function SelectEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        SelectEditorView.prototype._createInput = function () {\n            return dom_1.select();\n        };\n        SelectEditorView.prototype.renderEditor = function () {\n            for (var _i = 0, _a = this.model.options; _i < _a.length; _i++) {\n                var opt = _a[_i];\n                this.inputEl.appendChild(dom_1.option({ value: opt }, opt));\n            }\n            this.focus();\n        };\n        return SelectEditorView;\n    }(CellEditorView));\n    exports.SelectEditorView = SelectEditorView;\n    var SelectEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(SelectEditor, _super);\n        function SelectEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        SelectEditor.initClass = function () {\n            this.prototype.type = 'SelectEditor';\n            this.prototype.default_view = SelectEditorView;\n            this.define({\n                options: [p.Array, []],\n            });\n        };\n        return SelectEditor;\n    }(CellEditor));\n    exports.SelectEditor = SelectEditor;\n    SelectEditor.initClass();\n    var PercentEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(PercentEditorView, _super);\n        function PercentEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        PercentEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"text\" });\n        };\n        return PercentEditorView;\n    }(CellEditorView));\n    exports.PercentEditorView = PercentEditorView;\n    var PercentEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(PercentEditor, _super);\n        function PercentEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        PercentEditor.initClass = function () {\n            this.prototype.type = 'PercentEditor';\n            this.prototype.default_view = PercentEditorView;\n        };\n        return PercentEditor;\n    }(CellEditor));\n    exports.PercentEditor = PercentEditor;\n    PercentEditor.initClass();\n    var CheckboxEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(CheckboxEditorView, _super);\n        function CheckboxEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CheckboxEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"checkbox\", value: \"true\" });\n        };\n        CheckboxEditorView.prototype.renderEditor = function () {\n            this.focus();\n        };\n        CheckboxEditorView.prototype.loadValue = function (item) {\n            this.defaultValue = !!item[this.args.column.field];\n            this.inputEl.checked = this.defaultValue;\n        };\n        CheckboxEditorView.prototype.serializeValue = function () {\n            return this.inputEl.checked;\n        };\n        return CheckboxEditorView;\n    }(CellEditorView));\n    exports.CheckboxEditorView = CheckboxEditorView;\n    var CheckboxEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(CheckboxEditor, _super);\n        function CheckboxEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CheckboxEditor.initClass = function () {\n            this.prototype.type = 'CheckboxEditor';\n            this.prototype.default_view = CheckboxEditorView;\n        };\n        return CheckboxEditor;\n    }(CellEditor));\n    exports.CheckboxEditor = CheckboxEditor;\n    CheckboxEditor.initClass();\n    var IntEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(IntEditorView, _super);\n        function IntEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        IntEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"text\" });\n        };\n        IntEditorView.prototype.renderEditor = function () {\n            //$(@inputEl).spinner({step: @model.step})\n            this.inputEl.focus();\n            this.inputEl.select();\n        };\n        IntEditorView.prototype.remove = function () {\n            //$(@inputEl).spinner(\"destroy\")\n            _super.prototype.remove.call(this);\n        };\n        IntEditorView.prototype.serializeValue = function () {\n            return parseInt(this.getValue(), 10) || 0;\n        };\n        IntEditorView.prototype.loadValue = function (item) {\n            _super.prototype.loadValue.call(this, item);\n            this.inputEl.defaultValue = this.defaultValue;\n            this.inputEl.select();\n        };\n        IntEditorView.prototype.validateValue = function (value) {\n            if (isNaN(value))\n                return { valid: false, msg: \"Please enter a valid integer\" };\n            else\n                return _super.prototype.validateValue.call(this, value);\n        };\n        return IntEditorView;\n    }(CellEditorView));\n    exports.IntEditorView = IntEditorView;\n    var IntEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(IntEditor, _super);\n        function IntEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        IntEditor.initClass = function () {\n            this.prototype.type = 'IntEditor';\n            this.prototype.default_view = IntEditorView;\n            this.define({\n                step: [p.Number, 1],\n            });\n        };\n        return IntEditor;\n    }(CellEditor));\n    exports.IntEditor = IntEditor;\n    IntEditor.initClass();\n    var NumberEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(NumberEditorView, _super);\n        function NumberEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        NumberEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"text\" });\n        };\n        NumberEditorView.prototype.renderEditor = function () {\n            //$(@inputEl).spinner({step: @model.step})\n            this.inputEl.focus();\n            this.inputEl.select();\n        };\n        NumberEditorView.prototype.remove = function () {\n            //$(@inputEl).spinner(\"destroy\")\n            _super.prototype.remove.call(this);\n        };\n        NumberEditorView.prototype.serializeValue = function () {\n            return parseFloat(this.getValue()) || 0.0;\n        };\n        NumberEditorView.prototype.loadValue = function (item) {\n            _super.prototype.loadValue.call(this, item);\n            this.inputEl.defaultValue = this.defaultValue;\n            this.inputEl.select();\n        };\n        NumberEditorView.prototype.validateValue = function (value) {\n            if (isNaN(value))\n                return { valid: false, msg: \"Please enter a valid number\" };\n            else\n                return _super.prototype.validateValue.call(this, value);\n        };\n        return NumberEditorView;\n    }(CellEditorView));\n    exports.NumberEditorView = NumberEditorView;\n    var NumberEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(NumberEditor, _super);\n        function NumberEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        NumberEditor.initClass = function () {\n            this.prototype.type = 'NumberEditor';\n            this.prototype.default_view = NumberEditorView;\n            this.define({\n                step: [p.Number, 0.01],\n            });\n        };\n        return NumberEditor;\n    }(CellEditor));\n    exports.NumberEditor = NumberEditor;\n    NumberEditor.initClass();\n    var TimeEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeEditorView, _super);\n        function TimeEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"text\" });\n        };\n        return TimeEditorView;\n    }(CellEditorView));\n    exports.TimeEditorView = TimeEditorView;\n    var TimeEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeEditor, _super);\n        function TimeEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeEditor.initClass = function () {\n            this.prototype.type = 'TimeEditor';\n            this.prototype.default_view = TimeEditorView;\n        };\n        return TimeEditor;\n    }(CellEditor));\n    exports.TimeEditor = TimeEditor;\n    TimeEditor.initClass();\n    var DateEditorView = /** @class */ (function (_super) {\n        tslib_1.__extends(DateEditorView, _super);\n        function DateEditorView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DateEditorView.prototype._createInput = function () {\n            return dom_1.input({ type: \"text\" });\n        };\n        Object.defineProperty(DateEditorView.prototype, \"emptyValue\", {\n            get: function () {\n                return new Date();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DateEditorView.prototype.renderEditor = function () {\n            //this.calendarOpen = false\n            //@$datepicker = $(@inputEl).datepicker({\n            //  showOn: \"button\"\n            //  buttonImageOnly: true\n            //  beforeShow: () => @calendarOpen = true\n            //  onClose: () => @calendarOpen = false\n            //})\n            //@$datepicker.siblings(\".ui-datepicker-trigger\").css(\"vertical-align\": \"middle\")\n            //@$datepicker.width(@$datepicker.width() - (14 + 2*4 + 4)) # img width + margins + edge distance\n            this.inputEl.focus();\n            this.inputEl.select();\n        };\n        DateEditorView.prototype.destroy = function () {\n            //$.datepicker.dpDiv.stop(true, true)\n            //@$datepicker.datepicker(\"hide\")\n            //@$datepicker.datepicker(\"destroy\")\n            _super.prototype.destroy.call(this);\n        };\n        DateEditorView.prototype.show = function () {\n            //if @calendarOpen\n            //  $.datepicker.dpDiv.stop(true, true).show()\n            _super.prototype.show.call(this);\n        };\n        DateEditorView.prototype.hide = function () {\n            //if @calendarOpen\n            //  $.datepicker.dpDiv.stop(true, true).hide()\n            _super.prototype.hide.call(this);\n        };\n        DateEditorView.prototype.position = function ( /*_position*/) {\n            //if @calendarOpen\n            //  $.datepicker.dpDiv.css(top: position.top + 30, left: position.left)\n            return _super.prototype.position.call(this);\n        };\n        DateEditorView.prototype.getValue = function () { };\n        //return @$datepicker.datepicker(\"getDate\").getTime()\n        DateEditorView.prototype.setValue = function (_val) { };\n        return DateEditorView;\n    }(CellEditorView));\n    exports.DateEditorView = DateEditorView;\n    //@$datepicker.datepicker(\"setDate\", new Date(val))\n    var DateEditor = /** @class */ (function (_super) {\n        tslib_1.__extends(DateEditor, _super);\n        function DateEditor() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DateEditor.initClass = function () {\n            this.prototype.type = 'DateEditor';\n            this.prototype.default_view = DateEditorView;\n        };\n        return DateEditor;\n    }(CellEditor));\n    exports.DateEditor = DateEditor;\n    DateEditor.initClass();\n}\n","/* models/widgets/tables/cell_formatters */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    var Numbro = require(358) /* numbro */;\n    var compile_template = require(446) /* underscore.template */;\n    var tz = require(387) /* timezone */;\n    var p = require(15) /* core/properties */;\n    var dom_1 = require(5) /* core/dom */;\n    var types_1 = require(44) /* core/util/types */;\n    var model_1 = require(57) /* ../../../model */;\n    var CellFormatter = /** @class */ (function (_super) {\n        tslib_1.__extends(CellFormatter, _super);\n        function CellFormatter(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        CellFormatter.prototype.doFormat = function (_row, _cell, value, _columnDef, _dataContext) {\n            if (value == null)\n                return \"\";\n            else\n                return (value + \"\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return CellFormatter;\n    }(model_1.Model));\n    exports.CellFormatter = CellFormatter;\n    var StringFormatter = /** @class */ (function (_super) {\n        tslib_1.__extends(StringFormatter, _super);\n        function StringFormatter(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        StringFormatter.initClass = function () {\n            this.prototype.type = 'StringFormatter';\n            this.define({\n                font_style: [p.FontStyle, \"normal\"],\n                text_align: [p.TextAlign, \"left\"],\n                text_color: [p.Color],\n            });\n        };\n        StringFormatter.prototype.doFormat = function (_row, _cell, value, _columnDef, _dataContext) {\n            var _a = this, font_style = _a.font_style, text_align = _a.text_align, text_color = _a.text_color;\n            var text = dom_1.span({}, value == null ? \"\" : \"\" + value);\n            switch (font_style) {\n                case \"bold\":\n                    text.style.fontWeight = \"bold\";\n                    break;\n                case \"italic\":\n                    text.style.fontStyle = \"italic\";\n                    break;\n            }\n            if (text_align != null)\n                text.style.textAlign = text_align;\n            if (text_color != null)\n                text.style.color = text_color;\n            return text.outerHTML;\n        };\n        return StringFormatter;\n    }(CellFormatter));\n    exports.StringFormatter = StringFormatter;\n    StringFormatter.initClass();\n    var NumberFormatter = /** @class */ (function (_super) {\n        tslib_1.__extends(NumberFormatter, _super);\n        function NumberFormatter(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        NumberFormatter.initClass = function () {\n            this.prototype.type = 'NumberFormatter';\n            this.define({\n                format: [p.String, '0,0'],\n                language: [p.String, 'en'],\n                rounding: [p.String, 'round'],\n            });\n        };\n        NumberFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n            var _this = this;\n            var _a = this, format = _a.format, language = _a.language;\n            var rounding = (function () {\n                switch (_this.rounding) {\n                    case \"round\":\n                    case \"nearest\": return Math.round;\n                    case \"floor\":\n                    case \"rounddown\": return Math.floor;\n                    case \"ceil\":\n                    case \"roundup\": return Math.ceil;\n                }\n            })();\n            value = Numbro.format(value, format, language, rounding);\n            return _super.prototype.doFormat.call(this, row, cell, value, columnDef, dataContext);\n        };\n        return NumberFormatter;\n    }(StringFormatter));\n    exports.NumberFormatter = NumberFormatter;\n    NumberFormatter.initClass();\n    var BooleanFormatter = /** @class */ (function (_super) {\n        tslib_1.__extends(BooleanFormatter, _super);\n        function BooleanFormatter(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        BooleanFormatter.initClass = function () {\n            this.prototype.type = 'BooleanFormatter';\n            this.define({\n                icon: [p.String, 'check'],\n            });\n        };\n        BooleanFormatter.prototype.doFormat = function (_row, _cell, value, _columnDef, _dataContext) {\n            return !!value ? dom_1.i({ class: this.icon }).outerHTML : \"\";\n        };\n        return BooleanFormatter;\n    }(CellFormatter));\n    exports.BooleanFormatter = BooleanFormatter;\n    BooleanFormatter.initClass();\n    var DateFormatter = /** @class */ (function (_super) {\n        tslib_1.__extends(DateFormatter, _super);\n        function DateFormatter(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        DateFormatter.initClass = function () {\n            this.prototype.type = 'DateFormatter';\n            this.define({\n                format: [p.String, 'ISO-8601'],\n            });\n        };\n        DateFormatter.prototype.getFormat = function () {\n            // using definitions provided here: https://api.jqueryui.com/datepicker/\n            // except not implementing TICKS\n            switch (this.format) {\n                case \"ATOM\":\n                case \"W3C\":\n                case \"RFC-3339\":\n                case \"ISO-8601\":\n                    return \"%Y-%m-%d\";\n                case \"COOKIE\":\n                    return \"%a, %d %b %Y\";\n                case \"RFC-850\":\n                    return \"%A, %d-%b-%y\";\n                case \"RFC-1123\":\n                case \"RFC-2822\":\n                    return \"%a, %e %b %Y\";\n                case \"RSS\":\n                case \"RFC-822\":\n                case \"RFC-1036\":\n                    return \"%a, %e %b %y\";\n                case \"TIMESTAMP\":\n                    return undefined;\n                default:\n                    return this.format;\n            }\n        };\n        DateFormatter.prototype.doFormat = function (row, cell, value, columnDef, dataContext) {\n            value = types_1.isString(value) ? parseInt(value, 10) : value;\n            var date = tz(value, this.getFormat());\n            return _super.prototype.doFormat.call(this, row, cell, date, columnDef, dataContext);\n        };\n        return DateFormatter;\n    }(CellFormatter));\n    exports.DateFormatter = DateFormatter;\n    DateFormatter.initClass();\n    var HTMLTemplateFormatter = /** @class */ (function (_super) {\n        tslib_1.__extends(HTMLTemplateFormatter, _super);\n        function HTMLTemplateFormatter(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        HTMLTemplateFormatter.initClass = function () {\n            this.prototype.type = 'HTMLTemplateFormatter';\n            this.define({\n                template: [p.String, '<%= value %>'],\n            });\n        };\n        HTMLTemplateFormatter.prototype.doFormat = function (_row, _cell, value, _columnDef, dataContext) {\n            var template = this.template;\n            if (value == null)\n                return \"\";\n            else {\n                var compiled_template = compile_template(template);\n                var context = tslib_1.__assign({}, dataContext, { value: value });\n                return compiled_template(context);\n            }\n        };\n        return HTMLTemplateFormatter;\n    }(CellFormatter));\n    exports.HTMLTemplateFormatter = HTMLTemplateFormatter;\n    HTMLTemplateFormatter.initClass();\n}\n","/* models/widgets/tables/data_table */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    var SlickGrid = require(444) /* slickgrid */.Grid;\n    var RowSelectionModel = require(442) /* slickgrid/plugins/slick.rowselectionmodel */.RowSelectionModel;\n    var CheckboxSelectColumn = require(441) /* slickgrid/plugins/slick.checkboxselectcolumn */.CheckboxSelectColumn;\n    var p = require(15) /* core/properties */;\n    var string_1 = require(38) /* core/util/string */;\n    var array_1 = require(21) /* core/util/array */;\n    var object_1 = require(32) /* core/util/object */;\n    var logging_1 = require(14) /* core/logging */;\n    var table_widget_1 = require(436) /* ./table_widget */;\n    var widget_1 = require(437) /* ../widget */;\n    exports.DTINDEX_NAME = \"__bkdt_internal_index__\";\n    var DataProvider = /** @class */ (function () {\n        function DataProvider(source, view) {\n            this.source = source;\n            this.view = view;\n            if (exports.DTINDEX_NAME in this.source.data)\n                throw new Error(\"special name \" + exports.DTINDEX_NAME + \" cannot be used as a data table column\");\n            this.index = this.view.indices;\n        }\n        DataProvider.prototype.getLength = function () {\n            return this.index.length;\n        };\n        DataProvider.prototype.getItem = function (offset) {\n            var item = {};\n            for (var _i = 0, _a = object_1.keys(this.source.data); _i < _a.length; _i++) {\n                var field = _a[_i];\n                item[field] = this.source.data[field][this.index[offset]];\n            }\n            item[exports.DTINDEX_NAME] = this.index[offset];\n            return item;\n        };\n        DataProvider.prototype.setItem = function (offset, item) {\n            for (var field in item) {\n                // internal index is maintained independently, ignore\n                var value = item[field];\n                if (field != exports.DTINDEX_NAME) {\n                    this.source.data[field][this.index[offset]] = value;\n                }\n            }\n            this._update_source_inplace();\n        };\n        DataProvider.prototype.getField = function (offset, field) {\n            if (field == exports.DTINDEX_NAME) {\n                return this.index[offset];\n            }\n            return this.source.data[field][this.index[offset]];\n        };\n        DataProvider.prototype.setField = function (offset, field, value) {\n            // field assumed never to be internal index name (ctor would throw)\n            this.source.data[field][this.index[offset]] = value;\n            this._update_source_inplace();\n        };\n        DataProvider.prototype.getItemMetadata = function (_index) {\n            return null;\n        };\n        DataProvider.prototype.getRecords = function () {\n            var _this = this;\n            return array_1.range(0, this.getLength()).map(function (i) { return _this.getItem(i); });\n        };\n        DataProvider.prototype.sort = function (columns) {\n            var cols = columns.map(function (column) { return [column.sortCol.field, column.sortAsc ? 1 : -1]; });\n            if (cols.length == 0) {\n                cols = [[exports.DTINDEX_NAME, 1]];\n            }\n            var records = this.getRecords();\n            var old_index = this.index.slice();\n            this.index.sort(function (i1, i2) {\n                for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n                    var _a = cols_1[_i], field = _a[0], sign = _a[1];\n                    var value1 = records[old_index.indexOf(i1)][field];\n                    var value2 = records[old_index.indexOf(i2)][field];\n                    var result = value1 == value2 ? 0 : value1 > value2 ? sign : -sign;\n                    if (result != 0)\n                        return result;\n                }\n                return 0;\n            });\n        };\n        DataProvider.prototype._update_source_inplace = function () {\n            this.source.properties.data.change.emit();\n        };\n        return DataProvider;\n    }());\n    exports.DataProvider = DataProvider;\n    var DataTableView = /** @class */ (function (_super) {\n        tslib_1.__extends(DataTableView, _super);\n        function DataTableView() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._in_selection_update = false;\n            _this._warned_not_reorderable = false;\n            return _this;\n        }\n        DataTableView.prototype.connect_signals = function () {\n            var _this = this;\n            _super.prototype.connect_signals.call(this);\n            this.connect(this.model.change, function () { return _this.render(); });\n            this.connect(this.model.source.streaming, function () { return _this.updateGrid(); });\n            this.connect(this.model.source.patching, function () { return _this.updateGrid(); });\n            this.connect(this.model.source.change, function () { return _this.updateGrid(true); });\n            this.connect(this.model.source.properties.data.change, function () { return _this.updateGrid(); });\n            this.connect(this.model.source.selected.change, function () { return _this.updateSelection(); });\n        };\n        DataTableView.prototype.updateGrid = function (from_source_change) {\n            if (from_source_change === void 0) {\n                from_source_change = false;\n            }\n            // TODO (bev) This is to enure that CDSView indices are properly computed\n            // before passing to the DataProvider. This will result in extra calls to\n            // compute_indices. This \"over execution\" will be addressed in a more\n            // general look at events\n            this.model.view.compute_indices();\n            this.data.constructor(this.model.source, this.model.view);\n            this.grid.invalidate();\n            this.grid.render();\n            if (!from_source_change) {\n                // This is only needed to call @_tell_document_about_change()\n                this.model.source.data = this.model.source.data;\n                this.model.source.change.emit();\n            }\n        };\n        DataTableView.prototype.updateSelection = function () {\n            var _this = this;\n            if (this._in_selection_update)\n                return;\n            var selected = this.model.source.selected;\n            var permuted_indices = selected.indices.map(function (x) { return _this.data.index.indexOf(x); });\n            this._in_selection_update = true;\n            this.grid.setSelectedRows(permuted_indices);\n            this._in_selection_update = false;\n            // If the selection is not in the current slickgrid viewport, scroll the\n            // datatable to start at the row before the first selected row, so that\n            // the selection is immediately brought into view. We don't scroll when\n            // the selection is already in the viewport so that selecting from the\n            // datatable itself does not re-scroll.\n            var cur_grid_range = this.grid.getViewport();\n            var scroll_index = this.model.get_scroll_index(cur_grid_range, permuted_indices);\n            if (scroll_index != null)\n                this.grid.scrollRowToTop(scroll_index);\n        };\n        DataTableView.prototype.newIndexColumn = function () {\n            return {\n                id: string_1.uniqueId(),\n                name: this.model.index_header,\n                field: exports.DTINDEX_NAME,\n                width: this.model.index_width,\n                behavior: \"select\",\n                cannotTriggerInsert: true,\n                resizable: false,\n                selectable: false,\n                sortable: true,\n                cssClass: \"bk-cell-index\",\n                headerCssClass: \"bk-header-index\",\n            };\n        };\n        DataTableView.prototype.css_classes = function () {\n            return _super.prototype.css_classes.call(this).concat(\"bk-data-table\");\n        };\n        DataTableView.prototype.render = function () {\n            var _this = this;\n            var checkboxSelector;\n            var columns = this.model.columns.map(function (column) { return column.toColumn(); });\n            if (this.model.selectable == \"checkbox\") {\n                checkboxSelector = new CheckboxSelectColumn({ cssClass: \"bk-cell-select\" });\n                columns.unshift(checkboxSelector.getColumnDefinition());\n            }\n            if (this.model.index_position != null) {\n                var index_position = this.model.index_position;\n                var index = this.newIndexColumn();\n                // This is to be able to provide negative index behaviour that\n                // matches what python users will expect\n                if (index_position == -1) {\n                    columns.push(index);\n                }\n                else if (index_position < -1) {\n                    columns.splice(index_position + 1, 0, index);\n                }\n                else {\n                    columns.splice(index_position, 0, index);\n                }\n            }\n            var reorderable = this.model.reorderable;\n            if (reorderable && !(typeof $ !== \"undefined\" && $.fn != null && $.fn.sortable != null)) {\n                if (!this._warned_not_reorderable) {\n                    logging_1.logger.warn(\"jquery-ui is required to enable DataTable.reorderable\");\n                    this._warned_not_reorderable = true;\n                }\n                reorderable = false;\n            }\n            var options = {\n                enableCellNavigation: this.model.selectable !== false,\n                enableColumnReorder: reorderable,\n                forceFitColumns: this.model.fit_columns,\n                autoHeight: this.model.height == \"auto\",\n                multiColumnSort: this.model.sortable,\n                editable: this.model.editable,\n                autoEdit: false,\n            };\n            if (this.model.width != null)\n                this.el.style.width = this.model.width + \"px\";\n            else\n                this.el.style.width = this.model.default_width + \"px\";\n            if (this.model.height != null && this.model.height != \"auto\")\n                this.el.style.height = this.model.height + \"px\";\n            this.data = new DataProvider(this.model.source, this.model.view);\n            this.grid = new SlickGrid(this.el, this.data, columns, options);\n            this.grid.onSort.subscribe(function (_event, args) {\n                columns = args.sortCols;\n                _this.data.sort(columns);\n                _this.grid.invalidate();\n                _this.updateSelection();\n                _this.grid.render();\n                if (!_this.model.header_row) {\n                    _this._hide_header();\n                }\n            });\n            if (this.model.selectable !== false) {\n                this.grid.setSelectionModel(new RowSelectionModel({ selectActiveRow: checkboxSelector == null }));\n                if (checkboxSelector != null)\n                    this.grid.registerPlugin(checkboxSelector);\n                this.grid.onSelectedRowsChanged.subscribe(function (_event, args) {\n                    if (_this._in_selection_update) {\n                        return;\n                    }\n                    _this.model.source.selected.indices = args.rows.map(function (i) { return _this.data.index[i]; });\n                });\n                this.updateSelection();\n                if (!this.model.header_row) {\n                    this._hide_header();\n                }\n            }\n        };\n        DataTableView.prototype._hide_header = function () {\n            for (var _i = 0, _a = Array.from(this.el.querySelectorAll('.slick-header-columns')); _i < _a.length; _i++) {\n                var el = _a[_i];\n                el.style.height = \"0px\";\n            }\n            this.grid.resizeCanvas();\n        };\n        return DataTableView;\n    }(widget_1.WidgetView));\n    exports.DataTableView = DataTableView;\n    var DataTable = /** @class */ (function (_super) {\n        tslib_1.__extends(DataTable, _super);\n        function DataTable(attrs) {\n            var _this = _super.call(this, attrs) || this;\n            _this.default_width = 600;\n            return _this;\n        }\n        DataTable.initClass = function () {\n            this.prototype.type = 'DataTable';\n            this.prototype.default_view = DataTableView;\n            this.define({\n                columns: [p.Array, []],\n                fit_columns: [p.Bool, true],\n                sortable: [p.Bool, true],\n                reorderable: [p.Bool, true],\n                editable: [p.Bool, false],\n                selectable: [p.Any, true],\n                index_position: [p.Int, 0],\n                index_header: [p.String, \"#\"],\n                index_width: [p.Int, 40],\n                scroll_to_selection: [p.Bool, true],\n                header_row: [p.Bool, true],\n            });\n            this.override({\n                height: 400,\n            });\n        };\n        DataTable.prototype.get_scroll_index = function (grid_range, selected_indices) {\n            if (!this.scroll_to_selection || (selected_indices.length == 0))\n                return null;\n            if (!array_1.any(selected_indices, function (i) { return grid_range.top <= i && i <= grid_range.bottom; })) {\n                return Math.max(0, Math.min.apply(Math, selected_indices) - 1);\n            }\n            return null;\n        };\n        return DataTable;\n    }(table_widget_1.TableWidget));\n    exports.DataTable = DataTable;\n    DataTable.initClass();\n}\n","/* models/widgets/tables/index */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    tslib_1.__exportStar(require(430) /* ./cell_editors */, exports);\n    tslib_1.__exportStar(require(431) /* ./cell_formatters */, exports);\n    var data_table_1 = require(432) /* ./data_table */;\n    exports.DataTable = data_table_1.DataTable;\n    var table_column_1 = require(435) /* ./table_column */;\n    exports.TableColumn = table_column_1.TableColumn;\n    var table_widget_1 = require(436) /* ./table_widget */;\n    exports.TableWidget = table_widget_1.TableWidget;\n}\n","/* models/widgets/tables/main */ function _(require, module, exports) {\n    var Tables = require(433) /* ./index */;\n    exports.Tables = Tables;\n    var base_1 = require(0) /* ../../../base */;\n    base_1.register_models(Tables);\n}\n","/* models/widgets/tables/table_column */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    var cell_formatters_1 = require(431) /* ./cell_formatters */;\n    var cell_editors_1 = require(430) /* ./cell_editors */;\n    var p = require(15) /* core/properties */;\n    var string_1 = require(38) /* core/util/string */;\n    var model_1 = require(57) /* ../../../model */;\n    var TableColumn = /** @class */ (function (_super) {\n        tslib_1.__extends(TableColumn, _super);\n        function TableColumn(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        TableColumn.initClass = function () {\n            this.prototype.type = 'TableColumn';\n            this.define({\n                field: [p.String],\n                title: [p.String],\n                width: [p.Number, 300],\n                formatter: [p.Instance, function () { return new cell_formatters_1.StringFormatter(); }],\n                editor: [p.Instance, function () { return new cell_editors_1.StringEditor(); }],\n                sortable: [p.Bool, true],\n                default_sort: [p.String, \"ascending\"],\n            });\n        };\n        TableColumn.prototype.toColumn = function () {\n            return {\n                id: string_1.uniqueId(),\n                field: this.field,\n                name: this.title,\n                width: this.width,\n                formatter: this.formatter != null ? this.formatter.doFormat.bind(this.formatter) : undefined,\n                model: this.editor,\n                editor: this.editor.default_view,\n                sortable: this.sortable,\n                defaultSortAsc: this.default_sort == \"ascending\",\n            };\n        };\n        return TableColumn;\n    }(model_1.Model));\n    exports.TableColumn = TableColumn;\n    TableColumn.initClass();\n}\n","/* models/widgets/tables/table_widget */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    var widget_1 = require(437) /* ../widget */;\n    var cds_view_1 = require(196) /* ../../sources/cds_view */;\n    var p = require(15) /* core/properties */;\n    var TableWidget = /** @class */ (function (_super) {\n        tslib_1.__extends(TableWidget, _super);\n        function TableWidget(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        TableWidget.initClass = function () {\n            this.prototype.type = \"TableWidget\";\n            this.define({\n                source: [p.Instance],\n                view: [p.Instance, function () { return new cds_view_1.CDSView(); }],\n            });\n        };\n        TableWidget.prototype.initialize = function () {\n            _super.prototype.initialize.call(this);\n            if (this.view.source == null) {\n                this.view.source = this.source;\n                this.view.compute_indices();\n            }\n        };\n        return TableWidget;\n    }(widget_1.Widget));\n    exports.TableWidget = TableWidget;\n    TableWidget.initClass();\n}\n","/* models/widgets/widget */ function _(require, module, exports) {\n    var tslib_1 = require(388) /* tslib */;\n    var layout_dom_1 = require(154) /* ../layouts/layout_dom */;\n    var WidgetView = /** @class */ (function (_super) {\n        tslib_1.__extends(WidgetView, _super);\n        function WidgetView() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        WidgetView.prototype.css_classes = function () {\n            return _super.prototype.css_classes.call(this).concat(\"bk-widget\");\n        };\n        WidgetView.prototype.render = function () {\n            this._render_classes(); // XXX: because no super()\n            // LayoutDOMView sets up lots of helpful things, but\n            // it's render method is not suitable for widgets - who\n            // should provide their own.\n            if (this.model.height != null)\n                this.el.style.height = this.model.height + \"px\";\n            if (this.model.width != null)\n                this.el.style.width = this.model.width + \"px\";\n        };\n        WidgetView.prototype.get_width = function () {\n            throw new Error(\"unused\");\n        };\n        WidgetView.prototype.get_height = function () {\n            throw new Error(\"unused\");\n        };\n        return WidgetView;\n    }(layout_dom_1.LayoutDOMView));\n    exports.WidgetView = WidgetView;\n    var Widget = /** @class */ (function (_super) {\n        tslib_1.__extends(Widget, _super);\n        function Widget(attrs) {\n            return _super.call(this, attrs) || this;\n        }\n        Widget.initClass = function () {\n            this.prototype.type = \"Widget\";\n        };\n        return Widget;\n    }(layout_dom_1.LayoutDOM));\n    exports.Widget = Widget;\n    Widget.initClass();\n}\n","/* jquery/dist/jquery */ function _(require, module, exports) {\n    /*!\n     * jQuery JavaScript Library v3.2.1\n     * https://jquery.com/\n     *\n     * Includes Sizzle.js\n     * https://sizzlejs.com/\n     *\n     * Copyright JS Foundation and other contributors\n     * Released under the MIT license\n     * https://jquery.org/license\n     *\n     * Date: 2017-03-20T18:59Z\n     */\n    (function (global, factory) {\n        \"use strict\";\n        if (typeof module === \"object\" && typeof module.exports === \"object\") {\n            // For CommonJS and CommonJS-like environments where a proper `window`\n            // is present, execute the factory and get jQuery.\n            // For environments that do not have a `window` with a `document`\n            // (such as Node.js), expose a factory as module.exports.\n            // This accentuates the need for the creation of a real `window`.\n            // e.g. var jQuery = require(\"jquery\")(window);\n            // See ticket #14549 for more info.\n            module.exports = global.document ?\n                factory(global, true) :\n                function (w) {\n                    if (!w.document) {\n                        throw new Error(\"jQuery requires a window with a document\");\n                    }\n                    return factory(w);\n                };\n        }\n        else {\n            factory(global);\n        }\n        // Pass this if window is not defined yet\n    })(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n        // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n        // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n        // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n        // enough that all such attempts are guarded in a try block.\n        \"use strict\";\n        var arr = [];\n        var document = window.document;\n        var getProto = Object.getPrototypeOf;\n        var slice = arr.slice;\n        var concat = arr.concat;\n        var push = arr.push;\n        var indexOf = arr.indexOf;\n        var class2type = {};\n        var toString = class2type.toString;\n        var hasOwn = class2type.hasOwnProperty;\n        var fnToString = hasOwn.toString;\n        var ObjectFunctionString = fnToString.call(Object);\n        var support = {};\n        function DOMEval(code, doc) {\n            doc = doc || document;\n            var script = doc.createElement(\"script\");\n            script.text = code;\n            doc.head.appendChild(script).parentNode.removeChild(script);\n        }\n        /* global Symbol */\n        // Defining this global in .eslintrc.json would create a danger of using the global\n        // unguarded in another place, it seems safer to define global only for this module\n        var version = \"3.2.1\", \n        // Define a local copy of jQuery\n        jQuery = function (selector, context) {\n            // The jQuery object is actually just the init constructor 'enhanced'\n            // Need init if jQuery is called (just allow error to be thrown if not included)\n            return new jQuery.fn.init(selector, context);\n        }, \n        // Support: Android <=4.0 only\n        // Make sure we trim BOM and NBSP\n        rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \n        // Matches dashed string for camelizing\n        rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, \n        // Used by jQuery.camelCase as callback to replace()\n        fcamelCase = function (all, letter) {\n            return letter.toUpperCase();\n        };\n        jQuery.fn = jQuery.prototype = {\n            // The current version of jQuery being used\n            jquery: version,\n            constructor: jQuery,\n            // The default length of a jQuery object is 0\n            length: 0,\n            toArray: function () {\n                return slice.call(this);\n            },\n            // Get the Nth element in the matched element set OR\n            // Get the whole matched element set as a clean array\n            get: function (num) {\n                // Return all the elements in a clean array\n                if (num == null) {\n                    return slice.call(this);\n                }\n                // Return just the one element from the set\n                return num < 0 ? this[num + this.length] : this[num];\n            },\n            // Take an array of elements and push it onto the stack\n            // (returning the new matched element set)\n            pushStack: function (elems) {\n                // Build a new jQuery matched element set\n                var ret = jQuery.merge(this.constructor(), elems);\n                // Add the old object onto the stack (as a reference)\n                ret.prevObject = this;\n                // Return the newly-formed element set\n                return ret;\n            },\n            // Execute a callback for every element in the matched set.\n            each: function (callback) {\n                return jQuery.each(this, callback);\n            },\n            map: function (callback) {\n                return this.pushStack(jQuery.map(this, function (elem, i) {\n                    return callback.call(elem, i, elem);\n                }));\n            },\n            slice: function () {\n                return this.pushStack(slice.apply(this, arguments));\n            },\n            first: function () {\n                return this.eq(0);\n            },\n            last: function () {\n                return this.eq(-1);\n            },\n            eq: function (i) {\n                var len = this.length, j = +i + (i < 0 ? len : 0);\n                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n            },\n            end: function () {\n                return this.prevObject || this.constructor();\n            },\n            // For internal use only.\n            // Behaves like an Array's method, not like a jQuery method.\n            push: push,\n            sort: arr.sort,\n            splice: arr.splice\n        };\n        jQuery.extend = jQuery.fn.extend = function () {\n            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;\n            // Handle a deep copy situation\n            if (typeof target === \"boolean\") {\n                deep = target;\n                // Skip the boolean and the target\n                target = arguments[i] || {};\n                i++;\n            }\n            // Handle case when target is a string or something (possible in deep copy)\n            if (typeof target !== \"object\" && !jQuery.isFunction(target)) {\n                target = {};\n            }\n            // Extend jQuery itself if only one argument is passed\n            if (i === length) {\n                target = this;\n                i--;\n            }\n            for (; i < length; i++) {\n                // Only deal with non-null/undefined values\n                if ((options = arguments[i]) != null) {\n                    // Extend the base object\n                    for (name in options) {\n                        src = target[name];\n                        copy = options[name];\n                        // Prevent never-ending loop\n                        if (target === copy) {\n                            continue;\n                        }\n                        // Recurse if we're merging plain objects or arrays\n                        if (deep && copy && (jQuery.isPlainObject(copy) ||\n                            (copyIsArray = Array.isArray(copy)))) {\n                            if (copyIsArray) {\n                                copyIsArray = false;\n                                clone = src && Array.isArray(src) ? src : [];\n                            }\n                            else {\n                                clone = src && jQuery.isPlainObject(src) ? src : {};\n                            }\n                            // Never move original objects, clone them\n                            target[name] = jQuery.extend(deep, clone, copy);\n                            // Don't bring in undefined values\n                        }\n                        else if (copy !== undefined) {\n                            target[name] = copy;\n                        }\n                    }\n                }\n            }\n            // Return the modified object\n            return target;\n        };\n        jQuery.extend({\n            // Unique for each copy of jQuery on the page\n            expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n            // Assume jQuery is ready without the ready module\n            isReady: true,\n            error: function (msg) {\n                throw new Error(msg);\n            },\n            noop: function () { },\n            isFunction: function (obj) {\n                return jQuery.type(obj) === \"function\";\n            },\n            isWindow: function (obj) {\n                return obj != null && obj === obj.window;\n            },\n            isNumeric: function (obj) {\n                // As of jQuery 3.0, isNumeric is limited to\n                // strings and numbers (primitives or objects)\n                // that can be coerced to finite numbers (gh-2662)\n                var type = jQuery.type(obj);\n                return (type === \"number\" || type === \"string\") &&\n                    // parseFloat NaNs numeric-cast false positives (\"\")\n                    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n                    // subtraction forces infinities to NaN\n                    !isNaN(obj - parseFloat(obj));\n            },\n            isPlainObject: function (obj) {\n                var proto, Ctor;\n                // Detect obvious negatives\n                // Use toString instead of jQuery.type to catch host objects\n                if (!obj || toString.call(obj) !== \"[object Object]\") {\n                    return false;\n                }\n                proto = getProto(obj);\n                // Objects with no prototype (e.g., `Object.create( null )`) are plain\n                if (!proto) {\n                    return true;\n                }\n                // Objects with prototype are plain iff they were constructed by a global Object function\n                Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n                return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n            },\n            isEmptyObject: function (obj) {\n                /* eslint-disable no-unused-vars */\n                // See https://github.com/eslint/eslint/issues/6125\n                var name;\n                for (name in obj) {\n                    return false;\n                }\n                return true;\n            },\n            type: function (obj) {\n                if (obj == null) {\n                    return obj + \"\";\n                }\n                // Support: Android <=2.3 only (functionish RegExp)\n                return typeof obj === \"object\" || typeof obj === \"function\" ?\n                    class2type[toString.call(obj)] || \"object\" :\n                    typeof obj;\n            },\n            // Evaluates a script in a global context\n            globalEval: function (code) {\n                DOMEval(code);\n            },\n            // Convert dashed to camelCase; used by the css and data modules\n            // Support: IE <=9 - 11, Edge 12 - 13\n            // Microsoft forgot to hump their vendor prefix (#9572)\n            camelCase: function (string) {\n                return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n            },\n            each: function (obj, callback) {\n                var length, i = 0;\n                if (isArrayLike(obj)) {\n                    length = obj.length;\n                    for (; i < length; i++) {\n                        if (callback.call(obj[i], i, obj[i]) === false) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (i in obj) {\n                        if (callback.call(obj[i], i, obj[i]) === false) {\n                            break;\n                        }\n                    }\n                }\n                return obj;\n            },\n            // Support: Android <=4.0 only\n            trim: function (text) {\n                return text == null ?\n                    \"\" :\n                    (text + \"\").replace(rtrim, \"\");\n            },\n            // results is for internal usage only\n            makeArray: function (arr, results) {\n                var ret = results || [];\n                if (arr != null) {\n                    if (isArrayLike(Object(arr))) {\n                        jQuery.merge(ret, typeof arr === \"string\" ?\n                            [arr] : arr);\n                    }\n                    else {\n                        push.call(ret, arr);\n                    }\n                }\n                return ret;\n            },\n            inArray: function (elem, arr, i) {\n                return arr == null ? -1 : indexOf.call(arr, elem, i);\n            },\n            // Support: Android <=4.0 only, PhantomJS 1 only\n            // push.apply(_, arraylike) throws on ancient WebKit\n            merge: function (first, second) {\n                var len = +second.length, j = 0, i = first.length;\n                for (; j < len; j++) {\n                    first[i++] = second[j];\n                }\n                first.length = i;\n                return first;\n            },\n            grep: function (elems, callback, invert) {\n                var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;\n                // Go through the array, only saving the items\n                // that pass the validator function\n                for (; i < length; i++) {\n                    callbackInverse = !callback(elems[i], i);\n                    if (callbackInverse !== callbackExpect) {\n                        matches.push(elems[i]);\n                    }\n                }\n                return matches;\n            },\n            // arg is for internal usage only\n            map: function (elems, callback, arg) {\n                var length, value, i = 0, ret = [];\n                // Go through the array, translating each of the items to their new values\n                if (isArrayLike(elems)) {\n                    length = elems.length;\n                    for (; i < length; i++) {\n                        value = callback(elems[i], i, arg);\n                        if (value != null) {\n                            ret.push(value);\n                        }\n                    }\n                    // Go through every key on the object,\n                }\n                else {\n                    for (i in elems) {\n                        value = callback(elems[i], i, arg);\n                        if (value != null) {\n                            ret.push(value);\n                        }\n                    }\n                }\n                // Flatten any nested arrays\n                return concat.apply([], ret);\n            },\n            // A global GUID counter for objects\n            guid: 1,\n            // Bind a function to a context, optionally partially applying any\n            // arguments.\n            proxy: function (fn, context) {\n                var tmp, args, proxy;\n                if (typeof context === \"string\") {\n                    tmp = fn[context];\n                    context = fn;\n                    fn = tmp;\n                }\n                // Quick check to determine if target is callable, in the spec\n                // this throws a TypeError, but we will just return undefined.\n                if (!jQuery.isFunction(fn)) {\n                    return undefined;\n                }\n                // Simulated bind\n                args = slice.call(arguments, 2);\n                proxy = function () {\n                    return fn.apply(context || this, args.concat(slice.call(arguments)));\n                };\n                // Set the guid of unique handler to the same of original handler, so it can be removed\n                proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n                return proxy;\n            },\n            now: Date.now,\n            // jQuery.support is not used in Core but other projects attach their\n            // properties to it so it needs to exist.\n            support: support\n        });\n        if (typeof Symbol === \"function\") {\n            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n        }\n        // Populate the class2type map\n        jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (i, name) {\n            class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n        });\n        function isArrayLike(obj) {\n            // Support: real iOS 8.2 only (not reproducible in simulator)\n            // `in` check used to prevent JIT error (gh-2145)\n            // hasOwn isn't used here due to false negatives\n            // regarding Nodelist length in IE\n            var length = !!obj && \"length\" in obj && obj.length, type = jQuery.type(obj);\n            if (type === \"function\" || jQuery.isWindow(obj)) {\n                return false;\n            }\n            return type === \"array\" || length === 0 ||\n                typeof length === \"number\" && length > 0 && (length - 1) in obj;\n        }\n        var Sizzle = \n        /*!\n         * Sizzle CSS Selector Engine v2.3.3\n         * https://sizzlejs.com/\n         *\n         * Copyright jQuery Foundation and other contributors\n         * Released under the MIT license\n         * http://jquery.org/license\n         *\n         * Date: 2016-08-08\n         */\n        (function (window) {\n            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, \n            // Local document vars\n            setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, \n            // Instance-specific data\n            expando = \"sizzle\" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {\n                if (a === b) {\n                    hasDuplicate = true;\n                }\n                return 0;\n            }, \n            // Instance methods\n            hasOwn = ({}).hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, \n            // Use a stripped-down indexOf as it's faster than native\n            // https://jsperf.com/thor-indexof-vs-for/5\n            indexOf = function (list, elem) {\n                var i = 0, len = list.length;\n                for (; i < len; i++) {\n                    if (list[i] === elem) {\n                        return i;\n                    }\n                }\n                return -1;\n            }, booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\", \n            // Regular expressions\n            // http://www.w3.org/TR/css3-selectors/#whitespace\n            whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\", \n            // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n            identifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\", \n            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n            attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n                // Operator (capture 2)\n                \"*([*^$|!~]?=)\" + whitespace +\n                // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n                \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n                \"*\\\\]\", pseudos = \":(\" + identifier + \")(?:\\\\((\" +\n                // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n                // 1. quoted (capture 3; capture 4 or capture 5)\n                \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n                // 2. simple (capture 6)\n                \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n                // 3. anything else (capture 2)\n                \".*\" +\n                \")\\\\)|)\", \n            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n            rwhitespace = new RegExp(whitespace + \"+\", \"g\"), rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"), rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"), rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"), rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp(\"^\" + identifier + \"$\"), matchExpr = {\n                \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n                \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n                \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n                \"ATTR\": new RegExp(\"^\" + attributes),\n                \"PSEUDO\": new RegExp(\"^\" + pseudos),\n                \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n                    \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n                    \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n                \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n                // For use in libraries implementing .is()\n                // We use this for POS matching in `select`\n                \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n                    whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\\d$/i, rnative = /^[^{]+\\{\\s*\\[native \\w/, \n            // Easily-parseable/retrievable ID or TAG or CLASS selectors\n            rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/, rsibling = /[+~]/, \n            // CSS escapes\n            // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n            runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"), funescape = function (_, escaped, escapedWhitespace) {\n                var high = \"0x\" + escaped - 0x10000;\n                // NaN means non-codepoint\n                // Support: Firefox<24\n                // Workaround erroneous numeric interpretation of +\"0x\"\n                return high !== high || escapedWhitespace ?\n                    escaped :\n                    high < 0 ?\n                        // BMP codepoint\n                        String.fromCharCode(high + 0x10000) :\n                        // Supplemental Plane codepoint (surrogate pair)\n                        String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n            }, \n            // CSS string/identifier serialization\n            // https://drafts.csswg.org/cssom/#common-serializing-idioms\n            rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g, fcssescape = function (ch, asCodePoint) {\n                if (asCodePoint) {\n                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n                    if (ch === \"\\0\") {\n                        return \"\\uFFFD\";\n                    }\n                    // Control characters and (dependent upon position) numbers get escaped as code points\n                    return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n                }\n                // Other potentially-special ASCII characters get backslash-escaped\n                return \"\\\\\" + ch;\n            }, \n            // Used for iframes\n            // See setDocument()\n            // Removing the function wrapper causes a \"Permission Denied\"\n            // error in IE\n            unloadHandler = function () {\n                setDocument();\n            }, disabledAncestor = addCombinator(function (elem) {\n                return elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n            }, { dir: \"parentNode\", next: \"legend\" });\n            // Optimize for push.apply( _, NodeList )\n            try {\n                push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);\n                // Support: Android<4.0\n                // Detect silently failing push.apply\n                arr[preferredDoc.childNodes.length].nodeType;\n            }\n            catch (e) {\n                push = { apply: arr.length ?\n                        // Leverage slice if possible\n                        function (target, els) {\n                            push_native.apply(target, slice.call(els));\n                        } :\n                        // Support: IE<9\n                        // Otherwise append directly\n                        function (target, els) {\n                            var j = target.length, i = 0;\n                            // Can't trust NodeList.length\n                            while ((target[j++] = els[i++])) { }\n                            target.length = j - 1;\n                        }\n                };\n            }\n            function Sizzle(selector, context, results, seed) {\n                var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, \n                // nodeType defaults to 9, since context defaults to document\n                nodeType = context ? context.nodeType : 9;\n                results = results || [];\n                // Return early from calls with invalid selector or context\n                if (typeof selector !== \"string\" || !selector ||\n                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n                    return results;\n                }\n                // Try to shortcut find operations (as opposed to filters) in HTML documents\n                if (!seed) {\n                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n                        setDocument(context);\n                    }\n                    context = context || document;\n                    if (documentIsHTML) {\n                        // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n                        // (excepting DocumentFragment context, where the methods don't exist)\n                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n                            // ID selector\n                            if ((m = match[1])) {\n                                // Document context\n                                if (nodeType === 9) {\n                                    if ((elem = context.getElementById(m))) {\n                                        // Support: IE, Opera, Webkit\n                                        // TODO: identify versions\n                                        // getElementById can match elements by name instead of ID\n                                        if (elem.id === m) {\n                                            results.push(elem);\n                                            return results;\n                                        }\n                                    }\n                                    else {\n                                        return results;\n                                    }\n                                    // Element context\n                                }\n                                else {\n                                    // Support: IE, Opera, Webkit\n                                    // TODO: identify versions\n                                    // getElementById can match elements by name instead of ID\n                                    if (newContext && (elem = newContext.getElementById(m)) &&\n                                        contains(context, elem) &&\n                                        elem.id === m) {\n                                        results.push(elem);\n                                        return results;\n                                    }\n                                }\n                                // Type selector\n                            }\n                            else if (match[2]) {\n                                push.apply(results, context.getElementsByTagName(selector));\n                                return results;\n                                // Class selector\n                            }\n                            else if ((m = match[3]) && support.getElementsByClassName &&\n                                context.getElementsByClassName) {\n                                push.apply(results, context.getElementsByClassName(m));\n                                return results;\n                            }\n                        }\n                        // Take advantage of querySelectorAll\n                        if (support.qsa &&\n                            !compilerCache[selector + \" \"] &&\n                            (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n                            if (nodeType !== 1) {\n                                newContext = context;\n                                newSelector = selector;\n                                // qSA looks outside Element context, which is not what we want\n                                // Thanks to Andrew Dupont for this workaround technique\n                                // Support: IE <=8\n                                // Exclude object elements\n                            }\n                            else if (context.nodeName.toLowerCase() !== \"object\") {\n                                // Capture the context ID, setting it first if necessary\n                                if ((nid = context.getAttribute(\"id\"))) {\n                                    nid = nid.replace(rcssescape, fcssescape);\n                                }\n                                else {\n                                    context.setAttribute(\"id\", (nid = expando));\n                                }\n                                // Prefix every selector in the list\n                                groups = tokenize(selector);\n                                i = groups.length;\n                                while (i--) {\n                                    groups[i] = \"#\" + nid + \" \" + toSelector(groups[i]);\n                                }\n                                newSelector = groups.join(\",\");\n                                // Expand context for sibling selectors\n                                newContext = rsibling.test(selector) && testContext(context.parentNode) ||\n                                    context;\n                            }\n                            if (newSelector) {\n                                try {\n                                    push.apply(results, newContext.querySelectorAll(newSelector));\n                                    return results;\n                                }\n                                catch (qsaError) {\n                                }\n                                finally {\n                                    if (nid === expando) {\n                                        context.removeAttribute(\"id\");\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                // All others\n                return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n            }\n            /**\n             * Create key-value caches of limited size\n             * @returns {function(string, object)} Returns the Object data after storing it on itself with\n             *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n             *\tdeleting the oldest entry\n             */\n            function createCache() {\n                var keys = [];\n                function cache(key, value) {\n                    // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n                    if (keys.push(key + \" \") > Expr.cacheLength) {\n                        // Only keep the most recent entries\n                        delete cache[keys.shift()];\n                    }\n                    return (cache[key + \" \"] = value);\n                }\n                return cache;\n            }\n            /**\n             * Mark a function for special use by Sizzle\n             * @param {Function} fn The function to mark\n             */\n            function markFunction(fn) {\n                fn[expando] = true;\n                return fn;\n            }\n            /**\n             * Support testing using an element\n             * @param {Function} fn Passed the created element and returns a boolean result\n             */\n            function assert(fn) {\n                var el = document.createElement(\"fieldset\");\n                try {\n                    return !!fn(el);\n                }\n                catch (e) {\n                    return false;\n                }\n                finally {\n                    // Remove from its parent by default\n                    if (el.parentNode) {\n                        el.parentNode.removeChild(el);\n                    }\n                    // release memory in IE\n                    el = null;\n                }\n            }\n            /**\n             * Adds the same handler for all of the specified attrs\n             * @param {String} attrs Pipe-separated list of attributes\n             * @param {Function} handler The method that will be applied\n             */\n            function addHandle(attrs, handler) {\n                var arr = attrs.split(\"|\"), i = arr.length;\n                while (i--) {\n                    Expr.attrHandle[arr[i]] = handler;\n                }\n            }\n            /**\n             * Checks document order of two siblings\n             * @param {Element} a\n             * @param {Element} b\n             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n             */\n            function siblingCheck(a, b) {\n                var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n                    a.sourceIndex - b.sourceIndex;\n                // Use IE sourceIndex if available on both nodes\n                if (diff) {\n                    return diff;\n                }\n                // Check if b follows a\n                if (cur) {\n                    while ((cur = cur.nextSibling)) {\n                        if (cur === b) {\n                            return -1;\n                        }\n                    }\n                }\n                return a ? 1 : -1;\n            }\n            /**\n             * Returns a function to use in pseudos for input types\n             * @param {String} type\n             */\n            function createInputPseudo(type) {\n                return function (elem) {\n                    var name = elem.nodeName.toLowerCase();\n                    return name === \"input\" && elem.type === type;\n                };\n            }\n            /**\n             * Returns a function to use in pseudos for buttons\n             * @param {String} type\n             */\n            function createButtonPseudo(type) {\n                return function (elem) {\n                    var name = elem.nodeName.toLowerCase();\n                    return (name === \"input\" || name === \"button\") && elem.type === type;\n                };\n            }\n            /**\n             * Returns a function to use in pseudos for :enabled/:disabled\n             * @param {Boolean} disabled true for :disabled; false for :enabled\n             */\n            function createDisabledPseudo(disabled) {\n                // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n                return function (elem) {\n                    // Only certain elements can match :enabled or :disabled\n                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n                    if (\"form\" in elem) {\n                        // Check for inherited disabledness on relevant non-disabled elements:\n                        // * listed form-associated elements in a disabled fieldset\n                        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n                        // * option elements in a disabled optgroup\n                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n                        // All such elements have a \"form\" property.\n                        if (elem.parentNode && elem.disabled === false) {\n                            // Option elements defer to a parent optgroup if present\n                            if (\"label\" in elem) {\n                                if (\"label\" in elem.parentNode) {\n                                    return elem.parentNode.disabled === disabled;\n                                }\n                                else {\n                                    return elem.disabled === disabled;\n                                }\n                            }\n                            // Support: IE 6 - 11\n                            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n                            return elem.isDisabled === disabled ||\n                                // Where there is no isDisabled, check manually\n                                /* jshint -W018 */\n                                elem.isDisabled !== !disabled &&\n                                    disabledAncestor(elem) === disabled;\n                        }\n                        return elem.disabled === disabled;\n                        // Try to winnow out elements that can't be disabled before trusting the disabled property.\n                        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n                        // even exist on them, let alone have a boolean value.\n                    }\n                    else if (\"label\" in elem) {\n                        return elem.disabled === disabled;\n                    }\n                    // Remaining elements are neither :enabled nor :disabled\n                    return false;\n                };\n            }\n            /**\n             * Returns a function to use in pseudos for positionals\n             * @param {Function} fn\n             */\n            function createPositionalPseudo(fn) {\n                return markFunction(function (argument) {\n                    argument = +argument;\n                    return markFunction(function (seed, matches) {\n                        var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;\n                        // Match elements found at the specified indexes\n                        while (i--) {\n                            if (seed[(j = matchIndexes[i])]) {\n                                seed[j] = !(matches[j] = seed[j]);\n                            }\n                        }\n                    });\n                });\n            }\n            /**\n             * Checks a node for validity as a Sizzle context\n             * @param {Element|Object=} context\n             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n             */\n            function testContext(context) {\n                return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n            }\n            // Expose support vars for convenience\n            support = Sizzle.support = {};\n            /**\n             * Detects XML nodes\n             * @param {Element|Object} elem An element or a document\n             * @returns {Boolean} True iff elem is a non-HTML XML node\n             */\n            isXML = Sizzle.isXML = function (elem) {\n                // documentElement is verified for cases where it doesn't yet exist\n                // (such as loading iframes in IE - #4833)\n                var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n                return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n            };\n            /**\n             * Sets document-related variables once based on the current document\n             * @param {Element|Object} [doc] An element or document object to use to set the document\n             * @returns {Object} Returns the current document\n             */\n            setDocument = Sizzle.setDocument = function (node) {\n                var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;\n                // Return early if doc is invalid or already selected\n                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n                    return document;\n                }\n                // Update global variables\n                document = doc;\n                docElem = document.documentElement;\n                documentIsHTML = !isXML(document);\n                // Support: IE 9-11, Edge\n                // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n                if (preferredDoc !== document &&\n                    (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n                    // Support: IE 11, Edge\n                    if (subWindow.addEventListener) {\n                        subWindow.addEventListener(\"unload\", unloadHandler, false);\n                        // Support: IE 9 - 10 only\n                    }\n                    else if (subWindow.attachEvent) {\n                        subWindow.attachEvent(\"onunload\", unloadHandler);\n                    }\n                }\n                /* Attributes\n                ---------------------------------------------------------------------- */\n                // Support: IE<8\n                // Verify that getAttribute really returns attributes and not properties\n                // (excepting IE8 booleans)\n                support.attributes = assert(function (el) {\n                    el.className = \"i\";\n                    return !el.getAttribute(\"className\");\n                });\n                /* getElement(s)By*\n                ---------------------------------------------------------------------- */\n                // Check if getElementsByTagName(\"*\") returns only elements\n                support.getElementsByTagName = assert(function (el) {\n                    el.appendChild(document.createComment(\"\"));\n                    return !el.getElementsByTagName(\"*\").length;\n                });\n                // Support: IE<9\n                support.getElementsByClassName = rnative.test(document.getElementsByClassName);\n                // Support: IE<10\n                // Check if getElementById returns elements by name\n                // The broken getElementById methods don't pick up programmatically-set names,\n                // so use a roundabout getElementsByName test\n                support.getById = assert(function (el) {\n                    docElem.appendChild(el).id = expando;\n                    return !document.getElementsByName || !document.getElementsByName(expando).length;\n                });\n                // ID filter and find\n                if (support.getById) {\n                    Expr.filter[\"ID\"] = function (id) {\n                        var attrId = id.replace(runescape, funescape);\n                        return function (elem) {\n                            return elem.getAttribute(\"id\") === attrId;\n                        };\n                    };\n                    Expr.find[\"ID\"] = function (id, context) {\n                        if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n                            var elem = context.getElementById(id);\n                            return elem ? [elem] : [];\n                        }\n                    };\n                }\n                else {\n                    Expr.filter[\"ID\"] = function (id) {\n                        var attrId = id.replace(runescape, funescape);\n                        return function (elem) {\n                            var node = typeof elem.getAttributeNode !== \"undefined\" &&\n                                elem.getAttributeNode(\"id\");\n                            return node && node.value === attrId;\n                        };\n                    };\n                    // Support: IE 6 - 7 only\n                    // getElementById is not reliable as a find shortcut\n                    Expr.find[\"ID\"] = function (id, context) {\n                        if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n                            var node, i, elems, elem = context.getElementById(id);\n                            if (elem) {\n                                // Verify the id attribute\n                                node = elem.getAttributeNode(\"id\");\n                                if (node && node.value === id) {\n                                    return [elem];\n                                }\n                                // Fall back on getElementsByName\n                                elems = context.getElementsByName(id);\n                                i = 0;\n                                while ((elem = elems[i++])) {\n                                    node = elem.getAttributeNode(\"id\");\n                                    if (node && node.value === id) {\n                                        return [elem];\n                                    }\n                                }\n                            }\n                            return [];\n                        }\n                    };\n                }\n                // Tag\n                Expr.find[\"TAG\"] = support.getElementsByTagName ?\n                    function (tag, context) {\n                        if (typeof context.getElementsByTagName !== \"undefined\") {\n                            return context.getElementsByTagName(tag);\n                            // DocumentFragment nodes don't have gEBTN\n                        }\n                        else if (support.qsa) {\n                            return context.querySelectorAll(tag);\n                        }\n                    } :\n                    function (tag, context) {\n                        var elem, tmp = [], i = 0, \n                        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n                        results = context.getElementsByTagName(tag);\n                        // Filter out possible comments\n                        if (tag === \"*\") {\n                            while ((elem = results[i++])) {\n                                if (elem.nodeType === 1) {\n                                    tmp.push(elem);\n                                }\n                            }\n                            return tmp;\n                        }\n                        return results;\n                    };\n                // Class\n                Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n                    if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n                        return context.getElementsByClassName(className);\n                    }\n                };\n                /* QSA/matchesSelector\n                ---------------------------------------------------------------------- */\n                // QSA and matchesSelector support\n                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n                rbuggyMatches = [];\n                // qSa(:focus) reports false when true (Chrome 21)\n                // We allow this because of a bug in IE8/9 that throws an error\n                // whenever `document.activeElement` is accessed on an iframe\n                // So, we allow :focus to pass through QSA all the time to avoid the IE error\n                // See https://bugs.jquery.com/ticket/13378\n                rbuggyQSA = [];\n                if ((support.qsa = rnative.test(document.querySelectorAll))) {\n                    // Build QSA regex\n                    // Regex strategy adopted from Diego Perini\n                    assert(function (el) {\n                        // Select is set to empty string on purpose\n                        // This is to test IE's treatment of not explicitly\n                        // setting a boolean content attribute,\n                        // since its presence should be enough\n                        // https://bugs.jquery.com/ticket/12359\n                        docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n                            \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n                            \"<option selected=''></option></select>\";\n                        // Support: IE8, Opera 11-12.16\n                        // Nothing should be selected when empty strings follow ^= or $= or *=\n                        // The test attribute must be unknown in Opera but \"safe\" for WinRT\n                        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n                        if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n                            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n                        }\n                        // Support: IE8\n                        // Boolean attributes and \"value\" are not treated correctly\n                        if (!el.querySelectorAll(\"[selected]\").length) {\n                            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n                        }\n                        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n                        if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n                            rbuggyQSA.push(\"~=\");\n                        }\n                        // Webkit/Opera - :checked should return selected option elements\n                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n                        // IE8 throws error here and will not see later tests\n                        if (!el.querySelectorAll(\":checked\").length) {\n                            rbuggyQSA.push(\":checked\");\n                        }\n                        // Support: Safari 8+, iOS 8+\n                        // https://bugs.webkit.org/show_bug.cgi?id=136851\n                        // In-page `selector#id sibling-combinator selector` fails\n                        if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n                            rbuggyQSA.push(\".#.+[+~]\");\n                        }\n                    });\n                    assert(function (el) {\n                        el.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n                            \"<select disabled='disabled'><option/></select>\";\n                        // Support: Windows 8 Native Apps\n                        // The type and name attributes are restricted during .innerHTML assignment\n                        var input = document.createElement(\"input\");\n                        input.setAttribute(\"type\", \"hidden\");\n                        el.appendChild(input).setAttribute(\"name\", \"D\");\n                        // Support: IE8\n                        // Enforce case-sensitivity of name attribute\n                        if (el.querySelectorAll(\"[name=d]\").length) {\n                            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n                        }\n                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n                        // IE8 throws error here and will not see later tests\n                        if (el.querySelectorAll(\":enabled\").length !== 2) {\n                            rbuggyQSA.push(\":enabled\", \":disabled\");\n                        }\n                        // Support: IE9-11+\n                        // IE's :disabled selector does not pick up the children of disabled fieldsets\n                        docElem.appendChild(el).disabled = true;\n                        if (el.querySelectorAll(\":disabled\").length !== 2) {\n                            rbuggyQSA.push(\":enabled\", \":disabled\");\n                        }\n                        // Opera 10-11 does not throw on post-comma invalid pseudos\n                        el.querySelectorAll(\"*,:x\");\n                        rbuggyQSA.push(\",.*:\");\n                    });\n                }\n                if ((support.matchesSelector = rnative.test((matches = docElem.matches ||\n                    docElem.webkitMatchesSelector ||\n                    docElem.mozMatchesSelector ||\n                    docElem.oMatchesSelector ||\n                    docElem.msMatchesSelector)))) {\n                    assert(function (el) {\n                        // Check to see if it's possible to do matchesSelector\n                        // on a disconnected node (IE 9)\n                        support.disconnectedMatch = matches.call(el, \"*\");\n                        // This should fail with an exception\n                        // Gecko does not error, returns false instead\n                        matches.call(el, \"[s!='']:x\");\n                        rbuggyMatches.push(\"!=\", pseudos);\n                    });\n                }\n                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n                /* Contains\n                ---------------------------------------------------------------------- */\n                hasCompare = rnative.test(docElem.compareDocumentPosition);\n                // Element contains another\n                // Purposefully self-exclusive\n                // As in, an element does not contain itself\n                contains = hasCompare || rnative.test(docElem.contains) ?\n                    function (a, b) {\n                        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;\n                        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ?\n                            adown.contains(bup) :\n                            a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n                    } :\n                    function (a, b) {\n                        if (b) {\n                            while ((b = b.parentNode)) {\n                                if (b === a) {\n                                    return true;\n                                }\n                            }\n                        }\n                        return false;\n                    };\n                /* Sorting\n                ---------------------------------------------------------------------- */\n                // Document order sorting\n                sortOrder = hasCompare ?\n                    function (a, b) {\n                        // Flag for duplicate removal\n                        if (a === b) {\n                            hasDuplicate = true;\n                            return 0;\n                        }\n                        // Sort on method existence if only one input has compareDocumentPosition\n                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n                        if (compare) {\n                            return compare;\n                        }\n                        // Calculate position if both inputs belong to the same document\n                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?\n                            a.compareDocumentPosition(b) :\n                            // Otherwise we know they are disconnected\n                            1;\n                        // Disconnected nodes\n                        if (compare & 1 ||\n                            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {\n                            // Choose the first element that is related to our preferred document\n                            if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n                                return -1;\n                            }\n                            if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n                                return 1;\n                            }\n                            // Maintain original order\n                            return sortInput ?\n                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :\n                                0;\n                        }\n                        return compare & 4 ? -1 : 1;\n                    } :\n                    function (a, b) {\n                        // Exit early if the nodes are identical\n                        if (a === b) {\n                            hasDuplicate = true;\n                            return 0;\n                        }\n                        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];\n                        // Parentless nodes are either documents or disconnected\n                        if (!aup || !bup) {\n                            return a === document ? -1 :\n                                b === document ? 1 :\n                                    aup ? -1 :\n                                        bup ? 1 :\n                                            sortInput ?\n                                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :\n                                                0;\n                            // If the nodes are siblings, we can do a quick check\n                        }\n                        else if (aup === bup) {\n                            return siblingCheck(a, b);\n                        }\n                        // Otherwise we need full lists of their ancestors for comparison\n                        cur = a;\n                        while ((cur = cur.parentNode)) {\n                            ap.unshift(cur);\n                        }\n                        cur = b;\n                        while ((cur = cur.parentNode)) {\n                            bp.unshift(cur);\n                        }\n                        // Walk down the tree looking for a discrepancy\n                        while (ap[i] === bp[i]) {\n                            i++;\n                        }\n                        return i ?\n                            // Do a sibling check if the nodes have a common ancestor\n                            siblingCheck(ap[i], bp[i]) :\n                            // Otherwise nodes in our document sort first\n                            ap[i] === preferredDoc ? -1 :\n                                bp[i] === preferredDoc ? 1 :\n                                    0;\n                    };\n                return document;\n            };\n            Sizzle.matches = function (expr, elements) {\n                return Sizzle(expr, null, null, elements);\n            };\n            Sizzle.matchesSelector = function (elem, expr) {\n                // Set document vars if needed\n                if ((elem.ownerDocument || elem) !== document) {\n                    setDocument(elem);\n                }\n                // Make sure that attribute selectors are quoted\n                expr = expr.replace(rattributeQuotes, \"='$1']\");\n                if (support.matchesSelector && documentIsHTML &&\n                    !compilerCache[expr + \" \"] &&\n                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&\n                    (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n                    try {\n                        var ret = matches.call(elem, expr);\n                        // IE 9's matchesSelector returns false on disconnected nodes\n                        if (ret || support.disconnectedMatch ||\n                            // As well, disconnected nodes are said to be in a document\n                            // fragment in IE 9\n                            elem.document && elem.document.nodeType !== 11) {\n                            return ret;\n                        }\n                    }\n                    catch (e) { }\n                }\n                return Sizzle(expr, document, null, [elem]).length > 0;\n            };\n            Sizzle.contains = function (context, elem) {\n                // Set document vars if needed\n                if ((context.ownerDocument || context) !== document) {\n                    setDocument(context);\n                }\n                return contains(context, elem);\n            };\n            Sizzle.attr = function (elem, name) {\n                // Set document vars if needed\n                if ((elem.ownerDocument || elem) !== document) {\n                    setDocument(elem);\n                }\n                var fn = Expr.attrHandle[name.toLowerCase()], \n                // Don't get fooled by Object.prototype properties (jQuery #13807)\n                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?\n                    fn(elem, name, !documentIsHTML) :\n                    undefined;\n                return val !== undefined ?\n                    val :\n                    support.attributes || !documentIsHTML ?\n                        elem.getAttribute(name) :\n                        (val = elem.getAttributeNode(name)) && val.specified ?\n                            val.value :\n                            null;\n            };\n            Sizzle.escape = function (sel) {\n                return (sel + \"\").replace(rcssescape, fcssescape);\n            };\n            Sizzle.error = function (msg) {\n                throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n            };\n            /**\n             * Document sorting and removing duplicates\n             * @param {ArrayLike} results\n             */\n            Sizzle.uniqueSort = function (results) {\n                var elem, duplicates = [], j = 0, i = 0;\n                // Unless we *know* we can detect duplicates, assume their presence\n                hasDuplicate = !support.detectDuplicates;\n                sortInput = !support.sortStable && results.slice(0);\n                results.sort(sortOrder);\n                if (hasDuplicate) {\n                    while ((elem = results[i++])) {\n                        if (elem === results[i]) {\n                            j = duplicates.push(i);\n                        }\n                    }\n                    while (j--) {\n                        results.splice(duplicates[j], 1);\n                    }\n                }\n                // Clear input after sorting to release objects\n                // See https://github.com/jquery/sizzle/pull/225\n                sortInput = null;\n                return results;\n            };\n            /**\n             * Utility function for retrieving the text value of an array of DOM nodes\n             * @param {Array|Element} elem\n             */\n            getText = Sizzle.getText = function (elem) {\n                var node, ret = \"\", i = 0, nodeType = elem.nodeType;\n                if (!nodeType) {\n                    // If no nodeType, this is expected to be an array\n                    while ((node = elem[i++])) {\n                        // Do not traverse comment nodes\n                        ret += getText(node);\n                    }\n                }\n                else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n                    // Use textContent for elements\n                    // innerText usage removed for consistency of new lines (jQuery #11153)\n                    if (typeof elem.textContent === \"string\") {\n                        return elem.textContent;\n                    }\n                    else {\n                        // Traverse its children\n                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n                            ret += getText(elem);\n                        }\n                    }\n                }\n                else if (nodeType === 3 || nodeType === 4) {\n                    return elem.nodeValue;\n                }\n                // Do not include comment or processing instruction nodes\n                return ret;\n            };\n            Expr = Sizzle.selectors = {\n                // Can be adjusted by the user\n                cacheLength: 50,\n                createPseudo: markFunction,\n                match: matchExpr,\n                attrHandle: {},\n                find: {},\n                relative: {\n                    \">\": { dir: \"parentNode\", first: true },\n                    \" \": { dir: \"parentNode\" },\n                    \"+\": { dir: \"previousSibling\", first: true },\n                    \"~\": { dir: \"previousSibling\" }\n                },\n                preFilter: {\n                    \"ATTR\": function (match) {\n                        match[1] = match[1].replace(runescape, funescape);\n                        // Move the given value to match[3] whether quoted or unquoted\n                        match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n                        if (match[2] === \"~=\") {\n                            match[3] = \" \" + match[3] + \" \";\n                        }\n                        return match.slice(0, 4);\n                    },\n                    \"CHILD\": function (match) {\n                        /* matches from matchExpr[\"CHILD\"]\n                            1 type (only|nth|...)\n                            2 what (child|of-type)\n                            3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n                            4 xn-component of xn+y argument ([+-]?\\d*n|)\n                            5 sign of xn-component\n                            6 x of xn-component\n                            7 sign of y-component\n                            8 y of y-component\n                        */\n                        match[1] = match[1].toLowerCase();\n                        if (match[1].slice(0, 3) === \"nth\") {\n                            // nth-* requires argument\n                            if (!match[3]) {\n                                Sizzle.error(match[0]);\n                            }\n                            // numeric x and y parameters for Expr.filter.CHILD\n                            // remember that false/true cast respectively to 0/1\n                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n                            match[5] = +((match[7] + match[8]) || match[3] === \"odd\");\n                            // other types prohibit arguments\n                        }\n                        else if (match[3]) {\n                            Sizzle.error(match[0]);\n                        }\n                        return match;\n                    },\n                    \"PSEUDO\": function (match) {\n                        var excess, unquoted = !match[6] && match[2];\n                        if (matchExpr[\"CHILD\"].test(match[0])) {\n                            return null;\n                        }\n                        // Accept quoted arguments as-is\n                        if (match[3]) {\n                            match[2] = match[4] || match[5] || \"\";\n                            // Strip excess characters from unquoted arguments\n                        }\n                        else if (unquoted && rpseudo.test(unquoted) &&\n                            // Get excess from tokenize (recursively)\n                            (excess = tokenize(unquoted, true)) &&\n                            // advance to the next closing parenthesis\n                            (excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n                            // excess is a negative index\n                            match[0] = match[0].slice(0, excess);\n                            match[2] = unquoted.slice(0, excess);\n                        }\n                        // Return only captures needed by the pseudo filter method (type and argument)\n                        return match.slice(0, 3);\n                    }\n                },\n                filter: {\n                    \"TAG\": function (nodeNameSelector) {\n                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n                        return nodeNameSelector === \"*\" ?\n                            function () { return true; } :\n                            function (elem) {\n                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n                            };\n                    },\n                    \"CLASS\": function (className) {\n                        var pattern = classCache[className + \" \"];\n                        return pattern ||\n                            (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) &&\n                                classCache(className, function (elem) {\n                                    return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n                                });\n                    },\n                    \"ATTR\": function (name, operator, check) {\n                        return function (elem) {\n                            var result = Sizzle.attr(elem, name);\n                            if (result == null) {\n                                return operator === \"!=\";\n                            }\n                            if (!operator) {\n                                return true;\n                            }\n                            result += \"\";\n                            return operator === \"=\" ? result === check :\n                                operator === \"!=\" ? result !== check :\n                                    operator === \"^=\" ? check && result.indexOf(check) === 0 :\n                                        operator === \"*=\" ? check && result.indexOf(check) > -1 :\n                                            operator === \"$=\" ? check && result.slice(-check.length) === check :\n                                                operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 :\n                                                    operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" :\n                                                        false;\n                        };\n                    },\n                    \"CHILD\": function (type, what, argument, first, last) {\n                        var simple = type.slice(0, 3) !== \"nth\", forward = type.slice(-4) !== \"last\", ofType = what === \"of-type\";\n                        return first === 1 && last === 0 ?\n                            // Shortcut for :nth-*(n)\n                            function (elem) {\n                                return !!elem.parentNode;\n                            } :\n                            function (elem, context, xml) {\n                                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? \"nextSibling\" : \"previousSibling\", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;\n                                if (parent) {\n                                    // :(first|last|only)-(child|of-type)\n                                    if (simple) {\n                                        while (dir) {\n                                            node = elem;\n                                            while ((node = node[dir])) {\n                                                if (ofType ?\n                                                    node.nodeName.toLowerCase() === name :\n                                                    node.nodeType === 1) {\n                                                    return false;\n                                                }\n                                            }\n                                            // Reverse direction for :only-* (if we haven't yet done so)\n                                            start = dir = type === \"only\" && !start && \"nextSibling\";\n                                        }\n                                        return true;\n                                    }\n                                    start = [forward ? parent.firstChild : parent.lastChild];\n                                    // non-xml :nth-child(...) stores cache data on `parent`\n                                    if (forward && useCache) {\n                                        // Seek `elem` from a previously-cached index\n                                        // ...in a gzip-friendly way\n                                        node = parent;\n                                        outerCache = node[expando] || (node[expando] = {});\n                                        // Support: IE <9 only\n                                        // Defend against cloned attroperties (jQuery gh-1709)\n                                        uniqueCache = outerCache[node.uniqueID] ||\n                                            (outerCache[node.uniqueID] = {});\n                                        cache = uniqueCache[type] || [];\n                                        nodeIndex = cache[0] === dirruns && cache[1];\n                                        diff = nodeIndex && cache[2];\n                                        node = nodeIndex && parent.childNodes[nodeIndex];\n                                        while ((node = ++nodeIndex && node && node[dir] ||\n                                            // Fallback to seeking `elem` from the start\n                                            (diff = nodeIndex = 0) || start.pop())) {\n                                            // When found, cache indexes on `parent` and break\n                                            if (node.nodeType === 1 && ++diff && node === elem) {\n                                                uniqueCache[type] = [dirruns, nodeIndex, diff];\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        // Use previously-cached element index if available\n                                        if (useCache) {\n                                            // ...in a gzip-friendly way\n                                            node = elem;\n                                            outerCache = node[expando] || (node[expando] = {});\n                                            // Support: IE <9 only\n                                            // Defend against cloned attroperties (jQuery gh-1709)\n                                            uniqueCache = outerCache[node.uniqueID] ||\n                                                (outerCache[node.uniqueID] = {});\n                                            cache = uniqueCache[type] || [];\n                                            nodeIndex = cache[0] === dirruns && cache[1];\n                                            diff = nodeIndex;\n                                        }\n                                        // xml :nth-child(...)\n                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                                        if (diff === false) {\n                                            // Use the same loop as above to seek `elem` from the start\n                                            while ((node = ++nodeIndex && node && node[dir] ||\n                                                (diff = nodeIndex = 0) || start.pop())) {\n                                                if ((ofType ?\n                                                    node.nodeName.toLowerCase() === name :\n                                                    node.nodeType === 1) &&\n                                                    ++diff) {\n                                                    // Cache the index of each encountered element\n                                                    if (useCache) {\n                                                        outerCache = node[expando] || (node[expando] = {});\n                                                        // Support: IE <9 only\n                                                        // Defend against cloned attroperties (jQuery gh-1709)\n                                                        uniqueCache = outerCache[node.uniqueID] ||\n                                                            (outerCache[node.uniqueID] = {});\n                                                        uniqueCache[type] = [dirruns, diff];\n                                                    }\n                                                    if (node === elem) {\n                                                        break;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    // Incorporate the offset, then check against cycle size\n                                    diff -= last;\n                                    return diff === first || (diff % first === 0 && diff / first >= 0);\n                                }\n                            };\n                    },\n                    \"PSEUDO\": function (pseudo, argument) {\n                        // pseudo-class names are case-insensitive\n                        // http://www.w3.org/TR/selectors/#pseudo-classes\n                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n                        // Remember that setFilters inherits from pseudos\n                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||\n                            Sizzle.error(\"unsupported pseudo: \" + pseudo);\n                        // The user may use createPseudo to indicate that\n                        // arguments are needed to create the filter function\n                        // just as Sizzle does\n                        if (fn[expando]) {\n                            return fn(argument);\n                        }\n                        // But maintain support for old signatures\n                        if (fn.length > 1) {\n                            args = [pseudo, pseudo, \"\", argument];\n                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?\n                                markFunction(function (seed, matches) {\n                                    var idx, matched = fn(seed, argument), i = matched.length;\n                                    while (i--) {\n                                        idx = indexOf(seed, matched[i]);\n                                        seed[idx] = !(matches[idx] = matched[i]);\n                                    }\n                                }) :\n                                function (elem) {\n                                    return fn(elem, 0, args);\n                                };\n                        }\n                        return fn;\n                    }\n                },\n                pseudos: {\n                    // Potentially complex pseudos\n                    \"not\": markFunction(function (selector) {\n                        // Trim the selector passed to compile\n                        // to avoid treating leading and trailing\n                        // spaces as combinators\n                        var input = [], results = [], matcher = compile(selector.replace(rtrim, \"$1\"));\n                        return matcher[expando] ?\n                            markFunction(function (seed, matches, context, xml) {\n                                var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;\n                                // Match elements unmatched by `matcher`\n                                while (i--) {\n                                    if ((elem = unmatched[i])) {\n                                        seed[i] = !(matches[i] = elem);\n                                    }\n                                }\n                            }) :\n                            function (elem, context, xml) {\n                                input[0] = elem;\n                                matcher(input, null, xml, results);\n                                // Don't keep the element (issue #299)\n                                input[0] = null;\n                                return !results.pop();\n                            };\n                    }),\n                    \"has\": markFunction(function (selector) {\n                        return function (elem) {\n                            return Sizzle(selector, elem).length > 0;\n                        };\n                    }),\n                    \"contains\": markFunction(function (text) {\n                        text = text.replace(runescape, funescape);\n                        return function (elem) {\n                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n                        };\n                    }),\n                    // \"Whether an element is represented by a :lang() selector\n                    // is based solely on the element's language value\n                    // being equal to the identifier C,\n                    // or beginning with the identifier C immediately followed by \"-\".\n                    // The matching of C against the element's language value is performed case-insensitively.\n                    // The identifier C does not have to be a valid language name.\"\n                    // http://www.w3.org/TR/selectors/#lang-pseudo\n                    \"lang\": markFunction(function (lang) {\n                        // lang value must be a valid identifier\n                        if (!ridentifier.test(lang || \"\")) {\n                            Sizzle.error(\"unsupported lang: \" + lang);\n                        }\n                        lang = lang.replace(runescape, funescape).toLowerCase();\n                        return function (elem) {\n                            var elemLang;\n                            do {\n                                if ((elemLang = documentIsHTML ?\n                                    elem.lang :\n                                    elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\"))) {\n                                    elemLang = elemLang.toLowerCase();\n                                    return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n                                }\n                            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n                            return false;\n                        };\n                    }),\n                    // Miscellaneous\n                    \"target\": function (elem) {\n                        var hash = window.location && window.location.hash;\n                        return hash && hash.slice(1) === elem.id;\n                    },\n                    \"root\": function (elem) {\n                        return elem === docElem;\n                    },\n                    \"focus\": function (elem) {\n                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n                    },\n                    // Boolean properties\n                    \"enabled\": createDisabledPseudo(false),\n                    \"disabled\": createDisabledPseudo(true),\n                    \"checked\": function (elem) {\n                        // In CSS3, :checked should return both checked and selected elements\n                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n                        var nodeName = elem.nodeName.toLowerCase();\n                        return (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n                    },\n                    \"selected\": function (elem) {\n                        // Accessing this property makes selected-by-default\n                        // options in Safari work properly\n                        if (elem.parentNode) {\n                            elem.parentNode.selectedIndex;\n                        }\n                        return elem.selected === true;\n                    },\n                    // Contents\n                    \"empty\": function (elem) {\n                        // http://www.w3.org/TR/selectors/#empty-pseudo\n                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n                        //   but not by others (comment: 8; processing instruction: 7; etc.)\n                        // nodeType < 6 works because attributes (2) do not appear as children\n                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n                            if (elem.nodeType < 6) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    },\n                    \"parent\": function (elem) {\n                        return !Expr.pseudos[\"empty\"](elem);\n                    },\n                    // Element/input types\n                    \"header\": function (elem) {\n                        return rheader.test(elem.nodeName);\n                    },\n                    \"input\": function (elem) {\n                        return rinputs.test(elem.nodeName);\n                    },\n                    \"button\": function (elem) {\n                        var name = elem.nodeName.toLowerCase();\n                        return name === \"input\" && elem.type === \"button\" || name === \"button\";\n                    },\n                    \"text\": function (elem) {\n                        var attr;\n                        return elem.nodeName.toLowerCase() === \"input\" &&\n                            elem.type === \"text\" &&\n                            // Support: IE<8\n                            // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n                            ((attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n                    },\n                    // Position-in-collection\n                    \"first\": createPositionalPseudo(function () {\n                        return [0];\n                    }),\n                    \"last\": createPositionalPseudo(function (matchIndexes, length) {\n                        return [length - 1];\n                    }),\n                    \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n                        return [argument < 0 ? argument + length : argument];\n                    }),\n                    \"even\": createPositionalPseudo(function (matchIndexes, length) {\n                        var i = 0;\n                        for (; i < length; i += 2) {\n                            matchIndexes.push(i);\n                        }\n                        return matchIndexes;\n                    }),\n                    \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n                        var i = 1;\n                        for (; i < length; i += 2) {\n                            matchIndexes.push(i);\n                        }\n                        return matchIndexes;\n                    }),\n                    \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n                        var i = argument < 0 ? argument + length : argument;\n                        for (; --i >= 0;) {\n                            matchIndexes.push(i);\n                        }\n                        return matchIndexes;\n                    }),\n                    \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n                        var i = argument < 0 ? argument + length : argument;\n                        for (; ++i < length;) {\n                            matchIndexes.push(i);\n                        }\n                        return matchIndexes;\n                    })\n                }\n            };\n            Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n            // Add button/input type pseudos\n            for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n                Expr.pseudos[i] = createInputPseudo(i);\n            }\n            for (i in { submit: true, reset: true }) {\n                Expr.pseudos[i] = createButtonPseudo(i);\n            }\n            // Easy API for creating new setFilters\n            function setFilters() { }\n            setFilters.prototype = Expr.filters = Expr.pseudos;\n            Expr.setFilters = new setFilters();\n            tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + \" \"];\n                if (cached) {\n                    return parseOnly ? 0 : cached.slice(0);\n                }\n                soFar = selector;\n                groups = [];\n                preFilters = Expr.preFilter;\n                while (soFar) {\n                    // Comma and first run\n                    if (!matched || (match = rcomma.exec(soFar))) {\n                        if (match) {\n                            // Don't consume trailing commas as valid\n                            soFar = soFar.slice(match[0].length) || soFar;\n                        }\n                        groups.push((tokens = []));\n                    }\n                    matched = false;\n                    // Combinators\n                    if ((match = rcombinators.exec(soFar))) {\n                        matched = match.shift();\n                        tokens.push({\n                            value: matched,\n                            // Cast descendant combinators to space\n                            type: match[0].replace(rtrim, \" \")\n                        });\n                        soFar = soFar.slice(matched.length);\n                    }\n                    // Filters\n                    for (type in Expr.filter) {\n                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||\n                            (match = preFilters[type](match)))) {\n                            matched = match.shift();\n                            tokens.push({\n                                value: matched,\n                                type: type,\n                                matches: match\n                            });\n                            soFar = soFar.slice(matched.length);\n                        }\n                    }\n                    if (!matched) {\n                        break;\n                    }\n                }\n                // Return the length of the invalid excess\n                // if we're just parsing\n                // Otherwise, throw an error or return tokens\n                return parseOnly ?\n                    soFar.length :\n                    soFar ?\n                        Sizzle.error(selector) :\n                        // Cache the tokens\n                        tokenCache(selector, groups).slice(0);\n            };\n            function toSelector(tokens) {\n                var i = 0, len = tokens.length, selector = \"\";\n                for (; i < len; i++) {\n                    selector += tokens[i].value;\n                }\n                return selector;\n            }\n            function addCombinator(matcher, combinator, base) {\n                var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === \"parentNode\", doneName = done++;\n                return combinator.first ?\n                    // Check against closest ancestor/preceding element\n                    function (elem, context, xml) {\n                        while ((elem = elem[dir])) {\n                            if (elem.nodeType === 1 || checkNonElements) {\n                                return matcher(elem, context, xml);\n                            }\n                        }\n                        return false;\n                    } :\n                    // Check against all ancestor/preceding elements\n                    function (elem, context, xml) {\n                        var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];\n                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n                        if (xml) {\n                            while ((elem = elem[dir])) {\n                                if (elem.nodeType === 1 || checkNonElements) {\n                                    if (matcher(elem, context, xml)) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            while ((elem = elem[dir])) {\n                                if (elem.nodeType === 1 || checkNonElements) {\n                                    outerCache = elem[expando] || (elem[expando] = {});\n                                    // Support: IE <9 only\n                                    // Defend against cloned attroperties (jQuery gh-1709)\n                                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n                                    if (skip && skip === elem.nodeName.toLowerCase()) {\n                                        elem = elem[dir] || elem;\n                                    }\n                                    else if ((oldCache = uniqueCache[key]) &&\n                                        oldCache[0] === dirruns && oldCache[1] === doneName) {\n                                        // Assign to newCache so results back-propagate to previous elements\n                                        return (newCache[2] = oldCache[2]);\n                                    }\n                                    else {\n                                        // Reuse newcache so results back-propagate to previous elements\n                                        uniqueCache[key] = newCache;\n                                        // A match means we're done; a fail means we have to keep checking\n                                        if ((newCache[2] = matcher(elem, context, xml))) {\n                                            return true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return false;\n                    };\n            }\n            function elementMatcher(matchers) {\n                return matchers.length > 1 ?\n                    function (elem, context, xml) {\n                        var i = matchers.length;\n                        while (i--) {\n                            if (!matchers[i](elem, context, xml)) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    } :\n                    matchers[0];\n            }\n            function multipleContexts(selector, contexts, results) {\n                var i = 0, len = contexts.length;\n                for (; i < len; i++) {\n                    Sizzle(selector, contexts[i], results);\n                }\n                return results;\n            }\n            function condense(unmatched, map, filter, context, xml) {\n                var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;\n                for (; i < len; i++) {\n                    if ((elem = unmatched[i])) {\n                        if (!filter || filter(elem, context, xml)) {\n                            newUnmatched.push(elem);\n                            if (mapped) {\n                                map.push(i);\n                            }\n                        }\n                    }\n                }\n                return newUnmatched;\n            }\n            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n                if (postFilter && !postFilter[expando]) {\n                    postFilter = setMatcher(postFilter);\n                }\n                if (postFinder && !postFinder[expando]) {\n                    postFinder = setMatcher(postFinder, postSelector);\n                }\n                return markFunction(function (seed, results, context, xml) {\n                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, \n                    // Get initial elements from seed or context\n                    elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []), \n                    // Prefilter to get matcher input, preserving a map for seed-results synchronization\n                    matcherIn = preFilter && (seed || !selector) ?\n                        condense(elems, preMap, preFilter, context, xml) :\n                        elems, matcherOut = matcher ?\n                        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n                        postFinder || (seed ? preFilter : preexisting || postFilter) ?\n                            // ...intermediate processing is necessary\n                            [] :\n                            // ...otherwise use results directly\n                            results :\n                        matcherIn;\n                    // Find primary matches\n                    if (matcher) {\n                        matcher(matcherIn, matcherOut, context, xml);\n                    }\n                    // Apply postFilter\n                    if (postFilter) {\n                        temp = condense(matcherOut, postMap);\n                        postFilter(temp, [], context, xml);\n                        // Un-match failing elements by moving them back to matcherIn\n                        i = temp.length;\n                        while (i--) {\n                            if ((elem = temp[i])) {\n                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n                            }\n                        }\n                    }\n                    if (seed) {\n                        if (postFinder || preFilter) {\n                            if (postFinder) {\n                                // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                                temp = [];\n                                i = matcherOut.length;\n                                while (i--) {\n                                    if ((elem = matcherOut[i])) {\n                                        // Restore matcherIn since elem is not yet a final match\n                                        temp.push((matcherIn[i] = elem));\n                                    }\n                                }\n                                postFinder(null, (matcherOut = []), temp, xml);\n                            }\n                            // Move matched elements from seed to results to keep them synchronized\n                            i = matcherOut.length;\n                            while (i--) {\n                                if ((elem = matcherOut[i]) &&\n                                    (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                                    seed[temp] = !(results[temp] = elem);\n                                }\n                            }\n                        }\n                        // Add elements to results, through postFinder if defined\n                    }\n                    else {\n                        matcherOut = condense(matcherOut === results ?\n                            matcherOut.splice(preexisting, matcherOut.length) :\n                            matcherOut);\n                        if (postFinder) {\n                            postFinder(null, results, matcherOut, xml);\n                        }\n                        else {\n                            push.apply(results, matcherOut);\n                        }\n                    }\n                });\n            }\n            function matcherFromTokens(tokens) {\n                var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[\" \"], i = leadingRelative ? 1 : 0, \n                // The foundational matcher ensures that elements are reachable from top-level context(s)\n                matchContext = addCombinator(function (elem) {\n                    return elem === checkContext;\n                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {\n                    return indexOf(checkContext, elem) > -1;\n                }, implicitRelative, true), matchers = [function (elem, context, xml) {\n                        var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ?\n                            matchContext(elem, context, xml) :\n                            matchAnyContext(elem, context, xml));\n                        // Avoid hanging onto element (issue #299)\n                        checkContext = null;\n                        return ret;\n                    }];\n                for (; i < len; i++) {\n                    if ((matcher = Expr.relative[tokens[i].type])) {\n                        matchers = [addCombinator(elementMatcher(matchers), matcher)];\n                    }\n                    else {\n                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n                        // Return special upon seeing a positional matcher\n                        if (matcher[expando]) {\n                            // Find the next relative operator (if any) for proper handling\n                            j = ++i;\n                            for (; j < len; j++) {\n                                if (Expr.relative[tokens[j].type]) {\n                                    break;\n                                }\n                            }\n                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                            tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));\n                        }\n                        matchers.push(matcher);\n                    }\n                }\n                return elementMatcher(matchers);\n            }\n            function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n                var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {\n                    var elem, j, matcher, matchedCount = 0, i = \"0\", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, \n                    // We must always have either seed elements or outermost context\n                    elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost), \n                    // Use integer dirruns iff this is the outermost matcher\n                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1), len = elems.length;\n                    if (outermost) {\n                        outermostContext = context === document || context || outermost;\n                    }\n                    // Add elements passing elementMatchers directly to results\n                    // Support: IE<9, Safari\n                    // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n                    for (; i !== len && (elem = elems[i]) != null; i++) {\n                        if (byElement && elem) {\n                            j = 0;\n                            if (!context && elem.ownerDocument !== document) {\n                                setDocument(elem);\n                                xml = !documentIsHTML;\n                            }\n                            while ((matcher = elementMatchers[j++])) {\n                                if (matcher(elem, context || document, xml)) {\n                                    results.push(elem);\n                                    break;\n                                }\n                            }\n                            if (outermost) {\n                                dirruns = dirrunsUnique;\n                            }\n                        }\n                        // Track unmatched elements for set filters\n                        if (bySet) {\n                            // They will have gone through all possible matchers\n                            if ((elem = !matcher && elem)) {\n                                matchedCount--;\n                            }\n                            // Lengthen the array for every element, matched or not\n                            if (seed) {\n                                unmatched.push(elem);\n                            }\n                        }\n                    }\n                    // `i` is now the count of elements visited above, and adding it to `matchedCount`\n                    // makes the latter nonnegative.\n                    matchedCount += i;\n                    // Apply set filters to unmatched elements\n                    // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n                    // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n                    // no element matchers and no seed.\n                    // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n                    // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n                    // numerically zero.\n                    if (bySet && i !== matchedCount) {\n                        j = 0;\n                        while ((matcher = setMatchers[j++])) {\n                            matcher(unmatched, setMatched, context, xml);\n                        }\n                        if (seed) {\n                            // Reintegrate element matches to eliminate the need for sorting\n                            if (matchedCount > 0) {\n                                while (i--) {\n                                    if (!(unmatched[i] || setMatched[i])) {\n                                        setMatched[i] = pop.call(results);\n                                    }\n                                }\n                            }\n                            // Discard index placeholder values to get only actual matches\n                            setMatched = condense(setMatched);\n                        }\n                        // Add matches to results\n                        push.apply(results, setMatched);\n                        // Seedless set matches succeeding multiple successful matchers stipulate sorting\n                        if (outermost && !seed && setMatched.length > 0 &&\n                            (matchedCount + setMatchers.length) > 1) {\n                            Sizzle.uniqueSort(results);\n                        }\n                    }\n                    // Override manipulation of globals by nested matchers\n                    if (outermost) {\n                        dirruns = dirrunsUnique;\n                        outermostContext = contextBackup;\n                    }\n                    return unmatched;\n                };\n                return bySet ?\n                    markFunction(superMatcher) :\n                    superMatcher;\n            }\n            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + \" \"];\n                if (!cached) {\n                    // Generate a function of recursive functions that can be used to check each element\n                    if (!match) {\n                        match = tokenize(selector);\n                    }\n                    i = match.length;\n                    while (i--) {\n                        cached = matcherFromTokens(match[i]);\n                        if (cached[expando]) {\n                            setMatchers.push(cached);\n                        }\n                        else {\n                            elementMatchers.push(cached);\n                        }\n                    }\n                    // Cache the compiled function\n                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n                    // Save selector and tokenization\n                    cached.selector = selector;\n                }\n                return cached;\n            };\n            /**\n             * A low-level selection function that works with Sizzle's compiled\n             *  selector functions\n             * @param {String|Function} selector A selector or a pre-compiled\n             *  selector function built with Sizzle.compile\n             * @param {Element} context\n             * @param {Array} [results]\n             * @param {Array} [seed] A set of elements to match against\n             */\n            select = Sizzle.select = function (selector, context, results, seed) {\n                var i, tokens, token, type, find, compiled = typeof selector === \"function\" && selector, match = !seed && tokenize((selector = compiled.selector || selector));\n                results = results || [];\n                // Try to minimize operations if there is only one selector in the list and no seed\n                // (the latter of which guarantees us context)\n                if (match.length === 1) {\n                    // Reduce context if the leading compound selector is an ID\n                    tokens = match[0] = match[0].slice(0);\n                    if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n                        context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n                        context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n                        if (!context) {\n                            return results;\n                            // Precompiled matchers will still verify ancestry, so step up a level\n                        }\n                        else if (compiled) {\n                            context = context.parentNode;\n                        }\n                        selector = selector.slice(tokens.shift().value.length);\n                    }\n                    // Fetch a seed set for right-to-left matching\n                    i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n                    while (i--) {\n                        token = tokens[i];\n                        // Abort if we hit a combinator\n                        if (Expr.relative[(type = token.type)]) {\n                            break;\n                        }\n                        if ((find = Expr.find[type])) {\n                            // Search, expanding context for leading sibling combinators\n                            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {\n                                // If seed is empty or no tokens remain, we can return early\n                                tokens.splice(i, 1);\n                                selector = seed.length && toSelector(tokens);\n                                if (!selector) {\n                                    push.apply(results, seed);\n                                    return results;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                // Compile and execute a filtering function if one is not provided\n                // Provide `match` to avoid retokenization if we modified the selector above\n                (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n                return results;\n            };\n            // One-time assignments\n            // Sort stability\n            support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n            // Support: Chrome 14-35+\n            // Always assume duplicates if they aren't passed to the comparison function\n            support.detectDuplicates = !!hasDuplicate;\n            // Initialize against the default document\n            setDocument();\n            // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n            // Detached nodes confoundingly follow *each other*\n            support.sortDetached = assert(function (el) {\n                // Should return 1, but returns 4 (following)\n                return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n            });\n            // Support: IE<8\n            // Prevent attribute/property \"interpolation\"\n            // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n            if (!assert(function (el) {\n                el.innerHTML = \"<a href='#'></a>\";\n                return el.firstChild.getAttribute(\"href\") === \"#\";\n            })) {\n                addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n                    if (!isXML) {\n                        return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n                    }\n                });\n            }\n            // Support: IE<9\n            // Use defaultValue in place of getAttribute(\"value\")\n            if (!support.attributes || !assert(function (el) {\n                el.innerHTML = \"<input/>\";\n                el.firstChild.setAttribute(\"value\", \"\");\n                return el.firstChild.getAttribute(\"value\") === \"\";\n            })) {\n                addHandle(\"value\", function (elem, name, isXML) {\n                    if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n                        return elem.defaultValue;\n                    }\n                });\n            }\n            // Support: IE<9\n            // Use getAttributeNode to fetch booleans when getAttribute lies\n            if (!assert(function (el) {\n                return el.getAttribute(\"disabled\") == null;\n            })) {\n                addHandle(booleans, function (elem, name, isXML) {\n                    var val;\n                    if (!isXML) {\n                        return elem[name] === true ? name.toLowerCase() :\n                            (val = elem.getAttributeNode(name)) && val.specified ?\n                                val.value :\n                                null;\n                    }\n                });\n            }\n            return Sizzle;\n        })(window);\n        jQuery.find = Sizzle;\n        jQuery.expr = Sizzle.selectors;\n        // Deprecated\n        jQuery.expr[\":\"] = jQuery.expr.pseudos;\n        jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n        jQuery.text = Sizzle.getText;\n        jQuery.isXMLDoc = Sizzle.isXML;\n        jQuery.contains = Sizzle.contains;\n        jQuery.escapeSelector = Sizzle.escape;\n        var dir = function (elem, dir, until) {\n            var matched = [], truncate = until !== undefined;\n            while ((elem = elem[dir]) && elem.nodeType !== 9) {\n                if (elem.nodeType === 1) {\n                    if (truncate && jQuery(elem).is(until)) {\n                        break;\n                    }\n                    matched.push(elem);\n                }\n            }\n            return matched;\n        };\n        var siblings = function (n, elem) {\n            var matched = [];\n            for (; n; n = n.nextSibling) {\n                if (n.nodeType === 1 && n !== elem) {\n                    matched.push(n);\n                }\n            }\n            return matched;\n        };\n        var rneedsContext = jQuery.expr.match.needsContext;\n        function nodeName(elem, name) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n        }\n        ;\n        var rsingleTag = (/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i);\n        var risSimple = /^.[^:#\\[\\.,]*$/;\n        // Implement the identical functionality for filter and not\n        function winnow(elements, qualifier, not) {\n            if (jQuery.isFunction(qualifier)) {\n                return jQuery.grep(elements, function (elem, i) {\n                    return !!qualifier.call(elem, i, elem) !== not;\n                });\n            }\n            // Single element\n            if (qualifier.nodeType) {\n                return jQuery.grep(elements, function (elem) {\n                    return (elem === qualifier) !== not;\n                });\n            }\n            // Arraylike of elements (jQuery, arguments, Array)\n            if (typeof qualifier !== \"string\") {\n                return jQuery.grep(elements, function (elem) {\n                    return (indexOf.call(qualifier, elem) > -1) !== not;\n                });\n            }\n            // Simple selector that can be filtered directly, removing non-Elements\n            if (risSimple.test(qualifier)) {\n                return jQuery.filter(qualifier, elements, not);\n            }\n            // Complex selector, compare the two sets, removing non-Elements\n            qualifier = jQuery.filter(qualifier, elements);\n            return jQuery.grep(elements, function (elem) {\n                return (indexOf.call(qualifier, elem) > -1) !== not && elem.nodeType === 1;\n            });\n        }\n        jQuery.filter = function (expr, elems, not) {\n            var elem = elems[0];\n            if (not) {\n                expr = \":not(\" + expr + \")\";\n            }\n            if (elems.length === 1 && elem.nodeType === 1) {\n                return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n            }\n            return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n                return elem.nodeType === 1;\n            }));\n        };\n        jQuery.fn.extend({\n            find: function (selector) {\n                var i, ret, len = this.length, self = this;\n                if (typeof selector !== \"string\") {\n                    return this.pushStack(jQuery(selector).filter(function () {\n                        for (i = 0; i < len; i++) {\n                            if (jQuery.contains(self[i], this)) {\n                                return true;\n                            }\n                        }\n                    }));\n                }\n                ret = this.pushStack([]);\n                for (i = 0; i < len; i++) {\n                    jQuery.find(selector, self[i], ret);\n                }\n                return len > 1 ? jQuery.uniqueSort(ret) : ret;\n            },\n            filter: function (selector) {\n                return this.pushStack(winnow(this, selector || [], false));\n            },\n            not: function (selector) {\n                return this.pushStack(winnow(this, selector || [], true));\n            },\n            is: function (selector) {\n                return !!winnow(this, \n                // If this is a positional/relative selector, check membership in the returned set\n                // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n                typeof selector === \"string\" && rneedsContext.test(selector) ?\n                    jQuery(selector) :\n                    selector || [], false).length;\n            }\n        });\n        // Initialize a jQuery object\n        // A central reference to the root jQuery(document)\n        var rootjQuery, \n        // A simple way to check for HTML strings\n        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n        // Strict HTML recognition (#11290: must start with <)\n        // Shortcut simple #id case for speed\n        rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {\n            var match, elem;\n            // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n            if (!selector) {\n                return this;\n            }\n            // Method init() accepts an alternate rootjQuery\n            // so migrate can support jQuery.sub (gh-2101)\n            root = root || rootjQuery;\n            // Handle HTML strings\n            if (typeof selector === \"string\") {\n                if (selector[0] === \"<\" &&\n                    selector[selector.length - 1] === \">\" &&\n                    selector.length >= 3) {\n                    // Assume that strings that start and end with <> are HTML and skip the regex check\n                    match = [null, selector, null];\n                }\n                else {\n                    match = rquickExpr.exec(selector);\n                }\n                // Match html or make sure no context is specified for #id\n                if (match && (match[1] || !context)) {\n                    // HANDLE: $(html) -> $(array)\n                    if (match[1]) {\n                        context = context instanceof jQuery ? context[0] : context;\n                        // Option to run scripts is true for back-compat\n                        // Intentionally let the error be thrown if parseHTML is not present\n                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n                        // HANDLE: $(html, props)\n                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n                            for (match in context) {\n                                // Properties of context are called as methods if possible\n                                if (jQuery.isFunction(this[match])) {\n                                    this[match](context[match]);\n                                    // ...and otherwise set as attributes\n                                }\n                                else {\n                                    this.attr(match, context[match]);\n                                }\n                            }\n                        }\n                        return this;\n                        // HANDLE: $(#id)\n                    }\n                    else {\n                        elem = document.getElementById(match[2]);\n                        if (elem) {\n                            // Inject the element directly into the jQuery object\n                            this[0] = elem;\n                            this.length = 1;\n                        }\n                        return this;\n                    }\n                    // HANDLE: $(expr, $(...))\n                }\n                else if (!context || context.jquery) {\n                    return (context || root).find(selector);\n                    // HANDLE: $(expr, context)\n                    // (which is just equivalent to: $(context).find(expr)\n                }\n                else {\n                    return this.constructor(context).find(selector);\n                }\n                // HANDLE: $(DOMElement)\n            }\n            else if (selector.nodeType) {\n                this[0] = selector;\n                this.length = 1;\n                return this;\n                // HANDLE: $(function)\n                // Shortcut for document ready\n            }\n            else if (jQuery.isFunction(selector)) {\n                return root.ready !== undefined ?\n                    root.ready(selector) :\n                    // Execute immediately if ready is not present\n                    selector(jQuery);\n            }\n            return jQuery.makeArray(selector, this);\n        };\n        // Give the init function the jQuery prototype for later instantiation\n        init.prototype = jQuery.fn;\n        // Initialize central reference\n        rootjQuery = jQuery(document);\n        var rparentsprev = /^(?:parents|prev(?:Until|All))/, \n        // Methods guaranteed to produce a unique set when starting from a unique set\n        guaranteedUnique = {\n            children: true,\n            contents: true,\n            next: true,\n            prev: true\n        };\n        jQuery.fn.extend({\n            has: function (target) {\n                var targets = jQuery(target, this), l = targets.length;\n                return this.filter(function () {\n                    var i = 0;\n                    for (; i < l; i++) {\n                        if (jQuery.contains(this, targets[i])) {\n                            return true;\n                        }\n                    }\n                });\n            },\n            closest: function (selectors, context) {\n                var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== \"string\" && jQuery(selectors);\n                // Positional selectors never match, since there's no _selection_ context\n                if (!rneedsContext.test(selectors)) {\n                    for (; i < l; i++) {\n                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n                            // Always skip document fragments\n                            if (cur.nodeType < 11 && (targets ?\n                                targets.index(cur) > -1 :\n                                // Don't pass non-elements to Sizzle\n                                cur.nodeType === 1 &&\n                                    jQuery.find.matchesSelector(cur, selectors))) {\n                                matched.push(cur);\n                                break;\n                            }\n                        }\n                    }\n                }\n                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n            },\n            // Determine the position of an element within the set\n            index: function (elem) {\n                // No argument, return index in parent\n                if (!elem) {\n                    return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;\n                }\n                // Index in selector\n                if (typeof elem === \"string\") {\n                    return indexOf.call(jQuery(elem), this[0]);\n                }\n                // Locate the position of the desired element\n                return indexOf.call(this, \n                // If it receives a jQuery object, the first element is used\n                elem.jquery ? elem[0] : elem);\n            },\n            add: function (selector, context) {\n                return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n            },\n            addBack: function (selector) {\n                return this.add(selector == null ?\n                    this.prevObject : this.prevObject.filter(selector));\n            }\n        });\n        function sibling(cur, dir) {\n            while ((cur = cur[dir]) && cur.nodeType !== 1) { }\n            return cur;\n        }\n        jQuery.each({\n            parent: function (elem) {\n                var parent = elem.parentNode;\n                return parent && parent.nodeType !== 11 ? parent : null;\n            },\n            parents: function (elem) {\n                return dir(elem, \"parentNode\");\n            },\n            parentsUntil: function (elem, i, until) {\n                return dir(elem, \"parentNode\", until);\n            },\n            next: function (elem) {\n                return sibling(elem, \"nextSibling\");\n            },\n            prev: function (elem) {\n                return sibling(elem, \"previousSibling\");\n            },\n            nextAll: function (elem) {\n                return dir(elem, \"nextSibling\");\n            },\n            prevAll: function (elem) {\n                return dir(elem, \"previousSibling\");\n            },\n            nextUntil: function (elem, i, until) {\n                return dir(elem, \"nextSibling\", until);\n            },\n            prevUntil: function (elem, i, until) {\n                return dir(elem, \"previousSibling\", until);\n            },\n            siblings: function (elem) {\n                return siblings((elem.parentNode || {}).firstChild, elem);\n            },\n            children: function (elem) {\n                return siblings(elem.firstChild);\n            },\n            contents: function (elem) {\n                if (nodeName(elem, \"iframe\")) {\n                    return elem.contentDocument;\n                }\n                // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n                // Treat the template element as a regular one in browsers that\n                // don't support it.\n                if (nodeName(elem, \"template\")) {\n                    elem = elem.content || elem;\n                }\n                return jQuery.merge([], elem.childNodes);\n            }\n        }, function (name, fn) {\n            jQuery.fn[name] = function (until, selector) {\n                var matched = jQuery.map(this, fn, until);\n                if (name.slice(-5) !== \"Until\") {\n                    selector = until;\n                }\n                if (selector && typeof selector === \"string\") {\n                    matched = jQuery.filter(selector, matched);\n                }\n                if (this.length > 1) {\n                    // Remove duplicates\n                    if (!guaranteedUnique[name]) {\n                        jQuery.uniqueSort(matched);\n                    }\n                    // Reverse order for parents* and prev-derivatives\n                    if (rparentsprev.test(name)) {\n                        matched.reverse();\n                    }\n                }\n                return this.pushStack(matched);\n            };\n        });\n        var rnothtmlwhite = (/[^\\x20\\t\\r\\n\\f]+/g);\n        // Convert String-formatted options into Object-formatted ones\n        function createOptions(options) {\n            var object = {};\n            jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n                object[flag] = true;\n            });\n            return object;\n        }\n        /*\n         * Create a callback list using the following parameters:\n         *\n         *\toptions: an optional list of space-separated options that will change how\n         *\t\t\tthe callback list behaves or a more traditional option object\n         *\n         * By default a callback list will act like an event callback list and can be\n         * \"fired\" multiple times.\n         *\n         * Possible options:\n         *\n         *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n         *\n         *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n         *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n         *\t\t\t\t\tvalues (like a Deferred)\n         *\n         *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n         *\n         *\tstopOnFalse:\tinterrupt callings when a callback returns false\n         *\n         */\n        jQuery.Callbacks = function (options) {\n            // Convert options from String-formatted to Object-formatted if needed\n            // (we check in cache first)\n            options = typeof options === \"string\" ?\n                createOptions(options) :\n                jQuery.extend({}, options);\n            var // Flag to know if list is currently firing\n            firing, \n            // Last fire value for non-forgettable lists\n            memory, \n            // Flag to know if list was already fired\n            fired, \n            // Flag to prevent firing\n            locked, \n            // Actual callback list\n            list = [], \n            // Queue of execution data for repeatable lists\n            queue = [], \n            // Index of currently firing callback (modified by add/remove as needed)\n            firingIndex = -1, \n            // Fire callbacks\n            fire = function () {\n                // Enforce single-firing\n                locked = locked || options.once;\n                // Execute callbacks for all pending executions,\n                // respecting firingIndex overrides and runtime changes\n                fired = firing = true;\n                for (; queue.length; firingIndex = -1) {\n                    memory = queue.shift();\n                    while (++firingIndex < list.length) {\n                        // Run callback and check for early termination\n                        if (list[firingIndex].apply(memory[0], memory[1]) === false &&\n                            options.stopOnFalse) {\n                            // Jump to end and forget the data so .add doesn't re-fire\n                            firingIndex = list.length;\n                            memory = false;\n                        }\n                    }\n                }\n                // Forget the data if we're done with it\n                if (!options.memory) {\n                    memory = false;\n                }\n                firing = false;\n                // Clean up if we're done firing for good\n                if (locked) {\n                    // Keep an empty list if we have data for future add calls\n                    if (memory) {\n                        list = [];\n                        // Otherwise, this object is spent\n                    }\n                    else {\n                        list = \"\";\n                    }\n                }\n            }, \n            // Actual Callbacks object\n            self = {\n                // Add a callback or a collection of callbacks to the list\n                add: function () {\n                    if (list) {\n                        // If we have memory from a past run, we should fire after adding\n                        if (memory && !firing) {\n                            firingIndex = list.length - 1;\n                            queue.push(memory);\n                        }\n                        (function add(args) {\n                            jQuery.each(args, function (_, arg) {\n                                if (jQuery.isFunction(arg)) {\n                                    if (!options.unique || !self.has(arg)) {\n                                        list.push(arg);\n                                    }\n                                }\n                                else if (arg && arg.length && jQuery.type(arg) !== \"string\") {\n                                    // Inspect recursively\n                                    add(arg);\n                                }\n                            });\n                        })(arguments);\n                        if (memory && !firing) {\n                            fire();\n                        }\n                    }\n                    return this;\n                },\n                // Remove a callback from the list\n                remove: function () {\n                    jQuery.each(arguments, function (_, arg) {\n                        var index;\n                        while ((index = jQuery.inArray(arg, list, index)) > -1) {\n                            list.splice(index, 1);\n                            // Handle firing indexes\n                            if (index <= firingIndex) {\n                                firingIndex--;\n                            }\n                        }\n                    });\n                    return this;\n                },\n                // Check if a given callback is in the list.\n                // If no argument is given, return whether or not list has callbacks attached.\n                has: function (fn) {\n                    return fn ?\n                        jQuery.inArray(fn, list) > -1 :\n                        list.length > 0;\n                },\n                // Remove all callbacks from the list\n                empty: function () {\n                    if (list) {\n                        list = [];\n                    }\n                    return this;\n                },\n                // Disable .fire and .add\n                // Abort any current/pending executions\n                // Clear all callbacks and values\n                disable: function () {\n                    locked = queue = [];\n                    list = memory = \"\";\n                    return this;\n                },\n                disabled: function () {\n                    return !list;\n                },\n                // Disable .fire\n                // Also disable .add unless we have memory (since it would have no effect)\n                // Abort any pending executions\n                lock: function () {\n                    locked = queue = [];\n                    if (!memory && !firing) {\n                        list = memory = \"\";\n                    }\n                    return this;\n                },\n                locked: function () {\n                    return !!locked;\n                },\n                // Call all callbacks with the given context and arguments\n                fireWith: function (context, args) {\n                    if (!locked) {\n                        args = args || [];\n                        args = [context, args.slice ? args.slice() : args];\n                        queue.push(args);\n                        if (!firing) {\n                            fire();\n                        }\n                    }\n                    return this;\n                },\n                // Call all the callbacks with the given arguments\n                fire: function () {\n                    self.fireWith(this, arguments);\n                    return this;\n                },\n                // To know if the callbacks have already been called at least once\n                fired: function () {\n                    return !!fired;\n                }\n            };\n            return self;\n        };\n        function Identity(v) {\n            return v;\n        }\n        function Thrower(ex) {\n            throw ex;\n        }\n        function adoptValue(value, resolve, reject, noValue) {\n            var method;\n            try {\n                // Check for promise aspect first to privilege synchronous behavior\n                if (value && jQuery.isFunction((method = value.promise))) {\n                    method.call(value).done(resolve).fail(reject);\n                    // Other thenables\n                }\n                else if (value && jQuery.isFunction((method = value.then))) {\n                    method.call(value, resolve, reject);\n                    // Other non-thenables\n                }\n                else {\n                    // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n                    // * false: [ value ].slice( 0 ) => resolve( value )\n                    // * true: [ value ].slice( 1 ) => resolve()\n                    resolve.apply(undefined, [value].slice(noValue));\n                }\n                // For Promises/A+, convert exceptions into rejections\n                // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n                // Deferred#then to conditionally suppress rejection.\n            }\n            catch (value) {\n                // Support: Android 4.0 only\n                // Strict mode functions invoked without .call/.apply get global-object context\n                reject.apply(undefined, [value]);\n            }\n        }\n        jQuery.extend({\n            Deferred: function (func) {\n                var tuples = [\n                    // action, add listener, callbacks,\n                    // ... .then handlers, argument index, [final state]\n                    [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"),\n                        jQuery.Callbacks(\"memory\"), 2],\n                    [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"),\n                        jQuery.Callbacks(\"once memory\"), 0, \"resolved\"],\n                    [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"),\n                        jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]\n                ], state = \"pending\", promise = {\n                    state: function () {\n                        return state;\n                    },\n                    always: function () {\n                        deferred.done(arguments).fail(arguments);\n                        return this;\n                    },\n                    \"catch\": function (fn) {\n                        return promise.then(null, fn);\n                    },\n                    // Keep pipe for back-compat\n                    pipe: function ( /* fnDone, fnFail, fnProgress */) {\n                        var fns = arguments;\n                        return jQuery.Deferred(function (newDefer) {\n                            jQuery.each(tuples, function (i, tuple) {\n                                // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n                                var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];\n                                // deferred.progress(function() { bind to newDefer or newDefer.notify })\n                                // deferred.done(function() { bind to newDefer or newDefer.resolve })\n                                // deferred.fail(function() { bind to newDefer or newDefer.reject })\n                                deferred[tuple[1]](function () {\n                                    var returned = fn && fn.apply(this, arguments);\n                                    if (returned && jQuery.isFunction(returned.promise)) {\n                                        returned.promise()\n                                            .progress(newDefer.notify)\n                                            .done(newDefer.resolve)\n                                            .fail(newDefer.reject);\n                                    }\n                                    else {\n                                        newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                                    }\n                                });\n                            });\n                            fns = null;\n                        }).promise();\n                    },\n                    then: function (onFulfilled, onRejected, onProgress) {\n                        var maxDepth = 0;\n                        function resolve(depth, deferred, handler, special) {\n                            return function () {\n                                var that = this, args = arguments, mightThrow = function () {\n                                    var returned, then;\n                                    // Support: Promises/A+ section 2.3.3.3.3\n                                    // https://promisesaplus.com/#point-59\n                                    // Ignore double-resolution attempts\n                                    if (depth < maxDepth) {\n                                        return;\n                                    }\n                                    returned = handler.apply(that, args);\n                                    // Support: Promises/A+ section 2.3.1\n                                    // https://promisesaplus.com/#point-48\n                                    if (returned === deferred.promise()) {\n                                        throw new TypeError(\"Thenable self-resolution\");\n                                    }\n                                    // Support: Promises/A+ sections 2.3.3.1, 3.5\n                                    // https://promisesaplus.com/#point-54\n                                    // https://promisesaplus.com/#point-75\n                                    // Retrieve `then` only once\n                                    then = returned &&\n                                        // Support: Promises/A+ section 2.3.4\n                                        // https://promisesaplus.com/#point-64\n                                        // Only check objects and functions for thenability\n                                        (typeof returned === \"object\" ||\n                                            typeof returned === \"function\") &&\n                                        returned.then;\n                                    // Handle a returned thenable\n                                    if (jQuery.isFunction(then)) {\n                                        // Special processors (notify) just wait for resolution\n                                        if (special) {\n                                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n                                            // Normal processors (resolve) also hook into progress\n                                        }\n                                        else {\n                                            // ...and disregard older resolution values\n                                            maxDepth++;\n                                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                                        }\n                                        // Handle all other returned values\n                                    }\n                                    else {\n                                        // Only substitute handlers pass on context\n                                        // and multiple values (non-spec behavior)\n                                        if (handler !== Identity) {\n                                            that = undefined;\n                                            args = [returned];\n                                        }\n                                        // Process the value(s)\n                                        // Default process is resolve\n                                        (special || deferred.resolveWith)(that, args);\n                                    }\n                                }, \n                                // Only normal processors (resolve) catch and reject exceptions\n                                process = special ?\n                                    mightThrow :\n                                    function () {\n                                        try {\n                                            mightThrow();\n                                        }\n                                        catch (e) {\n                                            if (jQuery.Deferred.exceptionHook) {\n                                                jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                                            }\n                                            // Support: Promises/A+ section 2.3.3.3.4.1\n                                            // https://promisesaplus.com/#point-61\n                                            // Ignore post-resolution exceptions\n                                            if (depth + 1 >= maxDepth) {\n                                                // Only substitute handlers pass on context\n                                                // and multiple values (non-spec behavior)\n                                                if (handler !== Thrower) {\n                                                    that = undefined;\n                                                    args = [e];\n                                                }\n                                                deferred.rejectWith(that, args);\n                                            }\n                                        }\n                                    };\n                                // Support: Promises/A+ section 2.3.3.3.1\n                                // https://promisesaplus.com/#point-57\n                                // Re-resolve promises immediately to dodge false rejection from\n                                // subsequent errors\n                                if (depth) {\n                                    process();\n                                }\n                                else {\n                                    // Call an optional hook to record the stack, in case of exception\n                                    // since it's otherwise lost when execution goes async\n                                    if (jQuery.Deferred.getStackHook) {\n                                        process.stackTrace = jQuery.Deferred.getStackHook();\n                                    }\n                                    window.setTimeout(process);\n                                }\n                            };\n                        }\n                        return jQuery.Deferred(function (newDefer) {\n                            // progress_handlers.add( ... )\n                            tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ?\n                                onProgress :\n                                Identity, newDefer.notifyWith));\n                            // fulfilled_handlers.add( ... )\n                            tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ?\n                                onFulfilled :\n                                Identity));\n                            // rejected_handlers.add( ... )\n                            tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ?\n                                onRejected :\n                                Thrower));\n                        }).promise();\n                    },\n                    // Get a promise for this deferred\n                    // If obj is provided, the promise aspect is added to the object\n                    promise: function (obj) {\n                        return obj != null ? jQuery.extend(obj, promise) : promise;\n                    }\n                }, deferred = {};\n                // Add list-specific methods\n                jQuery.each(tuples, function (i, tuple) {\n                    var list = tuple[2], stateString = tuple[5];\n                    // promise.progress = list.add\n                    // promise.done = list.add\n                    // promise.fail = list.add\n                    promise[tuple[1]] = list.add;\n                    // Handle state\n                    if (stateString) {\n                        list.add(function () {\n                            // state = \"resolved\" (i.e., fulfilled)\n                            // state = \"rejected\"\n                            state = stateString;\n                        }, \n                        // rejected_callbacks.disable\n                        // fulfilled_callbacks.disable\n                        tuples[3 - i][2].disable, \n                        // progress_callbacks.lock\n                        tuples[0][2].lock);\n                    }\n                    // progress_handlers.fire\n                    // fulfilled_handlers.fire\n                    // rejected_handlers.fire\n                    list.add(tuple[3].fire);\n                    // deferred.notify = function() { deferred.notifyWith(...) }\n                    // deferred.resolve = function() { deferred.resolveWith(...) }\n                    // deferred.reject = function() { deferred.rejectWith(...) }\n                    deferred[tuple[0]] = function () {\n                        deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n                        return this;\n                    };\n                    // deferred.notifyWith = list.fireWith\n                    // deferred.resolveWith = list.fireWith\n                    // deferred.rejectWith = list.fireWith\n                    deferred[tuple[0] + \"With\"] = list.fireWith;\n                });\n                // Make the deferred a promise\n                promise.promise(deferred);\n                // Call given func if any\n                if (func) {\n                    func.call(deferred, deferred);\n                }\n                // All done!\n                return deferred;\n            },\n            // Deferred helper\n            when: function (singleValue) {\n                var \n                // count of uncompleted subordinates\n                remaining = arguments.length, \n                // count of unprocessed arguments\n                i = remaining, \n                // subordinate fulfillment data\n                resolveContexts = Array(i), resolveValues = slice.call(arguments), \n                // the master Deferred\n                master = jQuery.Deferred(), \n                // subordinate callback factory\n                updateFunc = function (i) {\n                    return function (value) {\n                        resolveContexts[i] = this;\n                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n                        if (!(--remaining)) {\n                            master.resolveWith(resolveContexts, resolveValues);\n                        }\n                    };\n                };\n                // Single- and empty arguments are adopted like Promise.resolve\n                if (remaining <= 1) {\n                    adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);\n                    // Use .then() to unwrap secondary thenables (cf. gh-3000)\n                    if (master.state() === \"pending\" ||\n                        jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {\n                        return master.then();\n                    }\n                }\n                // Multiple arguments are aggregated like Promise.all array elements\n                while (i--) {\n                    adoptValue(resolveValues[i], updateFunc(i), master.reject);\n                }\n                return master.promise();\n            }\n        });\n        // These usually indicate a programmer mistake during development,\n        // warn about them ASAP rather than swallowing them by default.\n        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n        jQuery.Deferred.exceptionHook = function (error, stack) {\n            // Support: IE 8 - 9 only\n            // Console exists when dev tools are open, which can happen at any time\n            if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n                window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n            }\n        };\n        jQuery.readyException = function (error) {\n            window.setTimeout(function () {\n                throw error;\n            });\n        };\n        // The deferred used on DOM ready\n        var readyList = jQuery.Deferred();\n        jQuery.fn.ready = function (fn) {\n            readyList\n                .then(fn)\n                // Wrap jQuery.readyException in a function so that the lookup\n                // happens at the time of error handling instead of callback\n                // registration.\n                .catch(function (error) {\n                jQuery.readyException(error);\n            });\n            return this;\n        };\n        jQuery.extend({\n            // Is the DOM ready to be used? Set to true once it occurs.\n            isReady: false,\n            // A counter to track how many items to wait for before\n            // the ready event fires. See #6781\n            readyWait: 1,\n            // Handle when the DOM is ready\n            ready: function (wait) {\n                // Abort if there are pending holds or we're already ready\n                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n                    return;\n                }\n                // Remember that the DOM is ready\n                jQuery.isReady = true;\n                // If a normal DOM Ready event fired, decrement, and wait if need be\n                if (wait !== true && --jQuery.readyWait > 0) {\n                    return;\n                }\n                // If there are functions bound, to execute\n                readyList.resolveWith(document, [jQuery]);\n            }\n        });\n        jQuery.ready.then = readyList.then;\n        // The ready event handler and self cleanup method\n        function completed() {\n            document.removeEventListener(\"DOMContentLoaded\", completed);\n            window.removeEventListener(\"load\", completed);\n            jQuery.ready();\n        }\n        // Catch cases where $(document).ready() is called\n        // after the browser event has already occurred.\n        // Support: IE <=9 - 10 only\n        // Older IE sometimes signals \"interactive\" too soon\n        if (document.readyState === \"complete\" ||\n            (document.readyState !== \"loading\" && !document.documentElement.doScroll)) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            window.setTimeout(jQuery.ready);\n        }\n        else {\n            // Use the handy event callback\n            document.addEventListener(\"DOMContentLoaded\", completed);\n            // A fallback to window.onload, that will always work\n            window.addEventListener(\"load\", completed);\n        }\n        // Multifunctional method to get and set values of a collection\n        // The value/s can optionally be executed if it's a function\n        var access = function (elems, fn, key, value, chainable, emptyGet, raw) {\n            var i = 0, len = elems.length, bulk = key == null;\n            // Sets many values\n            if (jQuery.type(key) === \"object\") {\n                chainable = true;\n                for (i in key) {\n                    access(elems, fn, i, key[i], true, emptyGet, raw);\n                }\n                // Sets one value\n            }\n            else if (value !== undefined) {\n                chainable = true;\n                if (!jQuery.isFunction(value)) {\n                    raw = true;\n                }\n                if (bulk) {\n                    // Bulk operations run against the entire set\n                    if (raw) {\n                        fn.call(elems, value);\n                        fn = null;\n                        // ...except when executing function values\n                    }\n                    else {\n                        bulk = fn;\n                        fn = function (elem, key, value) {\n                            return bulk.call(jQuery(elem), value);\n                        };\n                    }\n                }\n                if (fn) {\n                    for (; i < len; i++) {\n                        fn(elems[i], key, raw ?\n                            value :\n                            value.call(elems[i], i, fn(elems[i], key)));\n                    }\n                }\n            }\n            if (chainable) {\n                return elems;\n            }\n            // Gets\n            if (bulk) {\n                return fn.call(elems);\n            }\n            return len ? fn(elems[0], key) : emptyGet;\n        };\n        var acceptData = function (owner) {\n            // Accepts only:\n            //  - Node\n            //    - Node.ELEMENT_NODE\n            //    - Node.DOCUMENT_NODE\n            //  - Object\n            //    - Any\n            return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);\n        };\n        function Data() {\n            this.expando = jQuery.expando + Data.uid++;\n        }\n        Data.uid = 1;\n        Data.prototype = {\n            cache: function (owner) {\n                // Check if the owner object already has a cache\n                var value = owner[this.expando];\n                // If not, create one\n                if (!value) {\n                    value = {};\n                    // We can accept data for non-element nodes in modern browsers,\n                    // but we should not, see #8335.\n                    // Always return an empty object.\n                    if (acceptData(owner)) {\n                        // If it is a node unlikely to be stringify-ed or looped over\n                        // use plain assignment\n                        if (owner.nodeType) {\n                            owner[this.expando] = value;\n                            // Otherwise secure it in a non-enumerable property\n                            // configurable must be true to allow the property to be\n                            // deleted when data is removed\n                        }\n                        else {\n                            Object.defineProperty(owner, this.expando, {\n                                value: value,\n                                configurable: true\n                            });\n                        }\n                    }\n                }\n                return value;\n            },\n            set: function (owner, data, value) {\n                var prop, cache = this.cache(owner);\n                // Handle: [ owner, key, value ] args\n                // Always use camelCase key (gh-2257)\n                if (typeof data === \"string\") {\n                    cache[jQuery.camelCase(data)] = value;\n                    // Handle: [ owner, { properties } ] args\n                }\n                else {\n                    // Copy the properties one-by-one to the cache object\n                    for (prop in data) {\n                        cache[jQuery.camelCase(prop)] = data[prop];\n                    }\n                }\n                return cache;\n            },\n            get: function (owner, key) {\n                return key === undefined ?\n                    this.cache(owner) :\n                    // Always use camelCase key (gh-2257)\n                    owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];\n            },\n            access: function (owner, key, value) {\n                // In cases where either:\n                //\n                //   1. No key was specified\n                //   2. A string key was specified, but no value provided\n                //\n                // Take the \"read\" path and allow the get method to determine\n                // which value to return, respectively either:\n                //\n                //   1. The entire cache object\n                //   2. The data stored at the key\n                //\n                if (key === undefined ||\n                    ((key && typeof key === \"string\") && value === undefined)) {\n                    return this.get(owner, key);\n                }\n                // When the key is not a string, or both a key and value\n                // are specified, set or extend (existing objects) with either:\n                //\n                //   1. An object of properties\n                //   2. A key and value\n                //\n                this.set(owner, key, value);\n                // Since the \"set\" path can have two possible entry points\n                // return the expected data based on which path was taken[*]\n                return value !== undefined ? value : key;\n            },\n            remove: function (owner, key) {\n                var i, cache = owner[this.expando];\n                if (cache === undefined) {\n                    return;\n                }\n                if (key !== undefined) {\n                    // Support array or space separated string of keys\n                    if (Array.isArray(key)) {\n                        // If key is an array of keys...\n                        // We always set camelCase keys, so remove that.\n                        key = key.map(jQuery.camelCase);\n                    }\n                    else {\n                        key = jQuery.camelCase(key);\n                        // If a key with the spaces exists, use it.\n                        // Otherwise, create an array by matching non-whitespace\n                        key = key in cache ?\n                            [key] :\n                            (key.match(rnothtmlwhite) || []);\n                    }\n                    i = key.length;\n                    while (i--) {\n                        delete cache[key[i]];\n                    }\n                }\n                // Remove the expando if there's no more data\n                if (key === undefined || jQuery.isEmptyObject(cache)) {\n                    // Support: Chrome <=35 - 45\n                    // Webkit & Blink performance suffers when deleting properties\n                    // from DOM nodes, so set to undefined instead\n                    // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n                    if (owner.nodeType) {\n                        owner[this.expando] = undefined;\n                    }\n                    else {\n                        delete owner[this.expando];\n                    }\n                }\n            },\n            hasData: function (owner) {\n                var cache = owner[this.expando];\n                return cache !== undefined && !jQuery.isEmptyObject(cache);\n            }\n        };\n        var dataPriv = new Data();\n        var dataUser = new Data();\n        //\tImplementation Summary\n        //\n        //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n        //\t2. Improve the module's maintainability by reducing the storage\n        //\t\tpaths to a single mechanism.\n        //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n        //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n        //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n        //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n        var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/, rmultiDash = /[A-Z]/g;\n        function getData(data) {\n            if (data === \"true\") {\n                return true;\n            }\n            if (data === \"false\") {\n                return false;\n            }\n            if (data === \"null\") {\n                return null;\n            }\n            // Only convert to a number if it doesn't change the string\n            if (data === +data + \"\") {\n                return +data;\n            }\n            if (rbrace.test(data)) {\n                return JSON.parse(data);\n            }\n            return data;\n        }\n        function dataAttr(elem, key, data) {\n            var name;\n            // If nothing was found internally, try to fetch any\n            // data from the HTML5 data-* attribute\n            if (data === undefined && elem.nodeType === 1) {\n                name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n                data = elem.getAttribute(name);\n                if (typeof data === \"string\") {\n                    try {\n                        data = getData(data);\n                    }\n                    catch (e) { }\n                    // Make sure we set the data so it isn't changed later\n                    dataUser.set(elem, key, data);\n                }\n                else {\n                    data = undefined;\n                }\n            }\n            return data;\n        }\n        jQuery.extend({\n            hasData: function (elem) {\n                return dataUser.hasData(elem) || dataPriv.hasData(elem);\n            },\n            data: function (elem, name, data) {\n                return dataUser.access(elem, name, data);\n            },\n            removeData: function (elem, name) {\n                dataUser.remove(elem, name);\n            },\n            // TODO: Now that all calls to _data and _removeData have been replaced\n            // with direct calls to dataPriv methods, these can be deprecated.\n            _data: function (elem, name, data) {\n                return dataPriv.access(elem, name, data);\n            },\n            _removeData: function (elem, name) {\n                dataPriv.remove(elem, name);\n            }\n        });\n        jQuery.fn.extend({\n            data: function (key, value) {\n                var i, name, data, elem = this[0], attrs = elem && elem.attributes;\n                // Gets all values\n                if (key === undefined) {\n                    if (this.length) {\n                        data = dataUser.get(elem);\n                        if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n                            i = attrs.length;\n                            while (i--) {\n                                // Support: IE 11 only\n                                // The attrs elements can be null (#14894)\n                                if (attrs[i]) {\n                                    name = attrs[i].name;\n                                    if (name.indexOf(\"data-\") === 0) {\n                                        name = jQuery.camelCase(name.slice(5));\n                                        dataAttr(elem, name, data[name]);\n                                    }\n                                }\n                            }\n                            dataPriv.set(elem, \"hasDataAttrs\", true);\n                        }\n                    }\n                    return data;\n                }\n                // Sets multiple values\n                if (typeof key === \"object\") {\n                    return this.each(function () {\n                        dataUser.set(this, key);\n                    });\n                }\n                return access(this, function (value) {\n                    var data;\n                    // The calling jQuery object (element matches) is not empty\n                    // (and therefore has an element appears at this[ 0 ]) and the\n                    // `value` parameter was not undefined. An empty jQuery object\n                    // will result in `undefined` for elem = this[ 0 ] which will\n                    // throw an exception if an attempt to read a data cache is made.\n                    if (elem && value === undefined) {\n                        // Attempt to get data from the cache\n                        // The key will always be camelCased in Data\n                        data = dataUser.get(elem, key);\n                        if (data !== undefined) {\n                            return data;\n                        }\n                        // Attempt to \"discover\" the data in\n                        // HTML5 custom data-* attrs\n                        data = dataAttr(elem, key);\n                        if (data !== undefined) {\n                            return data;\n                        }\n                        // We tried really hard, but the data doesn't exist.\n                        return;\n                    }\n                    // Set the data...\n                    this.each(function () {\n                        // We always store the camelCased key\n                        dataUser.set(this, key, value);\n                    });\n                }, null, value, arguments.length > 1, null, true);\n            },\n            removeData: function (key) {\n                return this.each(function () {\n                    dataUser.remove(this, key);\n                });\n            }\n        });\n        jQuery.extend({\n            queue: function (elem, type, data) {\n                var queue;\n                if (elem) {\n                    type = (type || \"fx\") + \"queue\";\n                    queue = dataPriv.get(elem, type);\n                    // Speed up dequeue by getting out quickly if this is just a lookup\n                    if (data) {\n                        if (!queue || Array.isArray(data)) {\n                            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n                        }\n                        else {\n                            queue.push(data);\n                        }\n                    }\n                    return queue || [];\n                }\n            },\n            dequeue: function (elem, type) {\n                type = type || \"fx\";\n                var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {\n                    jQuery.dequeue(elem, type);\n                };\n                // If the fx queue is dequeued, always remove the progress sentinel\n                if (fn === \"inprogress\") {\n                    fn = queue.shift();\n                    startLength--;\n                }\n                if (fn) {\n                    // Add a progress sentinel to prevent the fx queue from being\n                    // automatically dequeued\n                    if (type === \"fx\") {\n                        queue.unshift(\"inprogress\");\n                    }\n                    // Clear up the last queue stop function\n                    delete hooks.stop;\n                    fn.call(elem, next, hooks);\n                }\n                if (!startLength && hooks) {\n                    hooks.empty.fire();\n                }\n            },\n            // Not public - generate a queueHooks object, or return the current one\n            _queueHooks: function (elem, type) {\n                var key = type + \"queueHooks\";\n                return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n                    empty: jQuery.Callbacks(\"once memory\").add(function () {\n                        dataPriv.remove(elem, [type + \"queue\", key]);\n                    })\n                });\n            }\n        });\n        jQuery.fn.extend({\n            queue: function (type, data) {\n                var setter = 2;\n                if (typeof type !== \"string\") {\n                    data = type;\n                    type = \"fx\";\n                    setter--;\n                }\n                if (arguments.length < setter) {\n                    return jQuery.queue(this[0], type);\n                }\n                return data === undefined ?\n                    this :\n                    this.each(function () {\n                        var queue = jQuery.queue(this, type, data);\n                        // Ensure a hooks for this queue\n                        jQuery._queueHooks(this, type);\n                        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n                            jQuery.dequeue(this, type);\n                        }\n                    });\n            },\n            dequeue: function (type) {\n                return this.each(function () {\n                    jQuery.dequeue(this, type);\n                });\n            },\n            clearQueue: function (type) {\n                return this.queue(type || \"fx\", []);\n            },\n            // Get a promise resolved when queues of a certain type\n            // are emptied (fx is the type by default)\n            promise: function (type, obj) {\n                var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {\n                    if (!(--count)) {\n                        defer.resolveWith(elements, [elements]);\n                    }\n                };\n                if (typeof type !== \"string\") {\n                    obj = type;\n                    type = undefined;\n                }\n                type = type || \"fx\";\n                while (i--) {\n                    tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n                    if (tmp && tmp.empty) {\n                        count++;\n                        tmp.empty.add(resolve);\n                    }\n                }\n                resolve();\n                return defer.promise(obj);\n            }\n        });\n        var pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n        var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n        var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n        var isHiddenWithinTree = function (elem, el) {\n            // isHiddenWithinTree might be called from jQuery#filter function;\n            // in that case, element will be second argument\n            elem = el || elem;\n            // Inline style trumps all\n            return elem.style.display === \"none\" ||\n                elem.style.display === \"\" &&\n                    // Otherwise, check computed style\n                    // Support: Firefox <=43 - 45\n                    // Disconnected elements can have computed display: none, so first confirm that elem is\n                    // in the document.\n                    jQuery.contains(elem.ownerDocument, elem) &&\n                    jQuery.css(elem, \"display\") === \"none\";\n        };\n        var swap = function (elem, options, callback, args) {\n            var ret, name, old = {};\n            // Remember the old values, and insert the new ones\n            for (name in options) {\n                old[name] = elem.style[name];\n                elem.style[name] = options[name];\n            }\n            ret = callback.apply(elem, args || []);\n            // Revert the old values\n            for (name in options) {\n                elem.style[name] = old[name];\n            }\n            return ret;\n        };\n        function adjustCSS(elem, prop, valueParts, tween) {\n            var adjusted, scale = 1, maxIterations = 20, currentValue = tween ?\n                function () {\n                    return tween.cur();\n                } :\n                function () {\n                    return jQuery.css(elem, prop, \"\");\n                }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"), \n            // Starting value computation is required for potential unit mismatches\n            initialInUnit = (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) &&\n                rcssNum.exec(jQuery.css(elem, prop));\n            if (initialInUnit && initialInUnit[3] !== unit) {\n                // Trust units reported by jQuery.css\n                unit = unit || initialInUnit[3];\n                // Make sure we update the tween properties later on\n                valueParts = valueParts || [];\n                // Iteratively approximate from a nonzero starting point\n                initialInUnit = +initial || 1;\n                do {\n                    // If previous iteration zeroed out, double until we get *something*.\n                    // Use string for doubling so we don't accidentally see scale as unchanged below\n                    scale = scale || \".5\";\n                    // Adjust and apply\n                    initialInUnit = initialInUnit / scale;\n                    jQuery.style(elem, prop, initialInUnit + unit);\n                    // Update scale, tolerating zero or NaN from tween.cur()\n                    // Break the loop if scale is unchanged or perfect, or if we've just had enough.\n                } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);\n            }\n            if (valueParts) {\n                initialInUnit = +initialInUnit || +initial || 0;\n                // Apply relative offset (+=/-=) if specified\n                adjusted = valueParts[1] ?\n                    initialInUnit + (valueParts[1] + 1) * valueParts[2] :\n                    +valueParts[2];\n                if (tween) {\n                    tween.unit = unit;\n                    tween.start = initialInUnit;\n                    tween.end = adjusted;\n                }\n            }\n            return adjusted;\n        }\n        var defaultDisplayMap = {};\n        function getDefaultDisplay(elem) {\n            var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];\n            if (display) {\n                return display;\n            }\n            temp = doc.body.appendChild(doc.createElement(nodeName));\n            display = jQuery.css(temp, \"display\");\n            temp.parentNode.removeChild(temp);\n            if (display === \"none\") {\n                display = \"block\";\n            }\n            defaultDisplayMap[nodeName] = display;\n            return display;\n        }\n        function showHide(elements, show) {\n            var display, elem, values = [], index = 0, length = elements.length;\n            // Determine new display value for elements that need to change\n            for (; index < length; index++) {\n                elem = elements[index];\n                if (!elem.style) {\n                    continue;\n                }\n                display = elem.style.display;\n                if (show) {\n                    // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n                    // check is required in this first loop unless we have a nonempty display value (either\n                    // inline or about-to-be-restored)\n                    if (display === \"none\") {\n                        values[index] = dataPriv.get(elem, \"display\") || null;\n                        if (!values[index]) {\n                            elem.style.display = \"\";\n                        }\n                    }\n                    if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n                        values[index] = getDefaultDisplay(elem);\n                    }\n                }\n                else {\n                    if (display !== \"none\") {\n                        values[index] = \"none\";\n                        // Remember what we're overwriting\n                        dataPriv.set(elem, \"display\", display);\n                    }\n                }\n            }\n            // Set the display of the elements in a second loop to avoid constant reflow\n            for (index = 0; index < length; index++) {\n                if (values[index] != null) {\n                    elements[index].style.display = values[index];\n                }\n            }\n            return elements;\n        }\n        jQuery.fn.extend({\n            show: function () {\n                return showHide(this, true);\n            },\n            hide: function () {\n                return showHide(this);\n            },\n            toggle: function (state) {\n                if (typeof state === \"boolean\") {\n                    return state ? this.show() : this.hide();\n                }\n                return this.each(function () {\n                    if (isHiddenWithinTree(this)) {\n                        jQuery(this).show();\n                    }\n                    else {\n                        jQuery(this).hide();\n                    }\n                });\n            }\n        });\n        var rcheckableType = (/^(?:checkbox|radio)$/i);\n        var rtagName = (/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i);\n        var rscriptType = (/^$|\\/(?:java|ecma)script/i);\n        // We have to close these tags to support XHTML (#13200)\n        var wrapMap = {\n            // Support: IE <=9 only\n            option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n            // XHTML parsers do not magically insert elements in the\n            // same way that tag soup parsers do. So we cannot shorten\n            // this by omitting <tbody> or other required elements.\n            thead: [1, \"<table>\", \"</table>\"],\n            col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n            tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n            td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n            _default: [0, \"\", \"\"]\n        };\n        // Support: IE <=9 only\n        wrapMap.optgroup = wrapMap.option;\n        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n        wrapMap.th = wrapMap.td;\n        function getAll(context, tag) {\n            // Support: IE <=9 - 11 only\n            // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n            var ret;\n            if (typeof context.getElementsByTagName !== \"undefined\") {\n                ret = context.getElementsByTagName(tag || \"*\");\n            }\n            else if (typeof context.querySelectorAll !== \"undefined\") {\n                ret = context.querySelectorAll(tag || \"*\");\n            }\n            else {\n                ret = [];\n            }\n            if (tag === undefined || tag && nodeName(context, tag)) {\n                return jQuery.merge([context], ret);\n            }\n            return ret;\n        }\n        // Mark scripts as having already been evaluated\n        function setGlobalEval(elems, refElements) {\n            var i = 0, l = elems.length;\n            for (; i < l; i++) {\n                dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n            }\n        }\n        var rhtml = /<|&#?\\w+;/;\n        function buildFragment(elems, context, scripts, selection, ignored) {\n            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;\n            for (; i < l; i++) {\n                elem = elems[i];\n                if (elem || elem === 0) {\n                    // Add nodes directly\n                    if (jQuery.type(elem) === \"object\") {\n                        // Support: Android <=4.0 only, PhantomJS 1 only\n                        // push.apply(_, arraylike) throws on ancient WebKit\n                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n                        // Convert non-html into a text node\n                    }\n                    else if (!rhtml.test(elem)) {\n                        nodes.push(context.createTextNode(elem));\n                        // Convert html into DOM nodes\n                    }\n                    else {\n                        tmp = tmp || fragment.appendChild(context.createElement(\"div\"));\n                        // Deserialize a standard representation\n                        tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n                        wrap = wrapMap[tag] || wrapMap._default;\n                        tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n                        // Descend through wrappers to the right content\n                        j = wrap[0];\n                        while (j--) {\n                            tmp = tmp.lastChild;\n                        }\n                        // Support: Android <=4.0 only, PhantomJS 1 only\n                        // push.apply(_, arraylike) throws on ancient WebKit\n                        jQuery.merge(nodes, tmp.childNodes);\n                        // Remember the top-level container\n                        tmp = fragment.firstChild;\n                        // Ensure the created nodes are orphaned (#12392)\n                        tmp.textContent = \"\";\n                    }\n                }\n            }\n            // Remove wrapper from fragment\n            fragment.textContent = \"\";\n            i = 0;\n            while ((elem = nodes[i++])) {\n                // Skip elements already in the context collection (trac-4087)\n                if (selection && jQuery.inArray(elem, selection) > -1) {\n                    if (ignored) {\n                        ignored.push(elem);\n                    }\n                    continue;\n                }\n                contains = jQuery.contains(elem.ownerDocument, elem);\n                // Append to fragment\n                tmp = getAll(fragment.appendChild(elem), \"script\");\n                // Preserve script evaluation history\n                if (contains) {\n                    setGlobalEval(tmp);\n                }\n                // Capture executables\n                if (scripts) {\n                    j = 0;\n                    while ((elem = tmp[j++])) {\n                        if (rscriptType.test(elem.type || \"\")) {\n                            scripts.push(elem);\n                        }\n                    }\n                }\n            }\n            return fragment;\n        }\n        (function () {\n            var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement(\"div\")), input = document.createElement(\"input\");\n            // Support: Android 4.0 - 4.3 only\n            // Check state lost if the name is set (#11217)\n            // Support: Windows Web Apps (WWA)\n            // `name` and `type` must use .setAttribute for WWA (#14901)\n            input.setAttribute(\"type\", \"radio\");\n            input.setAttribute(\"checked\", \"checked\");\n            input.setAttribute(\"name\", \"t\");\n            div.appendChild(input);\n            // Support: Android <=4.1 only\n            // Older WebKit doesn't clone checked state correctly in fragments\n            support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n            // Support: IE <=11 only\n            // Make sure textarea (and checkbox) defaultValue is properly cloned\n            div.innerHTML = \"<textarea>x</textarea>\";\n            support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n        })();\n        var documentElement = document.documentElement;\n        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n        function returnTrue() {\n            return true;\n        }\n        function returnFalse() {\n            return false;\n        }\n        // Support: IE <=9 only\n        // See #13393 for more info\n        function safeActiveElement() {\n            try {\n                return document.activeElement;\n            }\n            catch (err) { }\n        }\n        function on(elem, types, selector, data, fn, one) {\n            var origFn, type;\n            // Types can be a map of types/handlers\n            if (typeof types === \"object\") {\n                // ( types-Object, selector, data )\n                if (typeof selector !== \"string\") {\n                    // ( types-Object, data )\n                    data = data || selector;\n                    selector = undefined;\n                }\n                for (type in types) {\n                    on(elem, type, selector, data, types[type], one);\n                }\n                return elem;\n            }\n            if (data == null && fn == null) {\n                // ( types, fn )\n                fn = selector;\n                data = selector = undefined;\n            }\n            else if (fn == null) {\n                if (typeof selector === \"string\") {\n                    // ( types, selector, fn )\n                    fn = data;\n                    data = undefined;\n                }\n                else {\n                    // ( types, data, fn )\n                    fn = data;\n                    data = selector;\n                    selector = undefined;\n                }\n            }\n            if (fn === false) {\n                fn = returnFalse;\n            }\n            else if (!fn) {\n                return elem;\n            }\n            if (one === 1) {\n                origFn = fn;\n                fn = function (event) {\n                    // Can use an empty set, since event contains the info\n                    jQuery().off(event);\n                    return origFn.apply(this, arguments);\n                };\n                // Use same guid so caller can remove using origFn\n                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n            }\n            return elem.each(function () {\n                jQuery.event.add(this, types, fn, data, selector);\n            });\n        }\n        /*\n         * Helper functions for managing events -- not part of the public interface.\n         * Props to Dean Edwards' addEvent library for many of the ideas.\n         */\n        jQuery.event = {\n            global: {},\n            add: function (elem, types, handler, data, selector) {\n                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);\n                // Don't attach events to noData or text/comment nodes (but allow plain objects)\n                if (!elemData) {\n                    return;\n                }\n                // Caller can pass in an object of custom data in lieu of the handler\n                if (handler.handler) {\n                    handleObjIn = handler;\n                    handler = handleObjIn.handler;\n                    selector = handleObjIn.selector;\n                }\n                // Ensure that invalid selectors throw exceptions at attach time\n                // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n                if (selector) {\n                    jQuery.find.matchesSelector(documentElement, selector);\n                }\n                // Make sure that the handler has a unique ID, used to find/remove it later\n                if (!handler.guid) {\n                    handler.guid = jQuery.guid++;\n                }\n                // Init the element's event structure and main handler, if this is the first\n                if (!(events = elemData.events)) {\n                    events = elemData.events = {};\n                }\n                if (!(eventHandle = elemData.handle)) {\n                    eventHandle = elemData.handle = function (e) {\n                        // Discard the second event of a jQuery.event.trigger() and\n                        // when an event is called after a page has unloaded\n                        return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n                            jQuery.event.dispatch.apply(elem, arguments) : undefined;\n                    };\n                }\n                // Handle multiple events separated by a space\n                types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n                t = types.length;\n                while (t--) {\n                    tmp = rtypenamespace.exec(types[t]) || [];\n                    type = origType = tmp[1];\n                    namespaces = (tmp[2] || \"\").split(\".\").sort();\n                    // There *must* be a type, no attaching namespace-only handlers\n                    if (!type) {\n                        continue;\n                    }\n                    // If event changes its type, use the special event handlers for the changed type\n                    special = jQuery.event.special[type] || {};\n                    // If selector defined, determine special event api type, otherwise given type\n                    type = (selector ? special.delegateType : special.bindType) || type;\n                    // Update special based on newly reset type\n                    special = jQuery.event.special[type] || {};\n                    // handleObj is passed to all event handlers\n                    handleObj = jQuery.extend({\n                        type: type,\n                        origType: origType,\n                        data: data,\n                        handler: handler,\n                        guid: handler.guid,\n                        selector: selector,\n                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n                        namespace: namespaces.join(\".\")\n                    }, handleObjIn);\n                    // Init the event handler queue if we're the first\n                    if (!(handlers = events[type])) {\n                        handlers = events[type] = [];\n                        handlers.delegateCount = 0;\n                        // Only use addEventListener if the special events handler returns false\n                        if (!special.setup ||\n                            special.setup.call(elem, data, namespaces, eventHandle) === false) {\n                            if (elem.addEventListener) {\n                                elem.addEventListener(type, eventHandle);\n                            }\n                        }\n                    }\n                    if (special.add) {\n                        special.add.call(elem, handleObj);\n                        if (!handleObj.handler.guid) {\n                            handleObj.handler.guid = handler.guid;\n                        }\n                    }\n                    // Add to the element's handler list, delegates in front\n                    if (selector) {\n                        handlers.splice(handlers.delegateCount++, 0, handleObj);\n                    }\n                    else {\n                        handlers.push(handleObj);\n                    }\n                    // Keep track of which events have ever been used, for event optimization\n                    jQuery.event.global[type] = true;\n                }\n            },\n            // Detach an event or set of events from an element\n            remove: function (elem, types, handler, selector, mappedTypes) {\n                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n                if (!elemData || !(events = elemData.events)) {\n                    return;\n                }\n                // Once for each type.namespace in types; type may be omitted\n                types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n                t = types.length;\n                while (t--) {\n                    tmp = rtypenamespace.exec(types[t]) || [];\n                    type = origType = tmp[1];\n                    namespaces = (tmp[2] || \"\").split(\".\").sort();\n                    // Unbind all events (on this namespace, if provided) for the element\n                    if (!type) {\n                        for (type in events) {\n                            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n                        }\n                        continue;\n                    }\n                    special = jQuery.event.special[type] || {};\n                    type = (selector ? special.delegateType : special.bindType) || type;\n                    handlers = events[type] || [];\n                    tmp = tmp[2] &&\n                        new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n                    // Remove matching events\n                    origCount = j = handlers.length;\n                    while (j--) {\n                        handleObj = handlers[j];\n                        if ((mappedTypes || origType === handleObj.origType) &&\n                            (!handler || handler.guid === handleObj.guid) &&\n                            (!tmp || tmp.test(handleObj.namespace)) &&\n                            (!selector || selector === handleObj.selector ||\n                                selector === \"**\" && handleObj.selector)) {\n                            handlers.splice(j, 1);\n                            if (handleObj.selector) {\n                                handlers.delegateCount--;\n                            }\n                            if (special.remove) {\n                                special.remove.call(elem, handleObj);\n                            }\n                        }\n                    }\n                    // Remove generic event handler if we removed something and no more handlers exist\n                    // (avoids potential for endless recursion during removal of special event handlers)\n                    if (origCount && !handlers.length) {\n                        if (!special.teardown ||\n                            special.teardown.call(elem, namespaces, elemData.handle) === false) {\n                            jQuery.removeEvent(elem, type, elemData.handle);\n                        }\n                        delete events[type];\n                    }\n                }\n                // Remove data and the expando if it's no longer used\n                if (jQuery.isEmptyObject(events)) {\n                    dataPriv.remove(elem, \"handle events\");\n                }\n            },\n            dispatch: function (nativeEvent) {\n                // Make a writable jQuery.Event from the native event object\n                var event = jQuery.event.fix(nativeEvent);\n                var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, \"events\") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};\n                // Use the fix-ed jQuery.Event rather than the (read-only) native event\n                args[0] = event;\n                for (i = 1; i < arguments.length; i++) {\n                    args[i] = arguments[i];\n                }\n                event.delegateTarget = this;\n                // Call the preDispatch hook for the mapped type, and let it bail if desired\n                if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n                    return;\n                }\n                // Determine handlers\n                handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n                // Run delegates first; they may want to stop propagation beneath us\n                i = 0;\n                while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n                    event.currentTarget = matched.elem;\n                    j = 0;\n                    while ((handleObj = matched.handlers[j++]) &&\n                        !event.isImmediatePropagationStopped()) {\n                        // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n                        // a subset or equal to those in the bound event (both can have no namespace).\n                        if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\n                            event.handleObj = handleObj;\n                            event.data = handleObj.data;\n                            ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||\n                                handleObj.handler).apply(matched.elem, args);\n                            if (ret !== undefined) {\n                                if ((event.result = ret) === false) {\n                                    event.preventDefault();\n                                    event.stopPropagation();\n                                }\n                            }\n                        }\n                    }\n                }\n                // Call the postDispatch hook for the mapped type\n                if (special.postDispatch) {\n                    special.postDispatch.call(this, event);\n                }\n                return event.result;\n            },\n            handlers: function (event, handlers) {\n                var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;\n                // Find delegate handlers\n                if (delegateCount &&\n                    // Support: IE <=9\n                    // Black-hole SVG <use> instance trees (trac-13180)\n                    cur.nodeType &&\n                    // Support: Firefox <=42\n                    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n                    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n                    // Support: IE 11 only\n                    // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n                    !(event.type === \"click\" && event.button >= 1)) {\n                    for (; cur !== this; cur = cur.parentNode || this) {\n                        // Don't check non-elements (#13208)\n                        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n                        if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n                            matchedHandlers = [];\n                            matchedSelectors = {};\n                            for (i = 0; i < delegateCount; i++) {\n                                handleObj = handlers[i];\n                                // Don't conflict with Object.prototype properties (#13203)\n                                sel = handleObj.selector + \" \";\n                                if (matchedSelectors[sel] === undefined) {\n                                    matchedSelectors[sel] = handleObj.needsContext ?\n                                        jQuery(sel, this).index(cur) > -1 :\n                                        jQuery.find(sel, this, null, [cur]).length;\n                                }\n                                if (matchedSelectors[sel]) {\n                                    matchedHandlers.push(handleObj);\n                                }\n                            }\n                            if (matchedHandlers.length) {\n                                handlerQueue.push({ elem: cur, handlers: matchedHandlers });\n                            }\n                        }\n                    }\n                }\n                // Add the remaining (directly-bound) handlers\n                cur = this;\n                if (delegateCount < handlers.length) {\n                    handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });\n                }\n                return handlerQueue;\n            },\n            addProp: function (name, hook) {\n                Object.defineProperty(jQuery.Event.prototype, name, {\n                    enumerable: true,\n                    configurable: true,\n                    get: jQuery.isFunction(hook) ?\n                        function () {\n                            if (this.originalEvent) {\n                                return hook(this.originalEvent);\n                            }\n                        } :\n                        function () {\n                            if (this.originalEvent) {\n                                return this.originalEvent[name];\n                            }\n                        },\n                    set: function (value) {\n                        Object.defineProperty(this, name, {\n                            enumerable: true,\n                            configurable: true,\n                            writable: true,\n                            value: value\n                        });\n                    }\n                });\n            },\n            fix: function (originalEvent) {\n                return originalEvent[jQuery.expando] ?\n                    originalEvent :\n                    new jQuery.Event(originalEvent);\n            },\n            special: {\n                load: {\n                    // Prevent triggered image.load events from bubbling to window.load\n                    noBubble: true\n                },\n                focus: {\n                    // Fire native event if possible so blur/focus sequence is correct\n                    trigger: function () {\n                        if (this !== safeActiveElement() && this.focus) {\n                            this.focus();\n                            return false;\n                        }\n                    },\n                    delegateType: \"focusin\"\n                },\n                blur: {\n                    trigger: function () {\n                        if (this === safeActiveElement() && this.blur) {\n                            this.blur();\n                            return false;\n                        }\n                    },\n                    delegateType: \"focusout\"\n                },\n                click: {\n                    // For checkbox, fire native event so checked state will be right\n                    trigger: function () {\n                        if (this.type === \"checkbox\" && this.click && nodeName(this, \"input\")) {\n                            this.click();\n                            return false;\n                        }\n                    },\n                    // For cross-browser consistency, don't fire native .click() on links\n                    _default: function (event) {\n                        return nodeName(event.target, \"a\");\n                    }\n                },\n                beforeunload: {\n                    postDispatch: function (event) {\n                        // Support: Firefox 20+\n                        // Firefox doesn't alert if the returnValue field is not set.\n                        if (event.result !== undefined && event.originalEvent) {\n                            event.originalEvent.returnValue = event.result;\n                        }\n                    }\n                }\n            }\n        };\n        jQuery.removeEvent = function (elem, type, handle) {\n            // This \"if\" is needed for plain objects\n            if (elem.removeEventListener) {\n                elem.removeEventListener(type, handle);\n            }\n        };\n        jQuery.Event = function (src, props) {\n            // Allow instantiation without the 'new' keyword\n            if (!(this instanceof jQuery.Event)) {\n                return new jQuery.Event(src, props);\n            }\n            // Event object\n            if (src && src.type) {\n                this.originalEvent = src;\n                this.type = src.type;\n                // Events bubbling up the document may have been marked as prevented\n                // by a handler lower down the tree; reflect the correct value.\n                this.isDefaultPrevented = src.defaultPrevented ||\n                    src.defaultPrevented === undefined &&\n                        // Support: Android <=2.3 only\n                        src.returnValue === false ?\n                    returnTrue :\n                    returnFalse;\n                // Create target properties\n                // Support: Safari <=6 - 7 only\n                // Target should not be a text node (#504, #13143)\n                this.target = (src.target && src.target.nodeType === 3) ?\n                    src.target.parentNode :\n                    src.target;\n                this.currentTarget = src.currentTarget;\n                this.relatedTarget = src.relatedTarget;\n                // Event type\n            }\n            else {\n                this.type = src;\n            }\n            // Put explicitly provided properties onto the event object\n            if (props) {\n                jQuery.extend(this, props);\n            }\n            // Create a timestamp if incoming event doesn't have one\n            this.timeStamp = src && src.timeStamp || jQuery.now();\n            // Mark it as fixed\n            this[jQuery.expando] = true;\n        };\n        // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n        // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n        jQuery.Event.prototype = {\n            constructor: jQuery.Event,\n            isDefaultPrevented: returnFalse,\n            isPropagationStopped: returnFalse,\n            isImmediatePropagationStopped: returnFalse,\n            isSimulated: false,\n            preventDefault: function () {\n                var e = this.originalEvent;\n                this.isDefaultPrevented = returnTrue;\n                if (e && !this.isSimulated) {\n                    e.preventDefault();\n                }\n            },\n            stopPropagation: function () {\n                var e = this.originalEvent;\n                this.isPropagationStopped = returnTrue;\n                if (e && !this.isSimulated) {\n                    e.stopPropagation();\n                }\n            },\n            stopImmediatePropagation: function () {\n                var e = this.originalEvent;\n                this.isImmediatePropagationStopped = returnTrue;\n                if (e && !this.isSimulated) {\n                    e.stopImmediatePropagation();\n                }\n                this.stopPropagation();\n            }\n        };\n        // Includes all common event props including KeyEvent and MouseEvent specific props\n        jQuery.each({\n            altKey: true,\n            bubbles: true,\n            cancelable: true,\n            changedTouches: true,\n            ctrlKey: true,\n            detail: true,\n            eventPhase: true,\n            metaKey: true,\n            pageX: true,\n            pageY: true,\n            shiftKey: true,\n            view: true,\n            \"char\": true,\n            charCode: true,\n            key: true,\n            keyCode: true,\n            button: true,\n            buttons: true,\n            clientX: true,\n            clientY: true,\n            offsetX: true,\n            offsetY: true,\n            pointerId: true,\n            pointerType: true,\n            screenX: true,\n            screenY: true,\n            targetTouches: true,\n            toElement: true,\n            touches: true,\n            which: function (event) {\n                var button = event.button;\n                // Add which for key events\n                if (event.which == null && rkeyEvent.test(event.type)) {\n                    return event.charCode != null ? event.charCode : event.keyCode;\n                }\n                // Add which for click: 1 === left; 2 === middle; 3 === right\n                if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n                    if (button & 1) {\n                        return 1;\n                    }\n                    if (button & 2) {\n                        return 3;\n                    }\n                    if (button & 4) {\n                        return 2;\n                    }\n                    return 0;\n                }\n                return event.which;\n            }\n        }, jQuery.event.addProp);\n        // Create mouseenter/leave events using mouseover/out and event-time checks\n        // so that event delegation works in jQuery.\n        // Do the same for pointerenter/pointerleave and pointerover/pointerout\n        //\n        // Support: Safari 7 only\n        // Safari sends mouseenter too often; see:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n        // for the description of the bug (it existed in older Chrome versions as well).\n        jQuery.each({\n            mouseenter: \"mouseover\",\n            mouseleave: \"mouseout\",\n            pointerenter: \"pointerover\",\n            pointerleave: \"pointerout\"\n        }, function (orig, fix) {\n            jQuery.event.special[orig] = {\n                delegateType: fix,\n                bindType: fix,\n                handle: function (event) {\n                    var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;\n                    // For mouseenter/leave call the handler if related is outside the target.\n                    // NB: No relatedTarget if the mouse left/entered the browser window\n                    if (!related || (related !== target && !jQuery.contains(target, related))) {\n                        event.type = handleObj.origType;\n                        ret = handleObj.handler.apply(this, arguments);\n                        event.type = fix;\n                    }\n                    return ret;\n                }\n            };\n        });\n        jQuery.fn.extend({\n            on: function (types, selector, data, fn) {\n                return on(this, types, selector, data, fn);\n            },\n            one: function (types, selector, data, fn) {\n                return on(this, types, selector, data, fn, 1);\n            },\n            off: function (types, selector, fn) {\n                var handleObj, type;\n                if (types && types.preventDefault && types.handleObj) {\n                    // ( event )  dispatched jQuery.Event\n                    handleObj = types.handleObj;\n                    jQuery(types.delegateTarget).off(handleObj.namespace ?\n                        handleObj.origType + \".\" + handleObj.namespace :\n                        handleObj.origType, handleObj.selector, handleObj.handler);\n                    return this;\n                }\n                if (typeof types === \"object\") {\n                    // ( types-object [, selector] )\n                    for (type in types) {\n                        this.off(type, selector, types[type]);\n                    }\n                    return this;\n                }\n                if (selector === false || typeof selector === \"function\") {\n                    // ( types [, fn] )\n                    fn = selector;\n                    selector = undefined;\n                }\n                if (fn === false) {\n                    fn = returnFalse;\n                }\n                return this.each(function () {\n                    jQuery.event.remove(this, types, fn, selector);\n                });\n            }\n        });\n        var \n        /* eslint-disable max-len */\n        // See https://github.com/eslint/eslint/issues/3229\n        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi, \n        /* eslint-enable */\n        // Support: IE <=10 - 11, Edge 12 - 13\n        // In IE/Edge using regex groups here causes severe slowdowns.\n        // See https://connect.microsoft.com/IE/feedback/details/1736512/\n        rnoInnerhtml = /<script|<style|<link/i, \n        // checked=\"checked\" or checked\n        rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i, rscriptTypeMasked = /^true\\/(.*)/, rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n        // Prefer a tbody over its parent table for containing new rows\n        function manipulationTarget(elem, content) {\n            if (nodeName(elem, \"table\") &&\n                nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n                return jQuery(\">tbody\", elem)[0] || elem;\n            }\n            return elem;\n        }\n        // Replace/restore the type attribute of script elements for safe DOM manipulation\n        function disableScript(elem) {\n            elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n            return elem;\n        }\n        function restoreScript(elem) {\n            var match = rscriptTypeMasked.exec(elem.type);\n            if (match) {\n                elem.type = match[1];\n            }\n            else {\n                elem.removeAttribute(\"type\");\n            }\n            return elem;\n        }\n        function cloneCopyEvent(src, dest) {\n            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n            if (dest.nodeType !== 1) {\n                return;\n            }\n            // 1. Copy private data: events, handlers, etc.\n            if (dataPriv.hasData(src)) {\n                pdataOld = dataPriv.access(src);\n                pdataCur = dataPriv.set(dest, pdataOld);\n                events = pdataOld.events;\n                if (events) {\n                    delete pdataCur.handle;\n                    pdataCur.events = {};\n                    for (type in events) {\n                        for (i = 0, l = events[type].length; i < l; i++) {\n                            jQuery.event.add(dest, type, events[type][i]);\n                        }\n                    }\n                }\n            }\n            // 2. Copy user data\n            if (dataUser.hasData(src)) {\n                udataOld = dataUser.access(src);\n                udataCur = jQuery.extend({}, udataOld);\n                dataUser.set(dest, udataCur);\n            }\n        }\n        // Fix IE bugs, see support tests\n        function fixInput(src, dest) {\n            var nodeName = dest.nodeName.toLowerCase();\n            // Fails to persist the checked state of a cloned checkbox or radio button.\n            if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n                dest.checked = src.checked;\n                // Fails to return the selected option to the default selected state when cloning options\n            }\n            else if (nodeName === \"input\" || nodeName === \"textarea\") {\n                dest.defaultValue = src.defaultValue;\n            }\n        }\n        function domManip(collection, args, callback, ignored) {\n            // Flatten any nested arrays\n            args = concat.apply([], args);\n            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);\n            // We can't cloneNode fragments that contain checked, in WebKit\n            if (isFunction ||\n                (l > 1 && typeof value === \"string\" &&\n                    !support.checkClone && rchecked.test(value))) {\n                return collection.each(function (index) {\n                    var self = collection.eq(index);\n                    if (isFunction) {\n                        args[0] = value.call(this, index, self.html());\n                    }\n                    domManip(self, args, callback, ignored);\n                });\n            }\n            if (l) {\n                fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n                first = fragment.firstChild;\n                if (fragment.childNodes.length === 1) {\n                    fragment = first;\n                }\n                // Require either new content or an interest in ignored elements to invoke the callback\n                if (first || ignored) {\n                    scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n                    hasScripts = scripts.length;\n                    // Use the original fragment for the last item\n                    // instead of the first because it can end up\n                    // being emptied incorrectly in certain situations (#8070).\n                    for (; i < l; i++) {\n                        node = fragment;\n                        if (i !== iNoClone) {\n                            node = jQuery.clone(node, true, true);\n                            // Keep references to cloned scripts for later restoration\n                            if (hasScripts) {\n                                // Support: Android <=4.0 only, PhantomJS 1 only\n                                // push.apply(_, arraylike) throws on ancient WebKit\n                                jQuery.merge(scripts, getAll(node, \"script\"));\n                            }\n                        }\n                        callback.call(collection[i], node, i);\n                    }\n                    if (hasScripts) {\n                        doc = scripts[scripts.length - 1].ownerDocument;\n                        // Reenable scripts\n                        jQuery.map(scripts, restoreScript);\n                        // Evaluate executable scripts on first document insertion\n                        for (i = 0; i < hasScripts; i++) {\n                            node = scripts[i];\n                            if (rscriptType.test(node.type || \"\") &&\n                                !dataPriv.access(node, \"globalEval\") &&\n                                jQuery.contains(doc, node)) {\n                                if (node.src) {\n                                    // Optional AJAX dependency, but won't run scripts if not present\n                                    if (jQuery._evalUrl) {\n                                        jQuery._evalUrl(node.src);\n                                    }\n                                }\n                                else {\n                                    DOMEval(node.textContent.replace(rcleanScript, \"\"), doc);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return collection;\n        }\n        function remove(elem, selector, keepData) {\n            var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;\n            for (; (node = nodes[i]) != null; i++) {\n                if (!keepData && node.nodeType === 1) {\n                    jQuery.cleanData(getAll(node));\n                }\n                if (node.parentNode) {\n                    if (keepData && jQuery.contains(node.ownerDocument, node)) {\n                        setGlobalEval(getAll(node, \"script\"));\n                    }\n                    node.parentNode.removeChild(node);\n                }\n            }\n            return elem;\n        }\n        jQuery.extend({\n            htmlPrefilter: function (html) {\n                return html.replace(rxhtmlTag, \"<$1></$2>\");\n            },\n            clone: function (elem, dataAndEvents, deepDataAndEvents) {\n                var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);\n                // Fix IE cloning issues\n                if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&\n                    !jQuery.isXMLDoc(elem)) {\n                    // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n                    destElements = getAll(clone);\n                    srcElements = getAll(elem);\n                    for (i = 0, l = srcElements.length; i < l; i++) {\n                        fixInput(srcElements[i], destElements[i]);\n                    }\n                }\n                // Copy the events from the original to the clone\n                if (dataAndEvents) {\n                    if (deepDataAndEvents) {\n                        srcElements = srcElements || getAll(elem);\n                        destElements = destElements || getAll(clone);\n                        for (i = 0, l = srcElements.length; i < l; i++) {\n                            cloneCopyEvent(srcElements[i], destElements[i]);\n                        }\n                    }\n                    else {\n                        cloneCopyEvent(elem, clone);\n                    }\n                }\n                // Preserve script evaluation history\n                destElements = getAll(clone, \"script\");\n                if (destElements.length > 0) {\n                    setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n                }\n                // Return the cloned set\n                return clone;\n            },\n            cleanData: function (elems) {\n                var data, elem, type, special = jQuery.event.special, i = 0;\n                for (; (elem = elems[i]) !== undefined; i++) {\n                    if (acceptData(elem)) {\n                        if ((data = elem[dataPriv.expando])) {\n                            if (data.events) {\n                                for (type in data.events) {\n                                    if (special[type]) {\n                                        jQuery.event.remove(elem, type);\n                                        // This is a shortcut to avoid jQuery.event.remove's overhead\n                                    }\n                                    else {\n                                        jQuery.removeEvent(elem, type, data.handle);\n                                    }\n                                }\n                            }\n                            // Support: Chrome <=35 - 45+\n                            // Assign undefined instead of using delete, see Data#remove\n                            elem[dataPriv.expando] = undefined;\n                        }\n                        if (elem[dataUser.expando]) {\n                            // Support: Chrome <=35 - 45+\n                            // Assign undefined instead of using delete, see Data#remove\n                            elem[dataUser.expando] = undefined;\n                        }\n                    }\n                }\n            }\n        });\n        jQuery.fn.extend({\n            detach: function (selector) {\n                return remove(this, selector, true);\n            },\n            remove: function (selector) {\n                return remove(this, selector);\n            },\n            text: function (value) {\n                return access(this, function (value) {\n                    return value === undefined ?\n                        jQuery.text(this) :\n                        this.empty().each(function () {\n                            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                                this.textContent = value;\n                            }\n                        });\n                }, null, value, arguments.length);\n            },\n            append: function () {\n                return domManip(this, arguments, function (elem) {\n                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                        var target = manipulationTarget(this, elem);\n                        target.appendChild(elem);\n                    }\n                });\n            },\n            prepend: function () {\n                return domManip(this, arguments, function (elem) {\n                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                        var target = manipulationTarget(this, elem);\n                        target.insertBefore(elem, target.firstChild);\n                    }\n                });\n            },\n            before: function () {\n                return domManip(this, arguments, function (elem) {\n                    if (this.parentNode) {\n                        this.parentNode.insertBefore(elem, this);\n                    }\n                });\n            },\n            after: function () {\n                return domManip(this, arguments, function (elem) {\n                    if (this.parentNode) {\n                        this.parentNode.insertBefore(elem, this.nextSibling);\n                    }\n                });\n            },\n            empty: function () {\n                var elem, i = 0;\n                for (; (elem = this[i]) != null; i++) {\n                    if (elem.nodeType === 1) {\n                        // Prevent memory leaks\n                        jQuery.cleanData(getAll(elem, false));\n                        // Remove any remaining nodes\n                        elem.textContent = \"\";\n                    }\n                }\n                return this;\n            },\n            clone: function (dataAndEvents, deepDataAndEvents) {\n                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n                deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n                return this.map(function () {\n                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n                });\n            },\n            html: function (value) {\n                return access(this, function (value) {\n                    var elem = this[0] || {}, i = 0, l = this.length;\n                    if (value === undefined && elem.nodeType === 1) {\n                        return elem.innerHTML;\n                    }\n                    // See if we can take a shortcut and just use innerHTML\n                    if (typeof value === \"string\" && !rnoInnerhtml.test(value) &&\n                        !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n                        value = jQuery.htmlPrefilter(value);\n                        try {\n                            for (; i < l; i++) {\n                                elem = this[i] || {};\n                                // Remove element nodes and prevent memory leaks\n                                if (elem.nodeType === 1) {\n                                    jQuery.cleanData(getAll(elem, false));\n                                    elem.innerHTML = value;\n                                }\n                            }\n                            elem = 0;\n                            // If using innerHTML throws an exception, use the fallback method\n                        }\n                        catch (e) { }\n                    }\n                    if (elem) {\n                        this.empty().append(value);\n                    }\n                }, null, value, arguments.length);\n            },\n            replaceWith: function () {\n                var ignored = [];\n                // Make the changes, replacing each non-ignored context element with the new content\n                return domManip(this, arguments, function (elem) {\n                    var parent = this.parentNode;\n                    if (jQuery.inArray(this, ignored) < 0) {\n                        jQuery.cleanData(getAll(this));\n                        if (parent) {\n                            parent.replaceChild(elem, this);\n                        }\n                    }\n                    // Force callback invocation\n                }, ignored);\n            }\n        });\n        jQuery.each({\n            appendTo: \"append\",\n            prependTo: \"prepend\",\n            insertBefore: \"before\",\n            insertAfter: \"after\",\n            replaceAll: \"replaceWith\"\n        }, function (name, original) {\n            jQuery.fn[name] = function (selector) {\n                var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;\n                for (; i <= last; i++) {\n                    elems = i === last ? this : this.clone(true);\n                    jQuery(insert[i])[original](elems);\n                    // Support: Android <=4.0 only, PhantomJS 1 only\n                    // .get() because push.apply(_, arraylike) throws on ancient WebKit\n                    push.apply(ret, elems.get());\n                }\n                return this.pushStack(ret);\n            };\n        });\n        var rmargin = (/^margin/);\n        var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n        var getStyles = function (elem) {\n            // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n            // IE throws on elements created in popups\n            // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n            var view = elem.ownerDocument.defaultView;\n            if (!view || !view.opener) {\n                view = window;\n            }\n            return view.getComputedStyle(elem);\n        };\n        (function () {\n            // Executing both pixelPosition & boxSizingReliable tests require only one layout\n            // so they're executed at the same time to save the second computation.\n            function computeStyleTests() {\n                // This is a singleton, we need to execute it only once\n                if (!div) {\n                    return;\n                }\n                div.style.cssText =\n                    \"box-sizing:border-box;\" +\n                        \"position:relative;display:block;\" +\n                        \"margin:auto;border:1px;padding:1px;\" +\n                        \"top:1%;width:50%\";\n                div.innerHTML = \"\";\n                documentElement.appendChild(container);\n                var divStyle = window.getComputedStyle(div);\n                pixelPositionVal = divStyle.top !== \"1%\";\n                // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n                reliableMarginLeftVal = divStyle.marginLeft === \"2px\";\n                boxSizingReliableVal = divStyle.width === \"4px\";\n                // Support: Android 4.0 - 4.3 only\n                // Some styles come back with percentage values, even though they shouldn't\n                div.style.marginRight = \"50%\";\n                pixelMarginRightVal = divStyle.marginRight === \"4px\";\n                documentElement.removeChild(container);\n                // Nullify the div so it wouldn't be stored in the memory and\n                // it will also be a sign that checks already performed\n                div = null;\n            }\n            var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement(\"div\"), div = document.createElement(\"div\");\n            // Finish early in limited (non-browser) environments\n            if (!div.style) {\n                return;\n            }\n            // Support: IE <=9 - 11 only\n            // Style of cloned element affects source element cloned (#8908)\n            div.style.backgroundClip = \"content-box\";\n            div.cloneNode(true).style.backgroundClip = \"\";\n            support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n            container.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;\" +\n                \"padding:0;margin-top:1px;position:absolute\";\n            container.appendChild(div);\n            jQuery.extend(support, {\n                pixelPosition: function () {\n                    computeStyleTests();\n                    return pixelPositionVal;\n                },\n                boxSizingReliable: function () {\n                    computeStyleTests();\n                    return boxSizingReliableVal;\n                },\n                pixelMarginRight: function () {\n                    computeStyleTests();\n                    return pixelMarginRightVal;\n                },\n                reliableMarginLeft: function () {\n                    computeStyleTests();\n                    return reliableMarginLeftVal;\n                }\n            });\n        })();\n        function curCSS(elem, name, computed) {\n            var width, minWidth, maxWidth, ret, \n            // Support: Firefox 51+\n            // Retrieving style before computed somehow\n            // fixes an issue with getting wrong values\n            // on detached elements\n            style = elem.style;\n            computed = computed || getStyles(elem);\n            // getPropertyValue is needed for:\n            //   .css('filter') (IE 9 only, #12537)\n            //   .css('--customProperty) (#3144)\n            if (computed) {\n                ret = computed.getPropertyValue(name) || computed[name];\n                if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n                    ret = jQuery.style(elem, name);\n                }\n                // A tribute to the \"awesome hack by Dean Edwards\"\n                // Android Browser returns percentage for some values,\n                // but width seems to be reliably pixels.\n                // This is against the CSSOM draft spec:\n                // https://drafts.csswg.org/cssom/#resolved-values\n                if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {\n                    // Remember the original values\n                    width = style.width;\n                    minWidth = style.minWidth;\n                    maxWidth = style.maxWidth;\n                    // Put in the new values to get a computed value out\n                    style.minWidth = style.maxWidth = style.width = ret;\n                    ret = computed.width;\n                    // Revert the changed values\n                    style.width = width;\n                    style.minWidth = minWidth;\n                    style.maxWidth = maxWidth;\n                }\n            }\n            return ret !== undefined ?\n                // Support: IE <=9 - 11 only\n                // IE returns zIndex value as an integer.\n                ret + \"\" :\n                ret;\n        }\n        function addGetHookIf(conditionFn, hookFn) {\n            // Define the hook, we'll check on the first run if it's really needed.\n            return {\n                get: function () {\n                    if (conditionFn()) {\n                        // Hook not needed (or it's not possible to use it due\n                        // to missing dependency), remove it.\n                        delete this.get;\n                        return;\n                    }\n                    // Hook needed; redefine it so that the support test is not executed again.\n                    return (this.get = hookFn).apply(this, arguments);\n                }\n            };\n        }\n        var \n        // Swappable if display is none or starts with table\n        // except \"table\", \"table-cell\", or \"table-caption\"\n        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n        rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" }, cssNormalTransform = {\n            letterSpacing: \"0\",\n            fontWeight: \"400\"\n        }, cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"], emptyStyle = document.createElement(\"div\").style;\n        // Return a css property mapped to a potentially vendor prefixed property\n        function vendorPropName(name) {\n            // Shortcut for names that are not vendor prefixed\n            if (name in emptyStyle) {\n                return name;\n            }\n            // Check for vendor prefixed names\n            var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;\n            while (i--) {\n                name = cssPrefixes[i] + capName;\n                if (name in emptyStyle) {\n                    return name;\n                }\n            }\n        }\n        // Return a property mapped along what jQuery.cssProps suggests or to\n        // a vendor prefixed property.\n        function finalPropName(name) {\n            var ret = jQuery.cssProps[name];\n            if (!ret) {\n                ret = jQuery.cssProps[name] = vendorPropName(name) || name;\n            }\n            return ret;\n        }\n        function setPositiveNumber(elem, value, subtract) {\n            // Any relative (+/-) values have already been\n            // normalized at this point\n            var matches = rcssNum.exec(value);\n            return matches ?\n                // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n                Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") :\n                value;\n        }\n        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n            var i, val = 0;\n            // If we already have the right measurement, avoid augmentation\n            if (extra === (isBorderBox ? \"border\" : \"content\")) {\n                i = 4;\n                // Otherwise initialize for horizontal or vertical properties\n            }\n            else {\n                i = name === \"width\" ? 1 : 0;\n            }\n            for (; i < 4; i += 2) {\n                // Both box models exclude margin, so add it if we want it\n                if (extra === \"margin\") {\n                    val += jQuery.css(elem, extra + cssExpand[i], true, styles);\n                }\n                if (isBorderBox) {\n                    // border-box includes padding, so remove it if we want content\n                    if (extra === \"content\") {\n                        val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n                    }\n                    // At this point, extra isn't border nor margin, so remove border\n                    if (extra !== \"margin\") {\n                        val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                    }\n                }\n                else {\n                    // At this point, extra isn't content, so add padding\n                    val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n                    // At this point, extra isn't content nor padding, so add border\n                    if (extra !== \"padding\") {\n                        val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n                    }\n                }\n            }\n            return val;\n        }\n        function getWidthOrHeight(elem, name, extra) {\n            // Start with computed style\n            var valueIsBorderBox, styles = getStyles(elem), val = curCSS(elem, name, styles), isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\n            // Computed unit is not pixels. Stop here and return.\n            if (rnumnonpx.test(val)) {\n                return val;\n            }\n            // Check for style in case a browser which returns unreliable values\n            // for getComputedStyle silently falls back to the reliable elem.style\n            valueIsBorderBox = isBorderBox &&\n                (support.boxSizingReliable() || val === elem.style[name]);\n            // Fall back to offsetWidth/Height when value is \"auto\"\n            // This happens for inline elements with no explicit setting (gh-3571)\n            if (val === \"auto\") {\n                val = elem[\"offset\" + name[0].toUpperCase() + name.slice(1)];\n            }\n            // Normalize \"\", auto, and prepare for extra\n            val = parseFloat(val) || 0;\n            // Use the active box-sizing model to add/subtract irrelevant styles\n            return (val +\n                augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles)) + \"px\";\n        }\n        jQuery.extend({\n            // Add in style property hooks for overriding the default\n            // behavior of getting and setting a style property\n            cssHooks: {\n                opacity: {\n                    get: function (elem, computed) {\n                        if (computed) {\n                            // We should always get a number back from opacity\n                            var ret = curCSS(elem, \"opacity\");\n                            return ret === \"\" ? \"1\" : ret;\n                        }\n                    }\n                }\n            },\n            // Don't automatically add \"px\" to these possibly-unitless properties\n            cssNumber: {\n                \"animationIterationCount\": true,\n                \"columnCount\": true,\n                \"fillOpacity\": true,\n                \"flexGrow\": true,\n                \"flexShrink\": true,\n                \"fontWeight\": true,\n                \"lineHeight\": true,\n                \"opacity\": true,\n                \"order\": true,\n                \"orphans\": true,\n                \"widows\": true,\n                \"zIndex\": true,\n                \"zoom\": true\n            },\n            // Add in properties whose names you wish to fix before\n            // setting or getting the value\n            cssProps: {\n                \"float\": \"cssFloat\"\n            },\n            // Get and set the style property on a DOM Node\n            style: function (elem, name, value, extra) {\n                // Don't set styles on text and comment nodes\n                if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n                    return;\n                }\n                // Make sure that we're working with the right name\n                var ret, type, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;\n                // Make sure that we're working with the right name. We don't\n                // want to query the value if it is a CSS custom property\n                // since they are user-defined.\n                if (!isCustomProp) {\n                    name = finalPropName(origName);\n                }\n                // Gets hook for the prefixed version, then unprefixed version\n                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n                // Check if we're setting a value\n                if (value !== undefined) {\n                    type = typeof value;\n                    // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n                    if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n                        value = adjustCSS(elem, name, ret);\n                        // Fixes bug #9237\n                        type = \"number\";\n                    }\n                    // Make sure that null and NaN values aren't set (#7116)\n                    if (value == null || value !== value) {\n                        return;\n                    }\n                    // If a number was passed in, add the unit (except for certain CSS properties)\n                    if (type === \"number\") {\n                        value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n                    }\n                    // background-* props affect original clone's values\n                    if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n                        style[name] = \"inherit\";\n                    }\n                    // If a hook was provided, use that value, otherwise just set the specified value\n                    if (!hooks || !(\"set\" in hooks) ||\n                        (value = hooks.set(elem, value, extra)) !== undefined) {\n                        if (isCustomProp) {\n                            style.setProperty(name, value);\n                        }\n                        else {\n                            style[name] = value;\n                        }\n                    }\n                }\n                else {\n                    // If a hook was provided get the non-computed value from there\n                    if (hooks && \"get\" in hooks &&\n                        (ret = hooks.get(elem, false, extra)) !== undefined) {\n                        return ret;\n                    }\n                    // Otherwise just get the value from the style object\n                    return style[name];\n                }\n            },\n            css: function (elem, name, extra, styles) {\n                var val, num, hooks, origName = jQuery.camelCase(name), isCustomProp = rcustomProp.test(name);\n                // Make sure that we're working with the right name. We don't\n                // want to modify the value if it is a CSS custom property\n                // since they are user-defined.\n                if (!isCustomProp) {\n                    name = finalPropName(origName);\n                }\n                // Try prefixed name followed by the unprefixed name\n                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n                // If a hook was provided get the computed value from there\n                if (hooks && \"get\" in hooks) {\n                    val = hooks.get(elem, true, extra);\n                }\n                // Otherwise, if a way to get the computed value exists, use that\n                if (val === undefined) {\n                    val = curCSS(elem, name, styles);\n                }\n                // Convert \"normal\" to computed value\n                if (val === \"normal\" && name in cssNormalTransform) {\n                    val = cssNormalTransform[name];\n                }\n                // Make numeric if forced or a qualifier was provided and val looks numeric\n                if (extra === \"\" || extra) {\n                    num = parseFloat(val);\n                    return extra === true || isFinite(num) ? num || 0 : val;\n                }\n                return val;\n            }\n        });\n        jQuery.each([\"height\", \"width\"], function (i, name) {\n            jQuery.cssHooks[name] = {\n                get: function (elem, computed, extra) {\n                    if (computed) {\n                        // Certain elements can have dimension info if we invisibly show them\n                        // but it must have a current display style that would benefit\n                        return rdisplayswap.test(jQuery.css(elem, \"display\")) &&\n                            // Support: Safari 8+\n                            // Table columns in Safari have non-zero offsetWidth & zero\n                            // getBoundingClientRect().width unless display is changed.\n                            // Support: IE <=11 only\n                            // Running getBoundingClientRect on a disconnected node\n                            // in IE throws an error.\n                            (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?\n                            swap(elem, cssShow, function () {\n                                return getWidthOrHeight(elem, name, extra);\n                            }) :\n                            getWidthOrHeight(elem, name, extra);\n                    }\n                },\n                set: function (elem, value, extra) {\n                    var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles);\n                    // Convert to pixels if value adjustment is needed\n                    if (subtract && (matches = rcssNum.exec(value)) &&\n                        (matches[3] || \"px\") !== \"px\") {\n                        elem.style[name] = value;\n                        value = jQuery.css(elem, name);\n                    }\n                    return setPositiveNumber(elem, value, subtract);\n                }\n            };\n        });\n        jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n            if (computed) {\n                return (parseFloat(curCSS(elem, \"marginLeft\")) ||\n                    elem.getBoundingClientRect().left -\n                        swap(elem, { marginLeft: 0 }, function () {\n                            return elem.getBoundingClientRect().left;\n                        })) + \"px\";\n            }\n        });\n        // These hooks are used by animate to expand properties\n        jQuery.each({\n            margin: \"\",\n            padding: \"\",\n            border: \"Width\"\n        }, function (prefix, suffix) {\n            jQuery.cssHooks[prefix + suffix] = {\n                expand: function (value) {\n                    var i = 0, expanded = {}, \n                    // Assumes a single number if not a string\n                    parts = typeof value === \"string\" ? value.split(\" \") : [value];\n                    for (; i < 4; i++) {\n                        expanded[prefix + cssExpand[i] + suffix] =\n                            parts[i] || parts[i - 2] || parts[0];\n                    }\n                    return expanded;\n                }\n            };\n            if (!rmargin.test(prefix)) {\n                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n            }\n        });\n        jQuery.fn.extend({\n            css: function (name, value) {\n                return access(this, function (elem, name, value) {\n                    var styles, len, map = {}, i = 0;\n                    if (Array.isArray(name)) {\n                        styles = getStyles(elem);\n                        len = name.length;\n                        for (; i < len; i++) {\n                            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n                        }\n                        return map;\n                    }\n                    return value !== undefined ?\n                        jQuery.style(elem, name, value) :\n                        jQuery.css(elem, name);\n                }, name, value, arguments.length > 1);\n            }\n        });\n        function Tween(elem, options, prop, end, easing) {\n            return new Tween.prototype.init(elem, options, prop, end, easing);\n        }\n        jQuery.Tween = Tween;\n        Tween.prototype = {\n            constructor: Tween,\n            init: function (elem, options, prop, end, easing, unit) {\n                this.elem = elem;\n                this.prop = prop;\n                this.easing = easing || jQuery.easing._default;\n                this.options = options;\n                this.start = this.now = this.cur();\n                this.end = end;\n                this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n            },\n            cur: function () {\n                var hooks = Tween.propHooks[this.prop];\n                return hooks && hooks.get ?\n                    hooks.get(this) :\n                    Tween.propHooks._default.get(this);\n            },\n            run: function (percent) {\n                var eased, hooks = Tween.propHooks[this.prop];\n                if (this.options.duration) {\n                    this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n                }\n                else {\n                    this.pos = eased = percent;\n                }\n                this.now = (this.end - this.start) * eased + this.start;\n                if (this.options.step) {\n                    this.options.step.call(this.elem, this.now, this);\n                }\n                if (hooks && hooks.set) {\n                    hooks.set(this);\n                }\n                else {\n                    Tween.propHooks._default.set(this);\n                }\n                return this;\n            }\n        };\n        Tween.prototype.init.prototype = Tween.prototype;\n        Tween.propHooks = {\n            _default: {\n                get: function (tween) {\n                    var result;\n                    // Use a property on the element directly when it is not a DOM element,\n                    // or when there is no matching style property that exists.\n                    if (tween.elem.nodeType !== 1 ||\n                        tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n                        return tween.elem[tween.prop];\n                    }\n                    // Passing an empty string as a 3rd parameter to .css will automatically\n                    // attempt a parseFloat and fallback to a string if the parse fails.\n                    // Simple values such as \"10px\" are parsed to Float;\n                    // complex values such as \"rotate(1rad)\" are returned as-is.\n                    result = jQuery.css(tween.elem, tween.prop, \"\");\n                    // Empty strings, null, undefined and \"auto\" are converted to 0.\n                    return !result || result === \"auto\" ? 0 : result;\n                },\n                set: function (tween) {\n                    // Use step hook for back compat.\n                    // Use cssHook if its there.\n                    // Use .style if available and use plain properties where available.\n                    if (jQuery.fx.step[tween.prop]) {\n                        jQuery.fx.step[tween.prop](tween);\n                    }\n                    else if (tween.elem.nodeType === 1 &&\n                        (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||\n                            jQuery.cssHooks[tween.prop])) {\n                        jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n                    }\n                    else {\n                        tween.elem[tween.prop] = tween.now;\n                    }\n                }\n            }\n        };\n        // Support: IE <=9 only\n        // Panic based approach to setting things on disconnected nodes\n        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n            set: function (tween) {\n                if (tween.elem.nodeType && tween.elem.parentNode) {\n                    tween.elem[tween.prop] = tween.now;\n                }\n            }\n        };\n        jQuery.easing = {\n            linear: function (p) {\n                return p;\n            },\n            swing: function (p) {\n                return 0.5 - Math.cos(p * Math.PI) / 2;\n            },\n            _default: \"swing\"\n        };\n        jQuery.fx = Tween.prototype.init;\n        // Back compat <1.8 extension point\n        jQuery.fx.step = {};\n        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;\n        function schedule() {\n            if (inProgress) {\n                if (document.hidden === false && window.requestAnimationFrame) {\n                    window.requestAnimationFrame(schedule);\n                }\n                else {\n                    window.setTimeout(schedule, jQuery.fx.interval);\n                }\n                jQuery.fx.tick();\n            }\n        }\n        // Animations created synchronously will run synchronously\n        function createFxNow() {\n            window.setTimeout(function () {\n                fxNow = undefined;\n            });\n            return (fxNow = jQuery.now());\n        }\n        // Generate parameters to create a standard animation\n        function genFx(type, includeWidth) {\n            var which, i = 0, attrs = { height: type };\n            // If we include width, step value is 1 to do all cssExpand values,\n            // otherwise step value is 2 to skip over Left and Right\n            includeWidth = includeWidth ? 1 : 0;\n            for (; i < 4; i += 2 - includeWidth) {\n                which = cssExpand[i];\n                attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n            }\n            if (includeWidth) {\n                attrs.opacity = attrs.width = type;\n            }\n            return attrs;\n        }\n        function createTween(value, prop, animation) {\n            var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]), index = 0, length = collection.length;\n            for (; index < length; index++) {\n                if ((tween = collection[index].call(animation, prop, value))) {\n                    // We're done with this property\n                    return tween;\n                }\n            }\n        }\n        function defaultPrefilter(elem, props, opts) {\n            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = \"width\" in props || \"height\" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, \"fxshow\");\n            // Queue-skipping animations hijack the fx hooks\n            if (!opts.queue) {\n                hooks = jQuery._queueHooks(elem, \"fx\");\n                if (hooks.unqueued == null) {\n                    hooks.unqueued = 0;\n                    oldfire = hooks.empty.fire;\n                    hooks.empty.fire = function () {\n                        if (!hooks.unqueued) {\n                            oldfire();\n                        }\n                    };\n                }\n                hooks.unqueued++;\n                anim.always(function () {\n                    // Ensure the complete handler is called before this completes\n                    anim.always(function () {\n                        hooks.unqueued--;\n                        if (!jQuery.queue(elem, \"fx\").length) {\n                            hooks.empty.fire();\n                        }\n                    });\n                });\n            }\n            // Detect show/hide animations\n            for (prop in props) {\n                value = props[prop];\n                if (rfxtypes.test(value)) {\n                    delete props[prop];\n                    toggle = toggle || value === \"toggle\";\n                    if (value === (hidden ? \"hide\" : \"show\")) {\n                        // Pretend to be hidden if this is a \"show\" and\n                        // there is still data from a stopped show/hide\n                        if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n                            hidden = true;\n                            // Ignore all other no-op show/hide data\n                        }\n                        else {\n                            continue;\n                        }\n                    }\n                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n                }\n            }\n            // Bail out if this is a no-op like .hide().hide()\n            propTween = !jQuery.isEmptyObject(props);\n            if (!propTween && jQuery.isEmptyObject(orig)) {\n                return;\n            }\n            // Restrict \"overflow\" and \"display\" styles during box animations\n            if (isBox && elem.nodeType === 1) {\n                // Support: IE <=9 - 11, Edge 12 - 13\n                // Record all 3 overflow attributes because IE does not infer the shorthand\n                // from identically-valued overflowX and overflowY\n                opts.overflow = [style.overflow, style.overflowX, style.overflowY];\n                // Identify a display type, preferring old show/hide data over the CSS cascade\n                restoreDisplay = dataShow && dataShow.display;\n                if (restoreDisplay == null) {\n                    restoreDisplay = dataPriv.get(elem, \"display\");\n                }\n                display = jQuery.css(elem, \"display\");\n                if (display === \"none\") {\n                    if (restoreDisplay) {\n                        display = restoreDisplay;\n                    }\n                    else {\n                        // Get nonempty value(s) by temporarily forcing visibility\n                        showHide([elem], true);\n                        restoreDisplay = elem.style.display || restoreDisplay;\n                        display = jQuery.css(elem, \"display\");\n                        showHide([elem]);\n                    }\n                }\n                // Animate inline elements as inline-block\n                if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n                    if (jQuery.css(elem, \"float\") === \"none\") {\n                        // Restore the original display value at the end of pure show/hide animations\n                        if (!propTween) {\n                            anim.done(function () {\n                                style.display = restoreDisplay;\n                            });\n                            if (restoreDisplay == null) {\n                                display = style.display;\n                                restoreDisplay = display === \"none\" ? \"\" : display;\n                            }\n                        }\n                        style.display = \"inline-block\";\n                    }\n                }\n            }\n            if (opts.overflow) {\n                style.overflow = \"hidden\";\n                anim.always(function () {\n                    style.overflow = opts.overflow[0];\n                    style.overflowX = opts.overflow[1];\n                    style.overflowY = opts.overflow[2];\n                });\n            }\n            // Implement show/hide animations\n            propTween = false;\n            for (prop in orig) {\n                // General show/hide setup for this element animation\n                if (!propTween) {\n                    if (dataShow) {\n                        if (\"hidden\" in dataShow) {\n                            hidden = dataShow.hidden;\n                        }\n                    }\n                    else {\n                        dataShow = dataPriv.access(elem, \"fxshow\", { display: restoreDisplay });\n                    }\n                    // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n                    if (toggle) {\n                        dataShow.hidden = !hidden;\n                    }\n                    // Show elements before animating them\n                    if (hidden) {\n                        showHide([elem], true);\n                    }\n                    /* eslint-disable no-loop-func */\n                    anim.done(function () {\n                        /* eslint-enable no-loop-func */\n                        // The final step of a \"hide\" animation is actually hiding the element\n                        if (!hidden) {\n                            showHide([elem]);\n                        }\n                        dataPriv.remove(elem, \"fxshow\");\n                        for (prop in orig) {\n                            jQuery.style(elem, prop, orig[prop]);\n                        }\n                    });\n                }\n                // Per-property setup\n                propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n                if (!(prop in dataShow)) {\n                    dataShow[prop] = propTween.start;\n                    if (hidden) {\n                        propTween.end = propTween.start;\n                        propTween.start = 0;\n                    }\n                }\n            }\n        }\n        function propFilter(props, specialEasing) {\n            var index, name, easing, value, hooks;\n            // camelCase, specialEasing and expand cssHook pass\n            for (index in props) {\n                name = jQuery.camelCase(index);\n                easing = specialEasing[name];\n                value = props[index];\n                if (Array.isArray(value)) {\n                    easing = value[1];\n                    value = props[index] = value[0];\n                }\n                if (index !== name) {\n                    props[name] = value;\n                    delete props[index];\n                }\n                hooks = jQuery.cssHooks[name];\n                if (hooks && \"expand\" in hooks) {\n                    value = hooks.expand(value);\n                    delete props[name];\n                    // Not quite $.extend, this won't overwrite existing keys.\n                    // Reusing 'index' because we have the correct \"name\"\n                    for (index in value) {\n                        if (!(index in props)) {\n                            props[index] = value[index];\n                            specialEasing[index] = easing;\n                        }\n                    }\n                }\n                else {\n                    specialEasing[name] = easing;\n                }\n            }\n        }\n        function Animation(elem, properties, options) {\n            var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {\n                // Don't match elem in the :animated selector\n                delete tick.elem;\n            }), tick = function () {\n                if (stopped) {\n                    return false;\n                }\n                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), \n                // Support: Android 2.3 only\n                // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n                temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;\n                for (; index < length; index++) {\n                    animation.tweens[index].run(percent);\n                }\n                deferred.notifyWith(elem, [animation, percent, remaining]);\n                // If there's more to do, yield\n                if (percent < 1 && length) {\n                    return remaining;\n                }\n                // If this was an empty animation, synthesize a final progress notification\n                if (!length) {\n                    deferred.notifyWith(elem, [animation, 1, 0]);\n                }\n                // Resolve the animation and report its conclusion\n                deferred.resolveWith(elem, [animation]);\n                return false;\n            }, animation = deferred.promise({\n                elem: elem,\n                props: jQuery.extend({}, properties),\n                opts: jQuery.extend(true, {\n                    specialEasing: {},\n                    easing: jQuery.easing._default\n                }, options),\n                originalProperties: properties,\n                originalOptions: options,\n                startTime: fxNow || createFxNow(),\n                duration: options.duration,\n                tweens: [],\n                createTween: function (prop, end) {\n                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n                    animation.tweens.push(tween);\n                    return tween;\n                },\n                stop: function (gotoEnd) {\n                    var index = 0, \n                    // If we are going to the end, we want to run all the tweens\n                    // otherwise we skip this part\n                    length = gotoEnd ? animation.tweens.length : 0;\n                    if (stopped) {\n                        return this;\n                    }\n                    stopped = true;\n                    for (; index < length; index++) {\n                        animation.tweens[index].run(1);\n                    }\n                    // Resolve when we played the last frame; otherwise, reject\n                    if (gotoEnd) {\n                        deferred.notifyWith(elem, [animation, 1, 0]);\n                        deferred.resolveWith(elem, [animation, gotoEnd]);\n                    }\n                    else {\n                        deferred.rejectWith(elem, [animation, gotoEnd]);\n                    }\n                    return this;\n                }\n            }), props = animation.props;\n            propFilter(props, animation.opts.specialEasing);\n            for (; index < length; index++) {\n                result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n                if (result) {\n                    if (jQuery.isFunction(result.stop)) {\n                        jQuery._queueHooks(animation.elem, animation.opts.queue).stop =\n                            jQuery.proxy(result.stop, result);\n                    }\n                    return result;\n                }\n            }\n            jQuery.map(props, createTween, animation);\n            if (jQuery.isFunction(animation.opts.start)) {\n                animation.opts.start.call(elem, animation);\n            }\n            // Attach callbacks from options\n            animation\n                .progress(animation.opts.progress)\n                .done(animation.opts.done, animation.opts.complete)\n                .fail(animation.opts.fail)\n                .always(animation.opts.always);\n            jQuery.fx.timer(jQuery.extend(tick, {\n                elem: elem,\n                anim: animation,\n                queue: animation.opts.queue\n            }));\n            return animation;\n        }\n        jQuery.Animation = jQuery.extend(Animation, {\n            tweeners: {\n                \"*\": [function (prop, value) {\n                        var tween = this.createTween(prop, value);\n                        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n                        return tween;\n                    }]\n            },\n            tweener: function (props, callback) {\n                if (jQuery.isFunction(props)) {\n                    callback = props;\n                    props = [\"*\"];\n                }\n                else {\n                    props = props.match(rnothtmlwhite);\n                }\n                var prop, index = 0, length = props.length;\n                for (; index < length; index++) {\n                    prop = props[index];\n                    Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n                    Animation.tweeners[prop].unshift(callback);\n                }\n            },\n            prefilters: [defaultPrefilter],\n            prefilter: function (callback, prepend) {\n                if (prepend) {\n                    Animation.prefilters.unshift(callback);\n                }\n                else {\n                    Animation.prefilters.push(callback);\n                }\n            }\n        });\n        jQuery.speed = function (speed, easing, fn) {\n            var opt = speed && typeof speed === \"object\" ? jQuery.extend({}, speed) : {\n                complete: fn || !fn && easing ||\n                    jQuery.isFunction(speed) && speed,\n                duration: speed,\n                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n            };\n            // Go to the end state if fx are off\n            if (jQuery.fx.off) {\n                opt.duration = 0;\n            }\n            else {\n                if (typeof opt.duration !== \"number\") {\n                    if (opt.duration in jQuery.fx.speeds) {\n                        opt.duration = jQuery.fx.speeds[opt.duration];\n                    }\n                    else {\n                        opt.duration = jQuery.fx.speeds._default;\n                    }\n                }\n            }\n            // Normalize opt.queue - true/undefined/null -> \"fx\"\n            if (opt.queue == null || opt.queue === true) {\n                opt.queue = \"fx\";\n            }\n            // Queueing\n            opt.old = opt.complete;\n            opt.complete = function () {\n                if (jQuery.isFunction(opt.old)) {\n                    opt.old.call(this);\n                }\n                if (opt.queue) {\n                    jQuery.dequeue(this, opt.queue);\n                }\n            };\n            return opt;\n        };\n        jQuery.fn.extend({\n            fadeTo: function (speed, to, easing, callback) {\n                // Show any hidden elements after setting opacity to 0\n                return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show()\n                    // Animate to the value specified\n                    .end().animate({ opacity: to }, speed, easing, callback);\n            },\n            animate: function (prop, speed, easing, callback) {\n                var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {\n                    // Operate on a copy of prop so per-property easing won't be lost\n                    var anim = Animation(this, jQuery.extend({}, prop), optall);\n                    // Empty animations, or finishing resolves immediately\n                    if (empty || dataPriv.get(this, \"finish\")) {\n                        anim.stop(true);\n                    }\n                };\n                doAnimation.finish = doAnimation;\n                return empty || optall.queue === false ?\n                    this.each(doAnimation) :\n                    this.queue(optall.queue, doAnimation);\n            },\n            stop: function (type, clearQueue, gotoEnd) {\n                var stopQueue = function (hooks) {\n                    var stop = hooks.stop;\n                    delete hooks.stop;\n                    stop(gotoEnd);\n                };\n                if (typeof type !== \"string\") {\n                    gotoEnd = clearQueue;\n                    clearQueue = type;\n                    type = undefined;\n                }\n                if (clearQueue && type !== false) {\n                    this.queue(type || \"fx\", []);\n                }\n                return this.each(function () {\n                    var dequeue = true, index = type != null && type + \"queueHooks\", timers = jQuery.timers, data = dataPriv.get(this);\n                    if (index) {\n                        if (data[index] && data[index].stop) {\n                            stopQueue(data[index]);\n                        }\n                    }\n                    else {\n                        for (index in data) {\n                            if (data[index] && data[index].stop && rrun.test(index)) {\n                                stopQueue(data[index]);\n                            }\n                        }\n                    }\n                    for (index = timers.length; index--;) {\n                        if (timers[index].elem === this &&\n                            (type == null || timers[index].queue === type)) {\n                            timers[index].anim.stop(gotoEnd);\n                            dequeue = false;\n                            timers.splice(index, 1);\n                        }\n                    }\n                    // Start the next in the queue if the last step wasn't forced.\n                    // Timers currently will call their complete callbacks, which\n                    // will dequeue but only if they were gotoEnd.\n                    if (dequeue || !gotoEnd) {\n                        jQuery.dequeue(this, type);\n                    }\n                });\n            },\n            finish: function (type) {\n                if (type !== false) {\n                    type = type || \"fx\";\n                }\n                return this.each(function () {\n                    var index, data = dataPriv.get(this), queue = data[type + \"queue\"], hooks = data[type + \"queueHooks\"], timers = jQuery.timers, length = queue ? queue.length : 0;\n                    // Enable finishing flag on private data\n                    data.finish = true;\n                    // Empty the queue first\n                    jQuery.queue(this, type, []);\n                    if (hooks && hooks.stop) {\n                        hooks.stop.call(this, true);\n                    }\n                    // Look for any active animations, and finish them\n                    for (index = timers.length; index--;) {\n                        if (timers[index].elem === this && timers[index].queue === type) {\n                            timers[index].anim.stop(true);\n                            timers.splice(index, 1);\n                        }\n                    }\n                    // Look for any animations in the old queue and finish them\n                    for (index = 0; index < length; index++) {\n                        if (queue[index] && queue[index].finish) {\n                            queue[index].finish.call(this);\n                        }\n                    }\n                    // Turn off finishing flag\n                    delete data.finish;\n                });\n            }\n        });\n        jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n            var cssFn = jQuery.fn[name];\n            jQuery.fn[name] = function (speed, easing, callback) {\n                return speed == null || typeof speed === \"boolean\" ?\n                    cssFn.apply(this, arguments) :\n                    this.animate(genFx(name, true), speed, easing, callback);\n            };\n        });\n        // Generate shortcuts for custom animations\n        jQuery.each({\n            slideDown: genFx(\"show\"),\n            slideUp: genFx(\"hide\"),\n            slideToggle: genFx(\"toggle\"),\n            fadeIn: { opacity: \"show\" },\n            fadeOut: { opacity: \"hide\" },\n            fadeToggle: { opacity: \"toggle\" }\n        }, function (name, props) {\n            jQuery.fn[name] = function (speed, easing, callback) {\n                return this.animate(props, speed, easing, callback);\n            };\n        });\n        jQuery.timers = [];\n        jQuery.fx.tick = function () {\n            var timer, i = 0, timers = jQuery.timers;\n            fxNow = jQuery.now();\n            for (; i < timers.length; i++) {\n                timer = timers[i];\n                // Run the timer and safely remove it when done (allowing for external removal)\n                if (!timer() && timers[i] === timer) {\n                    timers.splice(i--, 1);\n                }\n            }\n            if (!timers.length) {\n                jQuery.fx.stop();\n            }\n            fxNow = undefined;\n        };\n        jQuery.fx.timer = function (timer) {\n            jQuery.timers.push(timer);\n            jQuery.fx.start();\n        };\n        jQuery.fx.interval = 13;\n        jQuery.fx.start = function () {\n            if (inProgress) {\n                return;\n            }\n            inProgress = true;\n            schedule();\n        };\n        jQuery.fx.stop = function () {\n            inProgress = null;\n        };\n        jQuery.fx.speeds = {\n            slow: 600,\n            fast: 200,\n            // Default speed\n            _default: 400\n        };\n        // Based off of the plugin by Clint Helfers, with permission.\n        // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n        jQuery.fn.delay = function (time, type) {\n            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n            type = type || \"fx\";\n            return this.queue(type, function (next, hooks) {\n                var timeout = window.setTimeout(next, time);\n                hooks.stop = function () {\n                    window.clearTimeout(timeout);\n                };\n            });\n        };\n        (function () {\n            var input = document.createElement(\"input\"), select = document.createElement(\"select\"), opt = select.appendChild(document.createElement(\"option\"));\n            input.type = \"checkbox\";\n            // Support: Android <=4.3 only\n            // Default value for a checkbox should be \"on\"\n            support.checkOn = input.value !== \"\";\n            // Support: IE <=11 only\n            // Must access selectedIndex to make default options select\n            support.optSelected = opt.selected;\n            // Support: IE <=11 only\n            // An input loses its value after becoming a radio\n            input = document.createElement(\"input\");\n            input.value = \"t\";\n            input.type = \"radio\";\n            support.radioValue = input.value === \"t\";\n        })();\n        var boolHook, attrHandle = jQuery.expr.attrHandle;\n        jQuery.fn.extend({\n            attr: function (name, value) {\n                return access(this, jQuery.attr, name, value, arguments.length > 1);\n            },\n            removeAttr: function (name) {\n                return this.each(function () {\n                    jQuery.removeAttr(this, name);\n                });\n            }\n        });\n        jQuery.extend({\n            attr: function (elem, name, value) {\n                var ret, hooks, nType = elem.nodeType;\n                // Don't get/set attributes on text, comment and attribute nodes\n                if (nType === 3 || nType === 8 || nType === 2) {\n                    return;\n                }\n                // Fallback to prop when attributes are not supported\n                if (typeof elem.getAttribute === \"undefined\") {\n                    return jQuery.prop(elem, name, value);\n                }\n                // Attribute hooks are determined by the lowercase version\n                // Grab necessary hook if one is defined\n                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                    hooks = jQuery.attrHooks[name.toLowerCase()] ||\n                        (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n                }\n                if (value !== undefined) {\n                    if (value === null) {\n                        jQuery.removeAttr(elem, name);\n                        return;\n                    }\n                    if (hooks && \"set\" in hooks &&\n                        (ret = hooks.set(elem, value, name)) !== undefined) {\n                        return ret;\n                    }\n                    elem.setAttribute(name, value + \"\");\n                    return value;\n                }\n                if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n                    return ret;\n                }\n                ret = jQuery.find.attr(elem, name);\n                // Non-existent attributes return null, we normalize to undefined\n                return ret == null ? undefined : ret;\n            },\n            attrHooks: {\n                type: {\n                    set: function (elem, value) {\n                        if (!support.radioValue && value === \"radio\" &&\n                            nodeName(elem, \"input\")) {\n                            var val = elem.value;\n                            elem.setAttribute(\"type\", value);\n                            if (val) {\n                                elem.value = val;\n                            }\n                            return value;\n                        }\n                    }\n                }\n            },\n            removeAttr: function (elem, value) {\n                var name, i = 0, \n                // Attribute names can contain non-HTML whitespace characters\n                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n                attrNames = value && value.match(rnothtmlwhite);\n                if (attrNames && elem.nodeType === 1) {\n                    while ((name = attrNames[i++])) {\n                        elem.removeAttribute(name);\n                    }\n                }\n            }\n        });\n        // Hooks for boolean attributes\n        boolHook = {\n            set: function (elem, value, name) {\n                if (value === false) {\n                    // Remove boolean attributes when set to false\n                    jQuery.removeAttr(elem, name);\n                }\n                else {\n                    elem.setAttribute(name, name);\n                }\n                return name;\n            }\n        };\n        jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n            var getter = attrHandle[name] || jQuery.find.attr;\n            attrHandle[name] = function (elem, name, isXML) {\n                var ret, handle, lowercaseName = name.toLowerCase();\n                if (!isXML) {\n                    // Avoid an infinite loop by temporarily removing this function from the getter\n                    handle = attrHandle[lowercaseName];\n                    attrHandle[lowercaseName] = ret;\n                    ret = getter(elem, name, isXML) != null ?\n                        lowercaseName :\n                        null;\n                    attrHandle[lowercaseName] = handle;\n                }\n                return ret;\n            };\n        });\n        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;\n        jQuery.fn.extend({\n            prop: function (name, value) {\n                return access(this, jQuery.prop, name, value, arguments.length > 1);\n            },\n            removeProp: function (name) {\n                return this.each(function () {\n                    delete this[jQuery.propFix[name] || name];\n                });\n            }\n        });\n        jQuery.extend({\n            prop: function (elem, name, value) {\n                var ret, hooks, nType = elem.nodeType;\n                // Don't get/set properties on text, comment and attribute nodes\n                if (nType === 3 || nType === 8 || nType === 2) {\n                    return;\n                }\n                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n                    // Fix name and attach hooks\n                    name = jQuery.propFix[name] || name;\n                    hooks = jQuery.propHooks[name];\n                }\n                if (value !== undefined) {\n                    if (hooks && \"set\" in hooks &&\n                        (ret = hooks.set(elem, value, name)) !== undefined) {\n                        return ret;\n                    }\n                    return (elem[name] = value);\n                }\n                if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n                    return ret;\n                }\n                return elem[name];\n            },\n            propHooks: {\n                tabIndex: {\n                    get: function (elem) {\n                        // Support: IE <=9 - 11 only\n                        // elem.tabIndex doesn't always return the\n                        // correct value when it hasn't been explicitly set\n                        // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n                        // Use proper attribute retrieval(#12072)\n                        var tabindex = jQuery.find.attr(elem, \"tabindex\");\n                        if (tabindex) {\n                            return parseInt(tabindex, 10);\n                        }\n                        if (rfocusable.test(elem.nodeName) ||\n                            rclickable.test(elem.nodeName) &&\n                                elem.href) {\n                            return 0;\n                        }\n                        return -1;\n                    }\n                }\n            },\n            propFix: {\n                \"for\": \"htmlFor\",\n                \"class\": \"className\"\n            }\n        });\n        // Support: IE <=11 only\n        // Accessing the selectedIndex property\n        // forces the browser to respect setting selected\n        // on the option\n        // The getter ensures a default option is selected\n        // when in an optgroup\n        // eslint rule \"no-unused-expressions\" is disabled for this code\n        // since it considers such accessions noop\n        if (!support.optSelected) {\n            jQuery.propHooks.selected = {\n                get: function (elem) {\n                    /* eslint no-unused-expressions: \"off\" */\n                    var parent = elem.parentNode;\n                    if (parent && parent.parentNode) {\n                        parent.parentNode.selectedIndex;\n                    }\n                    return null;\n                },\n                set: function (elem) {\n                    /* eslint no-unused-expressions: \"off\" */\n                    var parent = elem.parentNode;\n                    if (parent) {\n                        parent.selectedIndex;\n                        if (parent.parentNode) {\n                            parent.parentNode.selectedIndex;\n                        }\n                    }\n                }\n            };\n        }\n        jQuery.each([\n            \"tabIndex\",\n            \"readOnly\",\n            \"maxLength\",\n            \"cellSpacing\",\n            \"cellPadding\",\n            \"rowSpan\",\n            \"colSpan\",\n            \"useMap\",\n            \"frameBorder\",\n            \"contentEditable\"\n        ], function () {\n            jQuery.propFix[this.toLowerCase()] = this;\n        });\n        // Strip and collapse whitespace according to HTML spec\n        // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n        function stripAndCollapse(value) {\n            var tokens = value.match(rnothtmlwhite) || [];\n            return tokens.join(\" \");\n        }\n        function getClass(elem) {\n            return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n        }\n        jQuery.fn.extend({\n            addClass: function (value) {\n                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;\n                if (jQuery.isFunction(value)) {\n                    return this.each(function (j) {\n                        jQuery(this).addClass(value.call(this, j, getClass(this)));\n                    });\n                }\n                if (typeof value === \"string\" && value) {\n                    classes = value.match(rnothtmlwhite) || [];\n                    while ((elem = this[i++])) {\n                        curValue = getClass(elem);\n                        cur = elem.nodeType === 1 && (\" \" + stripAndCollapse(curValue) + \" \");\n                        if (cur) {\n                            j = 0;\n                            while ((clazz = classes[j++])) {\n                                if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                                    cur += clazz + \" \";\n                                }\n                            }\n                            // Only assign if different to avoid unneeded rendering.\n                            finalValue = stripAndCollapse(cur);\n                            if (curValue !== finalValue) {\n                                elem.setAttribute(\"class\", finalValue);\n                            }\n                        }\n                    }\n                }\n                return this;\n            },\n            removeClass: function (value) {\n                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;\n                if (jQuery.isFunction(value)) {\n                    return this.each(function (j) {\n                        jQuery(this).removeClass(value.call(this, j, getClass(this)));\n                    });\n                }\n                if (!arguments.length) {\n                    return this.attr(\"class\", \"\");\n                }\n                if (typeof value === \"string\" && value) {\n                    classes = value.match(rnothtmlwhite) || [];\n                    while ((elem = this[i++])) {\n                        curValue = getClass(elem);\n                        // This expression is here for better compressibility (see addClass)\n                        cur = elem.nodeType === 1 && (\" \" + stripAndCollapse(curValue) + \" \");\n                        if (cur) {\n                            j = 0;\n                            while ((clazz = classes[j++])) {\n                                // Remove *all* instances\n                                while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                                    cur = cur.replace(\" \" + clazz + \" \", \" \");\n                                }\n                            }\n                            // Only assign if different to avoid unneeded rendering.\n                            finalValue = stripAndCollapse(cur);\n                            if (curValue !== finalValue) {\n                                elem.setAttribute(\"class\", finalValue);\n                            }\n                        }\n                    }\n                }\n                return this;\n            },\n            toggleClass: function (value, stateVal) {\n                var type = typeof value;\n                if (typeof stateVal === \"boolean\" && type === \"string\") {\n                    return stateVal ? this.addClass(value) : this.removeClass(value);\n                }\n                if (jQuery.isFunction(value)) {\n                    return this.each(function (i) {\n                        jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n                    });\n                }\n                return this.each(function () {\n                    var className, i, self, classNames;\n                    if (type === \"string\") {\n                        // Toggle individual class names\n                        i = 0;\n                        self = jQuery(this);\n                        classNames = value.match(rnothtmlwhite) || [];\n                        while ((className = classNames[i++])) {\n                            // Check each className given, space separated list\n                            if (self.hasClass(className)) {\n                                self.removeClass(className);\n                            }\n                            else {\n                                self.addClass(className);\n                            }\n                        }\n                        // Toggle whole class name\n                    }\n                    else if (value === undefined || type === \"boolean\") {\n                        className = getClass(this);\n                        if (className) {\n                            // Store className if set\n                            dataPriv.set(this, \"__className__\", className);\n                        }\n                        // If the element has a class name or if we're passed `false`,\n                        // then remove the whole classname (if there was one, the above saved it).\n                        // Otherwise bring back whatever was previously saved (if anything),\n                        // falling back to the empty string if nothing was stored.\n                        if (this.setAttribute) {\n                            this.setAttribute(\"class\", className || value === false ?\n                                \"\" :\n                                dataPriv.get(this, \"__className__\") || \"\");\n                        }\n                    }\n                });\n            },\n            hasClass: function (selector) {\n                var className, elem, i = 0;\n                className = \" \" + selector + \" \";\n                while ((elem = this[i++])) {\n                    if (elem.nodeType === 1 &&\n                        (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        });\n        var rreturn = /\\r/g;\n        jQuery.fn.extend({\n            val: function (value) {\n                var hooks, ret, isFunction, elem = this[0];\n                if (!arguments.length) {\n                    if (elem) {\n                        hooks = jQuery.valHooks[elem.type] ||\n                            jQuery.valHooks[elem.nodeName.toLowerCase()];\n                        if (hooks &&\n                            \"get\" in hooks &&\n                            (ret = hooks.get(elem, \"value\")) !== undefined) {\n                            return ret;\n                        }\n                        ret = elem.value;\n                        // Handle most common string cases\n                        if (typeof ret === \"string\") {\n                            return ret.replace(rreturn, \"\");\n                        }\n                        // Handle cases where value is null/undef or number\n                        return ret == null ? \"\" : ret;\n                    }\n                    return;\n                }\n                isFunction = jQuery.isFunction(value);\n                return this.each(function (i) {\n                    var val;\n                    if (this.nodeType !== 1) {\n                        return;\n                    }\n                    if (isFunction) {\n                        val = value.call(this, i, jQuery(this).val());\n                    }\n                    else {\n                        val = value;\n                    }\n                    // Treat null/undefined as \"\"; convert numbers to string\n                    if (val == null) {\n                        val = \"\";\n                    }\n                    else if (typeof val === \"number\") {\n                        val += \"\";\n                    }\n                    else if (Array.isArray(val)) {\n                        val = jQuery.map(val, function (value) {\n                            return value == null ? \"\" : value + \"\";\n                        });\n                    }\n                    hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n                    // If set returns undefined, fall back to normal setting\n                    if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n                        this.value = val;\n                    }\n                });\n            }\n        });\n        jQuery.extend({\n            valHooks: {\n                option: {\n                    get: function (elem) {\n                        var val = jQuery.find.attr(elem, \"value\");\n                        return val != null ?\n                            val :\n                            // Support: IE <=10 - 11 only\n                            // option.text throws exceptions (#14686, #14858)\n                            // Strip and collapse whitespace\n                            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n                            stripAndCollapse(jQuery.text(elem));\n                    }\n                },\n                select: {\n                    get: function (elem) {\n                        var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === \"select-one\", values = one ? null : [], max = one ? index + 1 : options.length;\n                        if (index < 0) {\n                            i = max;\n                        }\n                        else {\n                            i = one ? index : 0;\n                        }\n                        // Loop through all the selected options\n                        for (; i < max; i++) {\n                            option = options[i];\n                            // Support: IE <=9 only\n                            // IE8-9 doesn't update selected after form reset (#2551)\n                            if ((option.selected || i === index) &&\n                                // Don't return options that are disabled or in a disabled optgroup\n                                !option.disabled &&\n                                (!option.parentNode.disabled ||\n                                    !nodeName(option.parentNode, \"optgroup\"))) {\n                                // Get the specific value for the option\n                                value = jQuery(option).val();\n                                // We don't need an array for one selects\n                                if (one) {\n                                    return value;\n                                }\n                                // Multi-Selects return an array\n                                values.push(value);\n                            }\n                        }\n                        return values;\n                    },\n                    set: function (elem, value) {\n                        var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;\n                        while (i--) {\n                            option = options[i];\n                            /* eslint-disable no-cond-assign */\n                            if (option.selected =\n                                jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n                                optionSet = true;\n                            }\n                            /* eslint-enable no-cond-assign */\n                        }\n                        // Force browsers to behave consistently when non-matching value is set\n                        if (!optionSet) {\n                            elem.selectedIndex = -1;\n                        }\n                        return values;\n                    }\n                }\n            }\n        });\n        // Radios and checkboxes getter/setter\n        jQuery.each([\"radio\", \"checkbox\"], function () {\n            jQuery.valHooks[this] = {\n                set: function (elem, value) {\n                    if (Array.isArray(value)) {\n                        return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);\n                    }\n                }\n            };\n            if (!support.checkOn) {\n                jQuery.valHooks[this].get = function (elem) {\n                    return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n                };\n            }\n        });\n        // Return jQuery for attributes-only inclusion\n        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n        jQuery.extend(jQuery.event, {\n            trigger: function (event, data, elem, onlyHandlers) {\n                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, \"type\") ? event.type : event, namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n                cur = tmp = elem = elem || document;\n                // Don't do events on text and comment nodes\n                if (elem.nodeType === 3 || elem.nodeType === 8) {\n                    return;\n                }\n                // focus/blur morphs to focusin/out; ensure we're not firing them right now\n                if (rfocusMorph.test(type + jQuery.event.triggered)) {\n                    return;\n                }\n                if (type.indexOf(\".\") > -1) {\n                    // Namespaced trigger; create a regexp to match event type in handle()\n                    namespaces = type.split(\".\");\n                    type = namespaces.shift();\n                    namespaces.sort();\n                }\n                ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n                // Caller can pass in a jQuery.Event object, Object, or just an event type string\n                event = event[jQuery.expando] ?\n                    event :\n                    new jQuery.Event(type, typeof event === \"object\" && event);\n                // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n                event.isTrigger = onlyHandlers ? 2 : 3;\n                event.namespace = namespaces.join(\".\");\n                event.rnamespace = event.namespace ?\n                    new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") :\n                    null;\n                // Clean up the event in case it is being reused\n                event.result = undefined;\n                if (!event.target) {\n                    event.target = elem;\n                }\n                // Clone any incoming data and prepend the event, creating the handler arg list\n                data = data == null ?\n                    [event] :\n                    jQuery.makeArray(data, [event]);\n                // Allow special events to draw outside the lines\n                special = jQuery.event.special[type] || {};\n                if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n                    return;\n                }\n                // Determine event propagation path in advance, per W3C events spec (#9951)\n                // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n                    bubbleType = special.delegateType || type;\n                    if (!rfocusMorph.test(bubbleType + type)) {\n                        cur = cur.parentNode;\n                    }\n                    for (; cur; cur = cur.parentNode) {\n                        eventPath.push(cur);\n                        tmp = cur;\n                    }\n                    // Only add window if we got to document (e.g., not plain obj or detached DOM)\n                    if (tmp === (elem.ownerDocument || document)) {\n                        eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n                    }\n                }\n                // Fire handlers on the event path\n                i = 0;\n                while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n                    event.type = i > 1 ?\n                        bubbleType :\n                        special.bindType || type;\n                    // jQuery handler\n                    handle = (dataPriv.get(cur, \"events\") || {})[event.type] &&\n                        dataPriv.get(cur, \"handle\");\n                    if (handle) {\n                        handle.apply(cur, data);\n                    }\n                    // Native handler\n                    handle = ontype && cur[ontype];\n                    if (handle && handle.apply && acceptData(cur)) {\n                        event.result = handle.apply(cur, data);\n                        if (event.result === false) {\n                            event.preventDefault();\n                        }\n                    }\n                }\n                event.type = type;\n                // If nobody prevented the default action, do it now\n                if (!onlyHandlers && !event.isDefaultPrevented()) {\n                    if ((!special._default ||\n                        special._default.apply(eventPath.pop(), data) === false) &&\n                        acceptData(elem)) {\n                        // Call a native DOM method on the target with the same name as the event.\n                        // Don't do default actions on window, that's where global variables be (#6170)\n                        if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\n                            // Don't re-trigger an onFOO event when we call its FOO() method\n                            tmp = elem[ontype];\n                            if (tmp) {\n                                elem[ontype] = null;\n                            }\n                            // Prevent re-triggering of the same event, since we already bubbled it above\n                            jQuery.event.triggered = type;\n                            elem[type]();\n                            jQuery.event.triggered = undefined;\n                            if (tmp) {\n                                elem[ontype] = tmp;\n                            }\n                        }\n                    }\n                }\n                return event.result;\n            },\n            // Piggyback on a donor event to simulate a different one\n            // Used only for `focus(in | out)` events\n            simulate: function (type, elem, event) {\n                var e = jQuery.extend(new jQuery.Event(), event, {\n                    type: type,\n                    isSimulated: true\n                });\n                jQuery.event.trigger(e, null, elem);\n            }\n        });\n        jQuery.fn.extend({\n            trigger: function (type, data) {\n                return this.each(function () {\n                    jQuery.event.trigger(type, data, this);\n                });\n            },\n            triggerHandler: function (type, data) {\n                var elem = this[0];\n                if (elem) {\n                    return jQuery.event.trigger(type, data, elem, true);\n                }\n            }\n        });\n        jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" +\n            \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n            \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (i, name) {\n            // Handle event binding\n            jQuery.fn[name] = function (data, fn) {\n                return arguments.length > 0 ?\n                    this.on(name, null, data, fn) :\n                    this.trigger(name);\n            };\n        });\n        jQuery.fn.extend({\n            hover: function (fnOver, fnOut) {\n                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n            }\n        });\n        support.focusin = \"onfocusin\" in window;\n        // Support: Firefox <=44\n        // Firefox doesn't have focus(in | out) events\n        // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n        //\n        // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n        // focus(in | out) events fire after focus & blur events,\n        // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n        // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n        if (!support.focusin) {\n            jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function (orig, fix) {\n                // Attach a single capturing handler on the document while someone wants focusin/focusout\n                var handler = function (event) {\n                    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n                };\n                jQuery.event.special[fix] = {\n                    setup: function () {\n                        var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);\n                        if (!attaches) {\n                            doc.addEventListener(orig, handler, true);\n                        }\n                        dataPriv.access(doc, fix, (attaches || 0) + 1);\n                    },\n                    teardown: function () {\n                        var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;\n                        if (!attaches) {\n                            doc.removeEventListener(orig, handler, true);\n                            dataPriv.remove(doc, fix);\n                        }\n                        else {\n                            dataPriv.access(doc, fix, attaches);\n                        }\n                    }\n                };\n            });\n        }\n        var location = window.location;\n        var nonce = jQuery.now();\n        var rquery = (/\\?/);\n        // Cross-browser xml parsing\n        jQuery.parseXML = function (data) {\n            var xml;\n            if (!data || typeof data !== \"string\") {\n                return null;\n            }\n            // Support: IE 9 - 11 only\n            // IE throws on parseFromString with invalid input.\n            try {\n                xml = (new window.DOMParser()).parseFromString(data, \"text/xml\");\n            }\n            catch (e) {\n                xml = undefined;\n            }\n            if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n                jQuery.error(\"Invalid XML: \" + data);\n            }\n            return xml;\n        };\n        var rbracket = /\\[\\]$/, rCRLF = /\\r?\\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;\n        function buildParams(prefix, obj, traditional, add) {\n            var name;\n            if (Array.isArray(obj)) {\n                // Serialize array item.\n                jQuery.each(obj, function (i, v) {\n                    if (traditional || rbracket.test(prefix)) {\n                        // Treat each array item as a scalar.\n                        add(prefix, v);\n                    }\n                    else {\n                        // Item is non-scalar (array or object), encode its numeric index.\n                        buildParams(prefix + \"[\" + (typeof v === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n                    }\n                });\n            }\n            else if (!traditional && jQuery.type(obj) === \"object\") {\n                // Serialize object item.\n                for (name in obj) {\n                    buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n                }\n            }\n            else {\n                // Serialize scalar item.\n                add(prefix, obj);\n            }\n        }\n        // Serialize an array of form elements or a set of\n        // key/values into a query string\n        jQuery.param = function (a, traditional) {\n            var prefix, s = [], add = function (key, valueOrFunction) {\n                // If value is a function, invoke it and use its return value\n                var value = jQuery.isFunction(valueOrFunction) ?\n                    valueOrFunction() :\n                    valueOrFunction;\n                s[s.length] = encodeURIComponent(key) + \"=\" +\n                    encodeURIComponent(value == null ? \"\" : value);\n            };\n            // If an array was passed in, assume that it is an array of form elements.\n            if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {\n                // Serialize the form elements\n                jQuery.each(a, function () {\n                    add(this.name, this.value);\n                });\n            }\n            else {\n                // If traditional, encode the \"old\" way (the way 1.3.2 or older\n                // did it), otherwise encode params recursively.\n                for (prefix in a) {\n                    buildParams(prefix, a[prefix], traditional, add);\n                }\n            }\n            // Return the resulting serialization\n            return s.join(\"&\");\n        };\n        jQuery.fn.extend({\n            serialize: function () {\n                return jQuery.param(this.serializeArray());\n            },\n            serializeArray: function () {\n                return this.map(function () {\n                    // Can add propHook for \"elements\" to filter or add form elements\n                    var elements = jQuery.prop(this, \"elements\");\n                    return elements ? jQuery.makeArray(elements) : this;\n                })\n                    .filter(function () {\n                    var type = this.type;\n                    // Use .is( \":disabled\" ) so that fieldset[disabled] works\n                    return this.name && !jQuery(this).is(\":disabled\") &&\n                        rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&\n                        (this.checked || !rcheckableType.test(type));\n                })\n                    .map(function (i, elem) {\n                    var val = jQuery(this).val();\n                    if (val == null) {\n                        return null;\n                    }\n                    if (Array.isArray(val)) {\n                        return jQuery.map(val, function (val) {\n                            return { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n                        });\n                    }\n                    return { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n                }).get();\n            }\n        });\n        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg, \n        // #7653, #8125, #8152: local protocol detection\n        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\\/\\//, \n        /* Prefilters\n         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n         * 2) These are called:\n         *    - BEFORE asking for a transport\n         *    - AFTER param serialization (s.data is a string if s.processData is true)\n         * 3) key is the dataType\n         * 4) the catchall symbol \"*\" can be used\n         * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n         */\n        prefilters = {}, \n        /* Transports bindings\n         * 1) key is the dataType\n         * 2) the catchall symbol \"*\" can be used\n         * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n         */\n        transports = {}, \n        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n        allTypes = \"*/\".concat(\"*\"), \n        // Anchor tag for parsing the document origin\n        originAnchor = document.createElement(\"a\");\n        originAnchor.href = location.href;\n        // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n        function addToPrefiltersOrTransports(structure) {\n            // dataTypeExpression is optional and defaults to \"*\"\n            return function (dataTypeExpression, func) {\n                if (typeof dataTypeExpression !== \"string\") {\n                    func = dataTypeExpression;\n                    dataTypeExpression = \"*\";\n                }\n                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n                if (jQuery.isFunction(func)) {\n                    // For each dataType in the dataTypeExpression\n                    while ((dataType = dataTypes[i++])) {\n                        // Prepend if requested\n                        if (dataType[0] === \"+\") {\n                            dataType = dataType.slice(1) || \"*\";\n                            (structure[dataType] = structure[dataType] || []).unshift(func);\n                            // Otherwise append\n                        }\n                        else {\n                            (structure[dataType] = structure[dataType] || []).push(func);\n                        }\n                    }\n                }\n            };\n        }\n        // Base inspection function for prefilters and transports\n        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n            var inspected = {}, seekingTransport = (structure === transports);\n            function inspect(dataType) {\n                var selected;\n                inspected[dataType] = true;\n                jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n                    if (typeof dataTypeOrTransport === \"string\" &&\n                        !seekingTransport && !inspected[dataTypeOrTransport]) {\n                        options.dataTypes.unshift(dataTypeOrTransport);\n                        inspect(dataTypeOrTransport);\n                        return false;\n                    }\n                    else if (seekingTransport) {\n                        return !(selected = dataTypeOrTransport);\n                    }\n                });\n                return selected;\n            }\n            return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n        }\n        // A special extend for ajax options\n        // that takes \"flat\" options (not to be deep extended)\n        // Fixes #9887\n        function ajaxExtend(target, src) {\n            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};\n            for (key in src) {\n                if (src[key] !== undefined) {\n                    (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];\n                }\n            }\n            if (deep) {\n                jQuery.extend(true, target, deep);\n            }\n            return target;\n        }\n        /* Handles responses to an ajax request:\n         * - finds the right dataType (mediates between content-type and expected dataType)\n         * - returns the corresponding response\n         */\n        function ajaxHandleResponses(s, jqXHR, responses) {\n            var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;\n            // Remove auto dataType and get content-type in the process\n            while (dataTypes[0] === \"*\") {\n                dataTypes.shift();\n                if (ct === undefined) {\n                    ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n                }\n            }\n            // Check if we're dealing with a known content-type\n            if (ct) {\n                for (type in contents) {\n                    if (contents[type] && contents[type].test(ct)) {\n                        dataTypes.unshift(type);\n                        break;\n                    }\n                }\n            }\n            // Check to see if we have a response for the expected dataType\n            if (dataTypes[0] in responses) {\n                finalDataType = dataTypes[0];\n            }\n            else {\n                // Try convertible dataTypes\n                for (type in responses) {\n                    if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n                        finalDataType = type;\n                        break;\n                    }\n                    if (!firstDataType) {\n                        firstDataType = type;\n                    }\n                }\n                // Or just use first one\n                finalDataType = finalDataType || firstDataType;\n            }\n            // If we found a dataType\n            // We add the dataType to the list if needed\n            // and return the corresponding response\n            if (finalDataType) {\n                if (finalDataType !== dataTypes[0]) {\n                    dataTypes.unshift(finalDataType);\n                }\n                return responses[finalDataType];\n            }\n        }\n        /* Chain conversions given the request and the original response\n         * Also sets the responseXXX fields on the jqXHR instance\n         */\n        function ajaxConvert(s, response, jqXHR, isSuccess) {\n            var conv2, current, conv, tmp, prev, converters = {}, \n            // Work with a copy of dataTypes in case we need to modify it for conversion\n            dataTypes = s.dataTypes.slice();\n            // Create converters map with lowercased keys\n            if (dataTypes[1]) {\n                for (conv in s.converters) {\n                    converters[conv.toLowerCase()] = s.converters[conv];\n                }\n            }\n            current = dataTypes.shift();\n            // Convert to each sequential dataType\n            while (current) {\n                if (s.responseFields[current]) {\n                    jqXHR[s.responseFields[current]] = response;\n                }\n                // Apply the dataFilter if provided\n                if (!prev && isSuccess && s.dataFilter) {\n                    response = s.dataFilter(response, s.dataType);\n                }\n                prev = current;\n                current = dataTypes.shift();\n                if (current) {\n                    // There's only work to do if current dataType is non-auto\n                    if (current === \"*\") {\n                        current = prev;\n                        // Convert response if prev dataType is non-auto and differs from current\n                    }\n                    else if (prev !== \"*\" && prev !== current) {\n                        // Seek a direct converter\n                        conv = converters[prev + \" \" + current] || converters[\"* \" + current];\n                        // If none found, seek a pair\n                        if (!conv) {\n                            for (conv2 in converters) {\n                                // If conv2 outputs current\n                                tmp = conv2.split(\" \");\n                                if (tmp[1] === current) {\n                                    // If prev can be converted to accepted input\n                                    conv = converters[prev + \" \" + tmp[0]] ||\n                                        converters[\"* \" + tmp[0]];\n                                    if (conv) {\n                                        // Condense equivalence converters\n                                        if (conv === true) {\n                                            conv = converters[conv2];\n                                            // Otherwise, insert the intermediate dataType\n                                        }\n                                        else if (converters[conv2] !== true) {\n                                            current = tmp[0];\n                                            dataTypes.unshift(tmp[1]);\n                                        }\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        // Apply converter (if not an equivalence)\n                        if (conv !== true) {\n                            // Unless errors are allowed to bubble, catch and return them\n                            if (conv && s.throws) {\n                                response = conv(response);\n                            }\n                            else {\n                                try {\n                                    response = conv(response);\n                                }\n                                catch (e) {\n                                    return {\n                                        state: \"parsererror\",\n                                        error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return { state: \"success\", data: response };\n        }\n        jQuery.extend({\n            // Counter for holding the number of active queries\n            active: 0,\n            // Last-Modified header cache for next request\n            lastModified: {},\n            etag: {},\n            ajaxSettings: {\n                url: location.href,\n                type: \"GET\",\n                isLocal: rlocalProtocol.test(location.protocol),\n                global: true,\n                processData: true,\n                async: true,\n                contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n                /*\n                timeout: 0,\n                data: null,\n                dataType: null,\n                username: null,\n                password: null,\n                cache: null,\n                throws: false,\n                traditional: false,\n                headers: {},\n                */\n                accepts: {\n                    \"*\": allTypes,\n                    text: \"text/plain\",\n                    html: \"text/html\",\n                    xml: \"application/xml, text/xml\",\n                    json: \"application/json, text/javascript\"\n                },\n                contents: {\n                    xml: /\\bxml\\b/,\n                    html: /\\bhtml/,\n                    json: /\\bjson\\b/\n                },\n                responseFields: {\n                    xml: \"responseXML\",\n                    text: \"responseText\",\n                    json: \"responseJSON\"\n                },\n                // Data converters\n                // Keys separate source (or catchall \"*\") and destination types with a single space\n                converters: {\n                    // Convert anything to text\n                    \"* text\": String,\n                    // Text to html (true = no transformation)\n                    \"text html\": true,\n                    // Evaluate text as a json expression\n                    \"text json\": JSON.parse,\n                    // Parse text as xml\n                    \"text xml\": jQuery.parseXML\n                },\n                // For options that shouldn't be deep extended:\n                // you can add your own custom options here if\n                // and when you create one that shouldn't be\n                // deep extended (see ajaxExtend)\n                flatOptions: {\n                    url: true,\n                    context: true\n                }\n            },\n            // Creates a full fledged settings object into target\n            // with both ajaxSettings and settings fields.\n            // If target is omitted, writes into ajaxSettings.\n            ajaxSetup: function (target, settings) {\n                return settings ?\n                    // Building a settings object\n                    ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n                    // Extending ajaxSettings\n                    ajaxExtend(jQuery.ajaxSettings, target);\n            },\n            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n            ajaxTransport: addToPrefiltersOrTransports(transports),\n            // Main method\n            ajax: function (url, options) {\n                // If url is an object, simulate pre-1.5 signature\n                if (typeof url === \"object\") {\n                    options = url;\n                    url = undefined;\n                }\n                // Force options to be an object\n                options = options || {};\n                var transport, \n                // URL without anti-cache param\n                cacheURL, \n                // Response headers\n                responseHeadersString, responseHeaders, \n                // timeout handle\n                timeoutTimer, \n                // Url cleanup var\n                urlAnchor, \n                // Request state (becomes false upon send and true upon completion)\n                completed, \n                // To know if global events are to be dispatched\n                fireGlobals, \n                // Loop variable\n                i, \n                // uncached part of the url\n                uncached, \n                // Create the final options object\n                s = jQuery.ajaxSetup({}, options), \n                // Callbacks context\n                callbackContext = s.context || s, \n                // Context for global events is callbackContext if it is a DOM node or jQuery collection\n                globalEventContext = s.context &&\n                    (callbackContext.nodeType || callbackContext.jquery) ?\n                    jQuery(callbackContext) :\n                    jQuery.event, \n                // Deferreds\n                deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks(\"once memory\"), \n                // Status-dependent callbacks\n                statusCode = s.statusCode || {}, \n                // Headers (they are sent all at once)\n                requestHeaders = {}, requestHeadersNames = {}, \n                // Default abort message\n                strAbort = \"canceled\", \n                // Fake xhr\n                jqXHR = {\n                    readyState: 0,\n                    // Builds headers hashtable if needed\n                    getResponseHeader: function (key) {\n                        var match;\n                        if (completed) {\n                            if (!responseHeaders) {\n                                responseHeaders = {};\n                                while ((match = rheaders.exec(responseHeadersString))) {\n                                    responseHeaders[match[1].toLowerCase()] = match[2];\n                                }\n                            }\n                            match = responseHeaders[key.toLowerCase()];\n                        }\n                        return match == null ? null : match;\n                    },\n                    // Raw string\n                    getAllResponseHeaders: function () {\n                        return completed ? responseHeadersString : null;\n                    },\n                    // Caches the header\n                    setRequestHeader: function (name, value) {\n                        if (completed == null) {\n                            name = requestHeadersNames[name.toLowerCase()] =\n                                requestHeadersNames[name.toLowerCase()] || name;\n                            requestHeaders[name] = value;\n                        }\n                        return this;\n                    },\n                    // Overrides response content-type header\n                    overrideMimeType: function (type) {\n                        if (completed == null) {\n                            s.mimeType = type;\n                        }\n                        return this;\n                    },\n                    // Status-dependent callbacks\n                    statusCode: function (map) {\n                        var code;\n                        if (map) {\n                            if (completed) {\n                                // Execute the appropriate callbacks\n                                jqXHR.always(map[jqXHR.status]);\n                            }\n                            else {\n                                // Lazy-add the new callbacks in a way that preserves old ones\n                                for (code in map) {\n                                    statusCode[code] = [statusCode[code], map[code]];\n                                }\n                            }\n                        }\n                        return this;\n                    },\n                    // Cancel the request\n                    abort: function (statusText) {\n                        var finalText = statusText || strAbort;\n                        if (transport) {\n                            transport.abort(finalText);\n                        }\n                        done(0, finalText);\n                        return this;\n                    }\n                };\n                // Attach deferreds\n                deferred.promise(jqXHR);\n                // Add protocol if not provided (prefilters might expect it)\n                // Handle falsy url in the settings object (#10093: consistency with old signature)\n                // We also use the url parameter if available\n                s.url = ((url || s.url || location.href) + \"\")\n                    .replace(rprotocol, location.protocol + \"//\");\n                // Alias method option to type as per ticket #12004\n                s.type = options.method || options.type || s.method || s.type;\n                // Extract dataTypes list\n                s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"];\n                // A cross-domain request is in order when the origin doesn't match the current origin.\n                if (s.crossDomain == null) {\n                    urlAnchor = document.createElement(\"a\");\n                    // Support: IE <=8 - 11, Edge 12 - 13\n                    // IE throws exception on accessing the href property if url is malformed,\n                    // e.g. http://example.com:80x/\n                    try {\n                        urlAnchor.href = s.url;\n                        // Support: IE <=8 - 11 only\n                        // Anchor's host property isn't correctly set when s.url is relative\n                        urlAnchor.href = urlAnchor.href;\n                        s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n                            urlAnchor.protocol + \"//\" + urlAnchor.host;\n                    }\n                    catch (e) {\n                        // If there is an error parsing the URL, assume it is crossDomain,\n                        // it can be rejected by the transport if it is invalid\n                        s.crossDomain = true;\n                    }\n                }\n                // Convert data if not already a string\n                if (s.data && s.processData && typeof s.data !== \"string\") {\n                    s.data = jQuery.param(s.data, s.traditional);\n                }\n                // Apply prefilters\n                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n                // If request was aborted inside a prefilter, stop there\n                if (completed) {\n                    return jqXHR;\n                }\n                // We can fire global events as of now if asked to\n                // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n                fireGlobals = jQuery.event && s.global;\n                // Watch for a new set of requests\n                if (fireGlobals && jQuery.active++ === 0) {\n                    jQuery.event.trigger(\"ajaxStart\");\n                }\n                // Uppercase the type\n                s.type = s.type.toUpperCase();\n                // Determine if request has content\n                s.hasContent = !rnoContent.test(s.type);\n                // Save the URL in case we're toying with the If-Modified-Since\n                // and/or If-None-Match header later on\n                // Remove hash to simplify url manipulation\n                cacheURL = s.url.replace(rhash, \"\");\n                // More options handling for requests with no content\n                if (!s.hasContent) {\n                    // Remember the hash so we can put it back\n                    uncached = s.url.slice(cacheURL.length);\n                    // If data is available, append data to url\n                    if (s.data) {\n                        cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n                        // #9682: remove data so that it's not used in an eventual retry\n                        delete s.data;\n                    }\n                    // Add or update anti-cache param if needed\n                    if (s.cache === false) {\n                        cacheURL = cacheURL.replace(rantiCache, \"$1\");\n                        uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + (nonce++) + uncached;\n                    }\n                    // Put hash and anti-cache on the URL that will be requested (gh-1732)\n                    s.url = cacheURL + uncached;\n                    // Change '%20' to '+' if this is encoded form body content (gh-2658)\n                }\n                else if (s.data && s.processData &&\n                    (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n                    s.data = s.data.replace(r20, \"+\");\n                }\n                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                if (s.ifModified) {\n                    if (jQuery.lastModified[cacheURL]) {\n                        jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n                    }\n                    if (jQuery.etag[cacheURL]) {\n                        jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n                    }\n                }\n                // Set the correct header, if data is being sent\n                if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n                    jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n                }\n                // Set the Accepts header for the server, depending on the dataType\n                jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?\n                    s.accepts[s.dataTypes[0]] +\n                        (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") :\n                    s.accepts[\"*\"]);\n                // Check for headers option\n                for (i in s.headers) {\n                    jqXHR.setRequestHeader(i, s.headers[i]);\n                }\n                // Allow custom headers/mimetypes and early abort\n                if (s.beforeSend &&\n                    (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n                    // Abort if not done already and return\n                    return jqXHR.abort();\n                }\n                // Aborting is no longer a cancellation\n                strAbort = \"abort\";\n                // Install callbacks on deferreds\n                completeDeferred.add(s.complete);\n                jqXHR.done(s.success);\n                jqXHR.fail(s.error);\n                // Get transport\n                transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n                // If no transport, we auto-abort\n                if (!transport) {\n                    done(-1, \"No Transport\");\n                }\n                else {\n                    jqXHR.readyState = 1;\n                    // Send global event\n                    if (fireGlobals) {\n                        globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n                    }\n                    // If request was aborted inside ajaxSend, stop there\n                    if (completed) {\n                        return jqXHR;\n                    }\n                    // Timeout\n                    if (s.async && s.timeout > 0) {\n                        timeoutTimer = window.setTimeout(function () {\n                            jqXHR.abort(\"timeout\");\n                        }, s.timeout);\n                    }\n                    try {\n                        completed = false;\n                        transport.send(requestHeaders, done);\n                    }\n                    catch (e) {\n                        // Rethrow post-completion exceptions\n                        if (completed) {\n                            throw e;\n                        }\n                        // Propagate others as results\n                        done(-1, e);\n                    }\n                }\n                // Callback for when everything is done\n                function done(status, nativeStatusText, responses, headers) {\n                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;\n                    // Ignore repeat invocations\n                    if (completed) {\n                        return;\n                    }\n                    completed = true;\n                    // Clear timeout if it exists\n                    if (timeoutTimer) {\n                        window.clearTimeout(timeoutTimer);\n                    }\n                    // Dereference transport for early garbage collection\n                    // (no matter how long the jqXHR object will be used)\n                    transport = undefined;\n                    // Cache response headers\n                    responseHeadersString = headers || \"\";\n                    // Set readyState\n                    jqXHR.readyState = status > 0 ? 4 : 0;\n                    // Determine if successful\n                    isSuccess = status >= 200 && status < 300 || status === 304;\n                    // Get response data\n                    if (responses) {\n                        response = ajaxHandleResponses(s, jqXHR, responses);\n                    }\n                    // Convert no matter what (that way responseXXX fields are always set)\n                    response = ajaxConvert(s, response, jqXHR, isSuccess);\n                    // If successful, handle type chaining\n                    if (isSuccess) {\n                        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                        if (s.ifModified) {\n                            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n                            if (modified) {\n                                jQuery.lastModified[cacheURL] = modified;\n                            }\n                            modified = jqXHR.getResponseHeader(\"etag\");\n                            if (modified) {\n                                jQuery.etag[cacheURL] = modified;\n                            }\n                        }\n                        // if no content\n                        if (status === 204 || s.type === \"HEAD\") {\n                            statusText = \"nocontent\";\n                            // if not modified\n                        }\n                        else if (status === 304) {\n                            statusText = \"notmodified\";\n                            // If we have data, let's convert it\n                        }\n                        else {\n                            statusText = response.state;\n                            success = response.data;\n                            error = response.error;\n                            isSuccess = !error;\n                        }\n                    }\n                    else {\n                        // Extract error from statusText and normalize for non-aborts\n                        error = statusText;\n                        if (status || !statusText) {\n                            statusText = \"error\";\n                            if (status < 0) {\n                                status = 0;\n                            }\n                        }\n                    }\n                    // Set data for the fake xhr object\n                    jqXHR.status = status;\n                    jqXHR.statusText = (nativeStatusText || statusText) + \"\";\n                    // Success/Error\n                    if (isSuccess) {\n                        deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n                    }\n                    else {\n                        deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n                    }\n                    // Status-dependent callbacks\n                    jqXHR.statusCode(statusCode);\n                    statusCode = undefined;\n                    if (fireGlobals) {\n                        globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n                    }\n                    // Complete\n                    completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n                    if (fireGlobals) {\n                        globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\n                        // Handle the global AJAX counter\n                        if (!(--jQuery.active)) {\n                            jQuery.event.trigger(\"ajaxStop\");\n                        }\n                    }\n                }\n                return jqXHR;\n            },\n            getJSON: function (url, data, callback) {\n                return jQuery.get(url, data, callback, \"json\");\n            },\n            getScript: function (url, callback) {\n                return jQuery.get(url, undefined, callback, \"script\");\n            }\n        });\n        jQuery.each([\"get\", \"post\"], function (i, method) {\n            jQuery[method] = function (url, data, callback, type) {\n                // Shift arguments if data argument was omitted\n                if (jQuery.isFunction(data)) {\n                    type = type || callback;\n                    callback = data;\n                    data = undefined;\n                }\n                // The url can be an options object (which then must have .url)\n                return jQuery.ajax(jQuery.extend({\n                    url: url,\n                    type: method,\n                    dataType: type,\n                    data: data,\n                    success: callback\n                }, jQuery.isPlainObject(url) && url));\n            };\n        });\n        jQuery._evalUrl = function (url) {\n            return jQuery.ajax({\n                url: url,\n                // Make this explicit, since user can override this through ajaxSetup (#11264)\n                type: \"GET\",\n                dataType: \"script\",\n                cache: true,\n                async: false,\n                global: false,\n                \"throws\": true\n            });\n        };\n        jQuery.fn.extend({\n            wrapAll: function (html) {\n                var wrap;\n                if (this[0]) {\n                    if (jQuery.isFunction(html)) {\n                        html = html.call(this[0]);\n                    }\n                    // The elements to wrap the target around\n                    wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n                    if (this[0].parentNode) {\n                        wrap.insertBefore(this[0]);\n                    }\n                    wrap.map(function () {\n                        var elem = this;\n                        while (elem.firstElementChild) {\n                            elem = elem.firstElementChild;\n                        }\n                        return elem;\n                    }).append(this);\n                }\n                return this;\n            },\n            wrapInner: function (html) {\n                if (jQuery.isFunction(html)) {\n                    return this.each(function (i) {\n                        jQuery(this).wrapInner(html.call(this, i));\n                    });\n                }\n                return this.each(function () {\n                    var self = jQuery(this), contents = self.contents();\n                    if (contents.length) {\n                        contents.wrapAll(html);\n                    }\n                    else {\n                        self.append(html);\n                    }\n                });\n            },\n            wrap: function (html) {\n                var isFunction = jQuery.isFunction(html);\n                return this.each(function (i) {\n                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n                });\n            },\n            unwrap: function (selector) {\n                this.parent(selector).not(\"body\").each(function () {\n                    jQuery(this).replaceWith(this.childNodes);\n                });\n                return this;\n            }\n        });\n        jQuery.expr.pseudos.hidden = function (elem) {\n            return !jQuery.expr.pseudos.visible(elem);\n        };\n        jQuery.expr.pseudos.visible = function (elem) {\n            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n        };\n        jQuery.ajaxSettings.xhr = function () {\n            try {\n                return new window.XMLHttpRequest();\n            }\n            catch (e) { }\n        };\n        var xhrSuccessStatus = {\n            // File protocol always yields status code 0, assume 200\n            0: 200,\n            // Support: IE <=9 only\n            // #1450: sometimes IE returns 1223 when it should be 204\n            1223: 204\n        }, xhrSupported = jQuery.ajaxSettings.xhr();\n        support.cors = !!xhrSupported && (\"withCredentials\" in xhrSupported);\n        support.ajax = xhrSupported = !!xhrSupported;\n        jQuery.ajaxTransport(function (options) {\n            var callback, errorCallback;\n            // Cross domain only allowed if supported through XMLHttpRequest\n            if (support.cors || xhrSupported && !options.crossDomain) {\n                return {\n                    send: function (headers, complete) {\n                        var i, xhr = options.xhr();\n                        xhr.open(options.type, options.url, options.async, options.username, options.password);\n                        // Apply custom fields if provided\n                        if (options.xhrFields) {\n                            for (i in options.xhrFields) {\n                                xhr[i] = options.xhrFields[i];\n                            }\n                        }\n                        // Override mime type if needed\n                        if (options.mimeType && xhr.overrideMimeType) {\n                            xhr.overrideMimeType(options.mimeType);\n                        }\n                        // X-Requested-With header\n                        // For cross-domain requests, seeing as conditions for a preflight are\n                        // akin to a jigsaw puzzle, we simply never set it to be sure.\n                        // (it can always be set on a per-request basis or even using ajaxSetup)\n                        // For same-domain requests, won't change header if already provided.\n                        if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n                            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                        }\n                        // Set headers\n                        for (i in headers) {\n                            xhr.setRequestHeader(i, headers[i]);\n                        }\n                        // Callback\n                        callback = function (type) {\n                            return function () {\n                                if (callback) {\n                                    callback = errorCallback = xhr.onload =\n                                        xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n                                    if (type === \"abort\") {\n                                        xhr.abort();\n                                    }\n                                    else if (type === \"error\") {\n                                        // Support: IE <=9 only\n                                        // On a manual native abort, IE9 throws\n                                        // errors on any property access that is not readyState\n                                        if (typeof xhr.status !== \"number\") {\n                                            complete(0, \"error\");\n                                        }\n                                        else {\n                                            complete(\n                                            // File: protocol always yields status 0; see #8605, #14207\n                                            xhr.status, xhr.statusText);\n                                        }\n                                    }\n                                    else {\n                                        complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, \n                                        // Support: IE <=9 only\n                                        // IE9 has no XHR2 but throws on binary (trac-11426)\n                                        // For XHR2 non-text, let the caller handle it (gh-2498)\n                                        (xhr.responseType || \"text\") !== \"text\" ||\n                                            typeof xhr.responseText !== \"string\" ?\n                                            { binary: xhr.response } :\n                                            { text: xhr.responseText }, xhr.getAllResponseHeaders());\n                                    }\n                                }\n                            };\n                        };\n                        // Listen to events\n                        xhr.onload = callback();\n                        errorCallback = xhr.onerror = callback(\"error\");\n                        // Support: IE 9 only\n                        // Use onreadystatechange to replace onabort\n                        // to handle uncaught aborts\n                        if (xhr.onabort !== undefined) {\n                            xhr.onabort = errorCallback;\n                        }\n                        else {\n                            xhr.onreadystatechange = function () {\n                                // Check readyState before timeout as it changes\n                                if (xhr.readyState === 4) {\n                                    // Allow onerror to be called first,\n                                    // but that will not handle a native abort\n                                    // Also, save errorCallback to a variable\n                                    // as xhr.onerror cannot be accessed\n                                    window.setTimeout(function () {\n                                        if (callback) {\n                                            errorCallback();\n                                        }\n                                    });\n                                }\n                            };\n                        }\n                        // Create the abort callback\n                        callback = callback(\"abort\");\n                        try {\n                            // Do send the request (this may raise an exception)\n                            xhr.send(options.hasContent && options.data || null);\n                        }\n                        catch (e) {\n                            // #14683: Only rethrow if this hasn't been notified as an error yet\n                            if (callback) {\n                                throw e;\n                            }\n                        }\n                    },\n                    abort: function () {\n                        if (callback) {\n                            callback();\n                        }\n                    }\n                };\n            }\n        });\n        // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n        jQuery.ajaxPrefilter(function (s) {\n            if (s.crossDomain) {\n                s.contents.script = false;\n            }\n        });\n        // Install script dataType\n        jQuery.ajaxSetup({\n            accepts: {\n                script: \"text/javascript, application/javascript, \" +\n                    \"application/ecmascript, application/x-ecmascript\"\n            },\n            contents: {\n                script: /\\b(?:java|ecma)script\\b/\n            },\n            converters: {\n                \"text script\": function (text) {\n                    jQuery.globalEval(text);\n                    return text;\n                }\n            }\n        });\n        // Handle cache's special case and crossDomain\n        jQuery.ajaxPrefilter(\"script\", function (s) {\n            if (s.cache === undefined) {\n                s.cache = false;\n            }\n            if (s.crossDomain) {\n                s.type = \"GET\";\n            }\n        });\n        // Bind script tag hack transport\n        jQuery.ajaxTransport(\"script\", function (s) {\n            // This transport only deals with cross domain requests\n            if (s.crossDomain) {\n                var script, callback;\n                return {\n                    send: function (_, complete) {\n                        script = jQuery(\"<script>\").prop({\n                            charset: s.scriptCharset,\n                            src: s.url\n                        }).on(\"load error\", callback = function (evt) {\n                            script.remove();\n                            callback = null;\n                            if (evt) {\n                                complete(evt.type === \"error\" ? 404 : 200, evt.type);\n                            }\n                        });\n                        // Use native DOM manipulation to avoid our domManip AJAX trickery\n                        document.head.appendChild(script[0]);\n                    },\n                    abort: function () {\n                        if (callback) {\n                            callback();\n                        }\n                    }\n                };\n            }\n        });\n        var oldCallbacks = [], rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n        // Default jsonp settings\n        jQuery.ajaxSetup({\n            jsonp: \"callback\",\n            jsonpCallback: function () {\n                var callback = oldCallbacks.pop() || (jQuery.expando + \"_\" + (nonce++));\n                this[callback] = true;\n                return callback;\n            }\n        });\n        // Detect, normalize options and install callbacks for jsonp requests\n        jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?\n                \"url\" :\n                typeof s.data === \"string\" &&\n                    (s.contentType || \"\")\n                        .indexOf(\"application/x-www-form-urlencoded\") === 0 &&\n                    rjsonp.test(s.data) && \"data\");\n            // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n            if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n                // Get callback name, remembering preexisting value associated with it\n                callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?\n                    s.jsonpCallback() :\n                    s.jsonpCallback;\n                // Insert callback into url or form data\n                if (jsonProp) {\n                    s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n                }\n                else if (s.jsonp !== false) {\n                    s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n                }\n                // Use data converter to retrieve json after script execution\n                s.converters[\"script json\"] = function () {\n                    if (!responseContainer) {\n                        jQuery.error(callbackName + \" was not called\");\n                    }\n                    return responseContainer[0];\n                };\n                // Force json dataType\n                s.dataTypes[0] = \"json\";\n                // Install callback\n                overwritten = window[callbackName];\n                window[callbackName] = function () {\n                    responseContainer = arguments;\n                };\n                // Clean-up function (fires after converters)\n                jqXHR.always(function () {\n                    // If previous value didn't exist - remove it\n                    if (overwritten === undefined) {\n                        jQuery(window).removeProp(callbackName);\n                        // Otherwise restore preexisting value\n                    }\n                    else {\n                        window[callbackName] = overwritten;\n                    }\n                    // Save back as free\n                    if (s[callbackName]) {\n                        // Make sure that re-using the options doesn't screw things around\n                        s.jsonpCallback = originalSettings.jsonpCallback;\n                        // Save the callback name for future use\n                        oldCallbacks.push(callbackName);\n                    }\n                    // Call if it was a function and we have a response\n                    if (responseContainer && jQuery.isFunction(overwritten)) {\n                        overwritten(responseContainer[0]);\n                    }\n                    responseContainer = overwritten = undefined;\n                });\n                // Delegate to script\n                return \"script\";\n            }\n        });\n        // Support: Safari 8 only\n        // In Safari 8 documents created via document.implementation.createHTMLDocument\n        // collapse sibling forms: the second one becomes a child of the first one.\n        // Because of that, this security measure has to be disabled in Safari 8.\n        // https://bugs.webkit.org/show_bug.cgi?id=137337\n        support.createHTMLDocument = (function () {\n            var body = document.implementation.createHTMLDocument(\"\").body;\n            body.innerHTML = \"<form></form><form></form>\";\n            return body.childNodes.length === 2;\n        })();\n        // Argument \"data\" should be string of html\n        // context (optional): If specified, the fragment will be created in this context,\n        // defaults to document\n        // keepScripts (optional): If true, will include scripts passed in the html string\n        jQuery.parseHTML = function (data, context, keepScripts) {\n            if (typeof data !== \"string\") {\n                return [];\n            }\n            if (typeof context === \"boolean\") {\n                keepScripts = context;\n                context = false;\n            }\n            var base, parsed, scripts;\n            if (!context) {\n                // Stop scripts or inline event handlers from being executed immediately\n                // by using document.implementation\n                if (support.createHTMLDocument) {\n                    context = document.implementation.createHTMLDocument(\"\");\n                    // Set the base href for the created document\n                    // so any parsed elements with URLs\n                    // are based on the document's URL (gh-2965)\n                    base = context.createElement(\"base\");\n                    base.href = document.location.href;\n                    context.head.appendChild(base);\n                }\n                else {\n                    context = document;\n                }\n            }\n            parsed = rsingleTag.exec(data);\n            scripts = !keepScripts && [];\n            // Single tag\n            if (parsed) {\n                return [context.createElement(parsed[1])];\n            }\n            parsed = buildFragment([data], context, scripts);\n            if (scripts && scripts.length) {\n                jQuery(scripts).remove();\n            }\n            return jQuery.merge([], parsed.childNodes);\n        };\n        /**\n         * Load a url into a page\n         */\n        jQuery.fn.load = function (url, params, callback) {\n            var selector, type, response, self = this, off = url.indexOf(\" \");\n            if (off > -1) {\n                selector = stripAndCollapse(url.slice(off));\n                url = url.slice(0, off);\n            }\n            // If it's a function\n            if (jQuery.isFunction(params)) {\n                // We assume that it's the callback\n                callback = params;\n                params = undefined;\n                // Otherwise, build a param string\n            }\n            else if (params && typeof params === \"object\") {\n                type = \"POST\";\n            }\n            // If we have elements to modify, make the request\n            if (self.length > 0) {\n                jQuery.ajax({\n                    url: url,\n                    // If \"type\" variable is undefined, then \"GET\" method will be used.\n                    // Make value of this field explicit since\n                    // user can override it through ajaxSetup method\n                    type: type || \"GET\",\n                    dataType: \"html\",\n                    data: params\n                }).done(function (responseText) {\n                    // Save response for use in complete callback\n                    response = arguments;\n                    self.html(selector ?\n                        // If a selector was specified, locate the right elements in a dummy div\n                        // Exclude scripts to avoid IE 'Permission Denied' errors\n                        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\n                        // Otherwise use the full result\n                        responseText);\n                    // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n                    // but they are ignored because response was set above.\n                    // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n                }).always(callback && function (jqXHR, status) {\n                    self.each(function () {\n                        callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n                    });\n                });\n            }\n            return this;\n        };\n        // Attach a bunch of functions for handling common AJAX events\n        jQuery.each([\n            \"ajaxStart\",\n            \"ajaxStop\",\n            \"ajaxComplete\",\n            \"ajaxError\",\n            \"ajaxSuccess\",\n            \"ajaxSend\"\n        ], function (i, type) {\n            jQuery.fn[type] = function (fn) {\n                return this.on(type, fn);\n            };\n        });\n        jQuery.expr.pseudos.animated = function (elem) {\n            return jQuery.grep(jQuery.timers, function (fn) {\n                return elem === fn.elem;\n            }).length;\n        };\n        jQuery.offset = {\n            setOffset: function (elem, options, i) {\n                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, \"position\"), curElem = jQuery(elem), props = {};\n                // Set position first, in-case top/left are set even on static elem\n                if (position === \"static\") {\n                    elem.style.position = \"relative\";\n                }\n                curOffset = curElem.offset();\n                curCSSTop = jQuery.css(elem, \"top\");\n                curCSSLeft = jQuery.css(elem, \"left\");\n                calculatePosition = (position === \"absolute\" || position === \"fixed\") &&\n                    (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n                // Need to be able to calculate position if either\n                // top or left is auto and position is either absolute or fixed\n                if (calculatePosition) {\n                    curPosition = curElem.position();\n                    curTop = curPosition.top;\n                    curLeft = curPosition.left;\n                }\n                else {\n                    curTop = parseFloat(curCSSTop) || 0;\n                    curLeft = parseFloat(curCSSLeft) || 0;\n                }\n                if (jQuery.isFunction(options)) {\n                    // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n                    options = options.call(elem, i, jQuery.extend({}, curOffset));\n                }\n                if (options.top != null) {\n                    props.top = (options.top - curOffset.top) + curTop;\n                }\n                if (options.left != null) {\n                    props.left = (options.left - curOffset.left) + curLeft;\n                }\n                if (\"using\" in options) {\n                    options.using.call(elem, props);\n                }\n                else {\n                    curElem.css(props);\n                }\n            }\n        };\n        jQuery.fn.extend({\n            offset: function (options) {\n                // Preserve chaining for setter\n                if (arguments.length) {\n                    return options === undefined ?\n                        this :\n                        this.each(function (i) {\n                            jQuery.offset.setOffset(this, options, i);\n                        });\n                }\n                var doc, docElem, rect, win, elem = this[0];\n                if (!elem) {\n                    return;\n                }\n                // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n                // Support: IE <=11 only\n                // Running getBoundingClientRect on a\n                // disconnected node in IE throws an error\n                if (!elem.getClientRects().length) {\n                    return { top: 0, left: 0 };\n                }\n                rect = elem.getBoundingClientRect();\n                doc = elem.ownerDocument;\n                docElem = doc.documentElement;\n                win = doc.defaultView;\n                return {\n                    top: rect.top + win.pageYOffset - docElem.clientTop,\n                    left: rect.left + win.pageXOffset - docElem.clientLeft\n                };\n            },\n            position: function () {\n                if (!this[0]) {\n                    return;\n                }\n                var offsetParent, offset, elem = this[0], parentOffset = { top: 0, left: 0 };\n                // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n                // because it is its only offset parent\n                if (jQuery.css(elem, \"position\") === \"fixed\") {\n                    // Assume getBoundingClientRect is there when computed position is fixed\n                    offset = elem.getBoundingClientRect();\n                }\n                else {\n                    // Get *real* offsetParent\n                    offsetParent = this.offsetParent();\n                    // Get correct offsets\n                    offset = this.offset();\n                    if (!nodeName(offsetParent[0], \"html\")) {\n                        parentOffset = offsetParent.offset();\n                    }\n                    // Add offsetParent borders\n                    parentOffset = {\n                        top: parentOffset.top + jQuery.css(offsetParent[0], \"borderTopWidth\", true),\n                        left: parentOffset.left + jQuery.css(offsetParent[0], \"borderLeftWidth\", true)\n                    };\n                }\n                // Subtract parent offsets and element margins\n                return {\n                    top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n                    left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n                };\n            },\n            // This method will return documentElement in the following cases:\n            // 1) For the element inside the iframe without offsetParent, this method will return\n            //    documentElement of the parent window\n            // 2) For the hidden or detached element\n            // 3) For body or html element, i.e. in case of the html node - it will return itself\n            //\n            // but those exceptions were never presented as a real life use-cases\n            // and might be considered as more preferable results.\n            //\n            // This logic, however, is not guaranteed and can change at any point in the future\n            offsetParent: function () {\n                return this.map(function () {\n                    var offsetParent = this.offsetParent;\n                    while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n                        offsetParent = offsetParent.offsetParent;\n                    }\n                    return offsetParent || documentElement;\n                });\n            }\n        });\n        // Create scrollLeft and scrollTop methods\n        jQuery.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (method, prop) {\n            var top = \"pageYOffset\" === prop;\n            jQuery.fn[method] = function (val) {\n                return access(this, function (elem, method, val) {\n                    // Coalesce documents and windows\n                    var win;\n                    if (jQuery.isWindow(elem)) {\n                        win = elem;\n                    }\n                    else if (elem.nodeType === 9) {\n                        win = elem.defaultView;\n                    }\n                    if (val === undefined) {\n                        return win ? win[prop] : elem[method];\n                    }\n                    if (win) {\n                        win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n                    }\n                    else {\n                        elem[method] = val;\n                    }\n                }, method, val, arguments.length);\n            };\n        });\n        // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n        // Add the top/left cssHooks using jQuery.fn.position\n        // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n        // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n        // getComputedStyle returns percent when specified for top/left/bottom/right;\n        // rather than make the css module depend on the offset module, just check for it here\n        jQuery.each([\"top\", \"left\"], function (i, prop) {\n            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n                if (computed) {\n                    computed = curCSS(elem, prop);\n                    // If curCSS returns percentage, fallback to offset\n                    return rnumnonpx.test(computed) ?\n                        jQuery(elem).position()[prop] + \"px\" :\n                        computed;\n                }\n            });\n        });\n        // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n        jQuery.each({ Height: \"height\", Width: \"width\" }, function (name, type) {\n            jQuery.each({ padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function (defaultExtra, funcName) {\n                // Margin is only for outerHeight, outerWidth\n                jQuery.fn[funcName] = function (margin, value) {\n                    var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"), extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n                    return access(this, function (elem, type, value) {\n                        var doc;\n                        if (jQuery.isWindow(elem)) {\n                            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n                            return funcName.indexOf(\"outer\") === 0 ?\n                                elem[\"inner\" + name] :\n                                elem.document.documentElement[\"client\" + name];\n                        }\n                        // Get document width or height\n                        if (elem.nodeType === 9) {\n                            doc = elem.documentElement;\n                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n                            // whichever is greatest\n                            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n                        }\n                        return value === undefined ?\n                            // Get width or height on the element, requesting but not forcing parseFloat\n                            jQuery.css(elem, type, extra) :\n                            // Set width or height on the element\n                            jQuery.style(elem, type, value, extra);\n                    }, type, chainable ? margin : undefined, chainable);\n                };\n            });\n        });\n        jQuery.fn.extend({\n            bind: function (types, data, fn) {\n                return this.on(types, null, data, fn);\n            },\n            unbind: function (types, fn) {\n                return this.off(types, null, fn);\n            },\n            delegate: function (selector, types, data, fn) {\n                return this.on(types, selector, data, fn);\n            },\n            undelegate: function (selector, types, fn) {\n                // ( namespace ) or ( selector, types [, fn] )\n                return arguments.length === 1 ?\n                    this.off(selector, \"**\") :\n                    this.off(types, selector || \"**\", fn);\n            }\n        });\n        jQuery.holdReady = function (hold) {\n            if (hold) {\n                jQuery.readyWait++;\n            }\n            else {\n                jQuery.ready(true);\n            }\n        };\n        jQuery.isArray = Array.isArray;\n        jQuery.parseJSON = JSON.parse;\n        jQuery.nodeName = nodeName;\n        // Register as a named AMD module, since jQuery can be concatenated with other\n        // files that may use define, but not via a proper concatenation script that\n        // understands anonymous AMD modules. A named AMD is safest and most robust\n        // way to register. Lowercase jquery is used because AMD module names are\n        // derived from file names, and jQuery is normally delivered in a lowercase\n        // file name. Do this after creating the global so that if an AMD module wants\n        // to call noConflict to hide this version of jQuery, it will work.\n        // Note that for maximum portability, libraries that are not jQuery should\n        // declare themselves as anonymous modules, and avoid setting a global if an\n        // AMD loader is present. jQuery is a special case. For more information, see\n        // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n        if (typeof define === \"function\" && define.amd) {\n            define(\"jquery\", [], function () {\n                return jQuery;\n            });\n        }\n        var \n        // Map over jQuery in case of overwrite\n        _jQuery = window.jQuery, \n        // Map over the $ in case of overwrite\n        _$ = window.$;\n        jQuery.noConflict = function (deep) {\n            if (window.$ === jQuery) {\n                window.$ = _$;\n            }\n            if (deep && window.jQuery === jQuery) {\n                window.jQuery = _jQuery;\n            }\n            return jQuery;\n        };\n        // Expose jQuery and $ identifiers, even in AMD\n        // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n        // and CommonJS for browser emulators (#13566)\n        if (!noGlobal) {\n            window.jQuery = window.$ = jQuery;\n        }\n        return jQuery;\n    });\n}\n","/* slickgrid/lib/jquery.event.drag-2.3.0 */ function _(require, module, exports) {\n    /*!\n     * jquery.event.drag - v 2.3.0\n     * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n     * Open Source MIT License - http://threedubmedia.com/code/license\n     */\n    // Created: 2008-06-04\n    // Updated: 2012-05-21\n    // Updated: 2016-08-16   Luiz Gonzaga dos Santos Filho\n    // REQUIRES: jquery 1.8 +, , event.drag 2.3.0\n    // TESTED WITH: jQuery 1.8.3, 1.11.2, 2.2.4, and 3.1.0\n    var $ = require(445) /* ../slick.jquery */;\n    // add the jquery instance method\n    $.fn.drag = function (str, arg, opts) {\n        // figure out the event type\n        var type = typeof str == \"string\" ? str : \"\", \n        // figure out the event handler...\n        fn = $.isFunction(str) ? str : $.isFunction(arg) ? arg : null;\n        // fix the event type\n        if (type.indexOf(\"drag\") !== 0)\n            type = \"drag\" + type;\n        // were options passed\n        opts = (str == fn ? arg : opts) || {};\n        // trigger or bind event handler\n        return fn ? this.on(type, opts, fn) : this.trigger(type);\n    };\n    // local refs (increase compression)\n    var $event = $.event, $special = $event.special, \n    // configure the drag special event\n    drag = $special.drag = {\n        // these are the default settings\n        defaults: {\n            which: 1,\n            distance: 0,\n            not: ':input',\n            handle: null,\n            relative: false,\n            drop: true,\n            click: false // false to suppress click events after dragend (no proxy)\n        },\n        // the key name for stored drag data\n        datakey: \"dragdata\",\n        // prevent bubbling for better performance\n        noBubble: true,\n        // count bound related events\n        add: function (obj) {\n            // read the interaction data\n            var data = $.data(this, drag.datakey), \n            // read any passed options\n            opts = obj.data || {};\n            // count another realted event\n            data.related += 1;\n            // extend data options bound with this event\n            // don't iterate \"opts\" in case it is a node\n            $.each(drag.defaults, function (key, def) {\n                if (opts[key] !== undefined)\n                    data[key] = opts[key];\n            });\n        },\n        // forget unbound related events\n        remove: function () {\n            $.data(this, drag.datakey).related -= 1;\n        },\n        // configure interaction, capture settings\n        setup: function () {\n            // check for related events\n            if ($.data(this, drag.datakey))\n                return;\n            // initialize the drag data with copied defaults\n            var data = $.extend({ related: 0 }, drag.defaults);\n            // store the interaction data\n            $.data(this, drag.datakey, data);\n            // bind the mousedown event, which starts drag interactions\n            $event.add(this, \"touchstart mousedown\", drag.init, data);\n            // prevent image dragging in IE...\n            if (this.attachEvent)\n                this.attachEvent(\"ondragstart\", drag.dontstart);\n        },\n        // destroy configured interaction\n        teardown: function () {\n            var data = $.data(this, drag.datakey) || {};\n            // check for related events\n            if (data.related)\n                return;\n            // remove the stored data\n            $.removeData(this, drag.datakey);\n            // remove the mousedown event\n            $event.remove(this, \"touchstart mousedown\", drag.init);\n            // enable text selection\n            drag.textselect(true);\n            // un-prevent image dragging in IE...\n            if (this.detachEvent)\n                this.detachEvent(\"ondragstart\", drag.dontstart);\n        },\n        // initialize the interaction\n        init: function (event) {\n            // sorry, only one touch at a time\n            if (drag.touched)\n                return;\n            // the drag/drop interaction data\n            var dd = event.data, results;\n            // check the which directive\n            if (event.which != 0 && dd.which > 0 && event.which != dd.which)\n                return;\n            // check for suppressed selector\n            if ($(event.target).is(dd.not))\n                return;\n            // check for handle selector\n            if (dd.handle && !$(event.target).closest(dd.handle, event.currentTarget).length)\n                return;\n            drag.touched = event.type == 'touchstart' ? this : null;\n            dd.propagates = 1;\n            dd.mousedown = this;\n            dd.interactions = [drag.interaction(this, dd)];\n            dd.target = event.target;\n            dd.pageX = event.pageX;\n            dd.pageY = event.pageY;\n            dd.dragging = null;\n            // handle draginit event...\n            results = drag.hijack(event, \"draginit\", dd);\n            // early cancel\n            if (!dd.propagates)\n                return;\n            // flatten the result set\n            results = drag.flatten(results);\n            // insert new interaction elements\n            if (results && results.length) {\n                dd.interactions = [];\n                $.each(results, function () {\n                    dd.interactions.push(drag.interaction(this, dd));\n                });\n            }\n            // remember how many interactions are propagating\n            dd.propagates = dd.interactions.length;\n            // locate and init the drop targets\n            if (dd.drop !== false && $special.drop)\n                $special.drop.handler(event, dd);\n            // disable text selection\n            drag.textselect(false);\n            // bind additional events...\n            if (drag.touched)\n                $event.add(drag.touched, \"touchmove touchend\", drag.handler, dd);\n            else\n                $event.add(document, \"mousemove mouseup\", drag.handler, dd);\n            // helps prevent text selection or scrolling\n            if (!drag.touched || dd.live)\n                return false;\n        },\n        // returns an interaction object\n        interaction: function (elem, dd) {\n            var offset = (elem && elem.ownerDocument)\n                ? $(elem)[dd.relative ? \"position\" : \"offset\"]() || { top: 0, left: 0 }\n                : { top: 0, left: 0 };\n            return {\n                drag: elem,\n                callback: new drag.callback(),\n                droppable: [],\n                offset: offset\n            };\n        },\n        // handle drag-releatd DOM events\n        handler: function (event) {\n            // read the data before hijacking anything\n            var dd = event.data;\n            // handle various events\n            switch (event.type) {\n                // mousemove, check distance, start dragging\n                case !dd.dragging && 'touchmove':\n                    event.preventDefault();\n                case !dd.dragging && 'mousemove':\n                    //  drag tolerance, x + y = distance\n                    if (Math.pow(event.pageX - dd.pageX, 2) + Math.pow(event.pageY - dd.pageY, 2) < Math.pow(dd.distance, 2))\n                        break; // distance tolerance not reached\n                    event.target = dd.target; // force target from \"mousedown\" event (fix distance issue)\n                    drag.hijack(event, \"dragstart\", dd); // trigger \"dragstart\"\n                    if (dd.propagates) // \"dragstart\" not rejected\n                        dd.dragging = true; // activate interaction\n                // mousemove, dragging\n                case 'touchmove':\n                    event.preventDefault();\n                case 'mousemove':\n                    if (dd.dragging) {\n                        // trigger \"drag\"\n                        drag.hijack(event, \"drag\", dd);\n                        if (dd.propagates) {\n                            // manage drop events\n                            if (dd.drop !== false && $special.drop)\n                                $special.drop.handler(event, dd); // \"dropstart\", \"dropend\"\n                            break; // \"drag\" not rejected, stop\n                        }\n                        event.type = \"mouseup\"; // helps \"drop\" handler behave\n                    }\n                // mouseup, stop dragging\n                case 'touchend':\n                case 'mouseup':\n                default:\n                    if (drag.touched)\n                        $event.remove(drag.touched, \"touchmove touchend\", drag.handler); // remove touch events\n                    else\n                        $event.remove(document, \"mousemove mouseup\", drag.handler); // remove page events\n                    if (dd.dragging) {\n                        if (dd.drop !== false && $special.drop)\n                            $special.drop.handler(event, dd); // \"drop\"\n                        drag.hijack(event, \"dragend\", dd); // trigger \"dragend\"\n                    }\n                    drag.textselect(true); // enable text selection\n                    // if suppressing click events...\n                    if (dd.click === false && dd.dragging)\n                        $.data(dd.mousedown, \"suppress.click\", new Date().getTime() + 5);\n                    dd.dragging = drag.touched = false; // deactivate element\n                    break;\n            }\n        },\n        // re-use event object for custom events\n        hijack: function (event, type, dd, x, elem) {\n            // not configured\n            if (!dd)\n                return;\n            // remember the original event and type\n            var orig = { event: event.originalEvent, type: event.type }, \n            // is the event drag related or drog related?\n            mode = type.indexOf(\"drop\") ? \"drag\" : \"drop\", \n            // iteration vars\n            result, i = x || 0, ia, $elems, callback, len = !isNaN(x) ? x : dd.interactions.length;\n            // modify the event type\n            event.type = type;\n            // protects originalEvent from side-effects\n            var noop = function () { };\n            event.originalEvent = new $.Event(orig.event, {\n                preventDefault: noop,\n                stopPropagation: noop,\n                stopImmediatePropagation: noop\n            });\n            // initialize the results\n            dd.results = [];\n            // handle each interacted element\n            do\n                if (ia = dd.interactions[i]) {\n                    // validate the interaction\n                    if (type !== \"dragend\" && ia.cancelled)\n                        continue;\n                    // set the dragdrop properties on the event object\n                    callback = drag.properties(event, dd, ia);\n                    // prepare for more results\n                    ia.results = [];\n                    // handle each element\n                    $(elem || ia[mode] || dd.droppable).each(function (p, subject) {\n                        // identify drag or drop targets individually\n                        callback.target = subject;\n                        // force propagtion of the custom event\n                        event.isPropagationStopped = function () { return false; };\n                        // handle the event\n                        result = subject ? $event.dispatch.call(subject, event, callback) : null;\n                        // stop the drag interaction for this element\n                        if (result === false) {\n                            if (mode == \"drag\") {\n                                ia.cancelled = true;\n                                dd.propagates -= 1;\n                            }\n                            if (type == \"drop\") {\n                                ia[mode][p] = null;\n                            }\n                        }\n                        // assign any dropinit elements\n                        else if (type == \"dropinit\")\n                            ia.droppable.push(drag.element(result) || subject);\n                        // accept a returned proxy element\n                        if (type == \"dragstart\")\n                            ia.proxy = $(drag.element(result) || ia.drag)[0];\n                        // remember this result\n                        ia.results.push(result);\n                        // forget the event result, for recycling\n                        delete event.result;\n                        // break on cancelled handler\n                        if (type !== \"dropinit\")\n                            return result;\n                    });\n                    // flatten the results\n                    dd.results[i] = drag.flatten(ia.results);\n                    // accept a set of valid drop targets\n                    if (type == \"dropinit\")\n                        ia.droppable = drag.flatten(ia.droppable);\n                    // locate drop targets\n                    if (type == \"dragstart\" && !ia.cancelled)\n                        callback.update();\n                }\n            while (++i < len);\n            // restore the original event & type\n            event.type = orig.type;\n            event.originalEvent = orig.event;\n            // return all handler results\n            return drag.flatten(dd.results);\n        },\n        // extend the callback object with drag/drop properties...\n        properties: function (event, dd, ia) {\n            var obj = ia.callback;\n            // elements\n            obj.drag = ia.drag;\n            obj.proxy = ia.proxy || ia.drag;\n            // starting mouse position\n            obj.startX = dd.pageX;\n            obj.startY = dd.pageY;\n            // current distance dragged\n            obj.deltaX = event.pageX - dd.pageX;\n            obj.deltaY = event.pageY - dd.pageY;\n            // original element position\n            obj.originalX = ia.offset.left;\n            obj.originalY = ia.offset.top;\n            // adjusted element position\n            obj.offsetX = obj.originalX + obj.deltaX;\n            obj.offsetY = obj.originalY + obj.deltaY;\n            // assign the drop targets information\n            obj.drop = drag.flatten((ia.drop || []).slice());\n            obj.available = drag.flatten((ia.droppable || []).slice());\n            return obj;\n        },\n        // determine is the argument is an element or jquery instance\n        element: function (arg) {\n            if (arg && (arg.jquery || arg.nodeType == 1))\n                return arg;\n        },\n        // flatten nested jquery objects and arrays into a single dimension array\n        flatten: function (arr) {\n            return $.map(arr, function (member) {\n                return member && member.jquery ? $.makeArray(member) :\n                    member && member.length ? drag.flatten(member) : member;\n            });\n        },\n        // toggles text selection attributes ON (true) or OFF (false)\n        textselect: function (bool) {\n            $(document)[bool ? \"off\" : \"on\"](\"selectstart\", drag.dontstart)\n                .css(\"MozUserSelect\", bool ? \"\" : \"none\");\n            // .attr(\"unselectable\", bool ? \"off\" : \"on\" )\n            document.unselectable = bool ? \"off\" : \"on\";\n        },\n        // suppress \"selectstart\" and \"ondragstart\" events\n        dontstart: function () {\n            return false;\n        },\n        // a callback instance contructor\n        callback: function () { }\n    };\n    // callback methods\n    drag.callback.prototype = {\n        update: function () {\n            if ($special.drop && this.available.length)\n                $.each(this.available, function (i) {\n                    $special.drop.locate(this, i);\n                });\n        }\n    };\n    // patch $.event.$dispatch to allow suppressing clicks\n    var $dispatch = $event.dispatch;\n    $event.dispatch = function (event) {\n        if ($.data(this, \"suppress.\" + event.type) - new Date().getTime() > 0) {\n            $.removeData(this, \"suppress.\" + event.type);\n            return;\n        }\n        return $dispatch.apply(this, arguments);\n    };\n    // share the same special event configuration with related events...\n    $special.draginit = $special.dragstart = $special.dragend = drag;\n}\n","/* slickgrid/lib/jquery.event.drop-2.3.0 */ function _(require, module, exports) {\n    /*!\n     * jquery.event.drop - v 2.3.0\n     * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com\n     * Open Source MIT License - http://threedubmedia.com/code/license\n     */\n    // Created: 2008-06-04\n    // Updated: 2012-05-21\n    // Updated: 2016-08-16   Luiz Gonzaga dos Santos Filho\n    // REQUIRES: jquery 1.8 +, , event.drag 2.3.0\n    // TESTED WITH: jQuery 1.8.3, 1.11.2, 2.2.4, and 3.1.0\n    var $ = require(445) /* ../slick.jquery */;\n    // Events: drop, dropstart, dropend\n    // add the jquery instance method\n    $.fn.drop = function (str, arg, opts) {\n        // figure out the event type\n        var type = typeof str == \"string\" ? str : \"\", \n        // figure out the event handler...\n        fn = $.isFunction(str) ? str : $.isFunction(arg) ? arg : null;\n        // fix the event type\n        if (type.indexOf(\"drop\") !== 0)\n            type = \"drop\" + type;\n        // were options passed\n        opts = (str == fn ? arg : opts) || {};\n        // trigger or bind event handler\n        return fn ? this.on(type, opts, fn) : this.trigger(type);\n    };\n    // DROP MANAGEMENT UTILITY\n    // returns filtered drop target elements, caches their positions\n    $.drop = function (opts) {\n        opts = opts || {};\n        // safely set new options...\n        drop.multi = opts.multi === true ? Infinity :\n            opts.multi === false ? 1 : !isNaN(opts.multi) ? opts.multi : drop.multi;\n        drop.delay = opts.delay || drop.delay;\n        drop.tolerance = $.isFunction(opts.tolerance) ? opts.tolerance :\n            opts.tolerance === null ? null : drop.tolerance;\n        drop.mode = opts.mode || drop.mode || 'intersect';\n    };\n    // local refs (increase compression)\n    var $event = $.event, $special = $event.special, \n    // configure the drop special event\n    drop = $.event.special.drop = {\n        // these are the default settings\n        multi: 1,\n        delay: 20,\n        mode: 'overlap',\n        // internal cache\n        targets: [],\n        // the key name for stored drop data\n        datakey: \"dropdata\",\n        // prevent bubbling for better performance\n        noBubble: true,\n        // count bound related events\n        add: function (obj) {\n            // read the interaction data\n            var data = $.data(this, drop.datakey);\n            // count another realted event\n            data.related += 1;\n        },\n        // forget unbound related events\n        remove: function () {\n            $.data(this, drop.datakey).related -= 1;\n        },\n        // configure the interactions\n        setup: function () {\n            // check for related events\n            if ($.data(this, drop.datakey))\n                return;\n            // initialize the drop element data\n            var data = {\n                related: 0,\n                active: [],\n                anyactive: 0,\n                winner: 0,\n                location: {}\n            };\n            // store the drop data on the element\n            $.data(this, drop.datakey, data);\n            // store the drop target in internal cache\n            drop.targets.push(this);\n        },\n        // destroy the configure interaction\n        teardown: function () {\n            var data = $.data(this, drop.datakey) || {};\n            // check for related events\n            if (data.related)\n                return;\n            // remove the stored data\n            $.removeData(this, drop.datakey);\n            // reference the targeted element\n            var element = this;\n            // remove from the internal cache\n            drop.targets = $.grep(drop.targets, function (target) {\n                return (target !== element);\n            });\n        },\n        // shared event handler\n        handler: function (event, dd) {\n            // local vars\n            var results, $targets;\n            // make sure the right data is available\n            if (!dd)\n                return;\n            // handle various events\n            switch (event.type) {\n                // draginit, from $.event.special.drag\n                case 'mousedown': // DROPINIT >>\n                case 'touchstart': // DROPINIT >>\n                    // collect and assign the drop targets\n                    $targets = $(drop.targets);\n                    if (typeof dd.drop == \"string\")\n                        $targets = $targets.filter(dd.drop);\n                    // reset drop data winner properties\n                    $targets.each(function () {\n                        var data = $.data(this, drop.datakey);\n                        data.active = [];\n                        data.anyactive = 0;\n                        data.winner = 0;\n                    });\n                    // set available target elements\n                    dd.droppable = $targets;\n                    // activate drop targets for the initial element being dragged\n                    $special.drag.hijack(event, \"dropinit\", dd);\n                    break;\n                // drag, from $.event.special.drag\n                case 'mousemove': // TOLERATE >>\n                case 'touchmove': // TOLERATE >>\n                    drop.event = event; // store the mousemove event\n                    if (!drop.timer)\n                        // monitor drop targets\n                        drop.tolerate(dd);\n                    break;\n                // dragend, from $.event.special.drag\n                case 'mouseup': // DROP >> DROPEND >>\n                case 'touchend': // DROP >> DROPEND >>\n                    drop.timer = clearTimeout(drop.timer); // delete timer\n                    if (dd.propagates) {\n                        $special.drag.hijack(event, \"drop\", dd);\n                        $special.drag.hijack(event, \"dropend\", dd);\n                    }\n                    break;\n            }\n        },\n        // returns the location positions of an element\n        locate: function (elem, index) {\n            var data = $.data(elem, drop.datakey), $elem = $(elem), posi = $elem.offset() || {}, height = $elem.outerHeight(), width = $elem.outerWidth(), location = {\n                elem: elem,\n                width: width,\n                height: height,\n                top: posi.top,\n                left: posi.left,\n                right: posi.left + width,\n                bottom: posi.top + height\n            };\n            // drag elements might not have dropdata\n            if (data) {\n                data.location = location;\n                data.index = index;\n                data.elem = elem;\n            }\n            return location;\n        },\n        // test the location positions of an element against another OR an X,Y coord\n        contains: function (target, test) {\n            return ((test[0] || test.left) >= target.left && (test[0] || test.right) <= target.right\n                && (test[1] || test.top) >= target.top && (test[1] || test.bottom) <= target.bottom);\n        },\n        // stored tolerance modes\n        modes: {\n            // target with mouse wins, else target with most overlap wins\n            'intersect': function (event, proxy, target) {\n                return this.contains(target, [event.pageX, event.pageY]) ? // check cursor\n                    1e9 : this.modes.overlap.apply(this, arguments); // check overlap\n            },\n            // target with most overlap wins\n            'overlap': function (event, proxy, target) {\n                // calculate the area of overlap...\n                return Math.max(0, Math.min(target.bottom, proxy.bottom) - Math.max(target.top, proxy.top))\n                    * Math.max(0, Math.min(target.right, proxy.right) - Math.max(target.left, proxy.left));\n            },\n            // proxy is completely contained within target bounds\n            'fit': function (event, proxy, target) {\n                return this.contains(target, proxy) ? 1 : 0;\n            },\n            // center of the proxy is contained within target bounds\n            'middle': function (event, proxy, target) {\n                return this.contains(target, [proxy.left + proxy.width * .5, proxy.top + proxy.height * .5]) ? 1 : 0;\n            }\n        },\n        // sort drop target cache by by winner (dsc), then index (asc)\n        sort: function (a, b) {\n            return (b.winner - a.winner) || (a.index - b.index);\n        },\n        // async, recursive tolerance execution\n        tolerate: function (dd) {\n            // declare local refs\n            var i, drp, drg, data, arr, len, elem, \n            // interaction iteration variables\n            x = 0, ia, end = dd.interactions.length, \n            // determine the mouse coords\n            xy = [drop.event.pageX, drop.event.pageY], \n            // custom or stored tolerance fn\n            tolerance = drop.tolerance || drop.modes[drop.mode];\n            // go through each passed interaction...\n            do\n                if (ia = dd.interactions[x]) {\n                    // check valid interaction\n                    if (!ia)\n                        return;\n                    // initialize or clear the drop data\n                    ia.drop = [];\n                    // holds the drop elements\n                    arr = [];\n                    len = ia.droppable.length;\n                    // determine the proxy location, if needed\n                    if (tolerance)\n                        drg = drop.locate(ia.proxy);\n                    // reset the loop\n                    i = 0;\n                    // loop each stored drop target\n                    do\n                        if (elem = ia.droppable[i]) {\n                            data = $.data(elem, drop.datakey);\n                            drp = data.location;\n                            if (!drp)\n                                continue;\n                            // find a winner: tolerance function is defined, call it\n                            data.winner = tolerance ? tolerance.call(drop, drop.event, drg, drp)\n                                // mouse position is always the fallback\n                                : drop.contains(drp, xy) ? 1 : 0;\n                            arr.push(data);\n                        }\n                    while (++i < len); // loop\n                    // sort the drop targets\n                    arr.sort(drop.sort);\n                    // reset the loop\n                    i = 0;\n                    // loop through all of the targets again\n                    do\n                        if (data = arr[i]) {\n                            // winners...\n                            if (data.winner && ia.drop.length < drop.multi) {\n                                // new winner... dropstart\n                                if (!data.active[x] && !data.anyactive) {\n                                    // check to make sure that this is not prevented\n                                    if ($special.drag.hijack(drop.event, \"dropstart\", dd, x, data.elem)[0] !== false) {\n                                        data.active[x] = 1;\n                                        data.anyactive += 1;\n                                    }\n                                    // if false, it is not a winner\n                                    else\n                                        data.winner = 0;\n                                }\n                                // if it is still a winner\n                                if (data.winner)\n                                    ia.drop.push(data.elem);\n                            }\n                            // losers...\n                            else if (data.active[x] && data.anyactive == 1) {\n                                // former winner... dropend\n                                $special.drag.hijack(drop.event, \"dropend\", dd, x, data.elem);\n                                data.active[x] = 0;\n                                data.anyactive -= 1;\n                            }\n                        }\n                    while (++i < len); // loop\n                }\n            while (++x < end); // loop\n            // check if the mouse is still moving or is idle\n            if (drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY)\n                delete drop.timer; // idle, don't recurse\n            else // recurse\n                drop.timer = setTimeout(function () {\n                    drop.tolerate(dd);\n                }, drop.delay);\n            // remember event, to compare idleness\n            drop.last = drop.event;\n        }\n    };\n    // share the same special event configuration with related events...\n    $special.dropinit = $special.dropstart = $special.dropend = drop;\n}\n","/* slickgrid/plugins/slick.checkboxselectcolumn */ function _(require, module, exports) {\n    var $ = require(445) /* ../slick.jquery */;\n    var Slick = require(443) /* ../slick.core */;\n    function CheckboxSelectColumn(options) {\n        var _grid;\n        var _self = this;\n        var _handler = new Slick.EventHandler();\n        var _selectedRowsLookup = {};\n        var _defaults = {\n            columnId: \"_checkbox_selector\",\n            cssClass: null,\n            toolTip: \"Select/Deselect All\",\n            width: 30\n        };\n        var _options = $.extend(true, {}, _defaults, options);\n        function init(grid) {\n            _grid = grid;\n            _handler\n                .subscribe(_grid.onSelectedRowsChanged, handleSelectedRowsChanged)\n                .subscribe(_grid.onClick, handleClick)\n                .subscribe(_grid.onHeaderClick, handleHeaderClick)\n                .subscribe(_grid.onKeyDown, handleKeyDown);\n        }\n        function destroy() {\n            _handler.unsubscribeAll();\n        }\n        function handleSelectedRowsChanged(e, args) {\n            var selectedRows = _grid.getSelectedRows();\n            var lookup = {}, row, i;\n            for (i = 0; i < selectedRows.length; i++) {\n                row = selectedRows[i];\n                lookup[row] = true;\n                if (lookup[row] !== _selectedRowsLookup[row]) {\n                    _grid.invalidateRow(row);\n                    delete _selectedRowsLookup[row];\n                }\n            }\n            for (i in _selectedRowsLookup) {\n                _grid.invalidateRow(i);\n            }\n            _selectedRowsLookup = lookup;\n            _grid.render();\n            if (selectedRows.length && selectedRows.length == _grid.getDataLength()) {\n                _grid.updateColumnHeader(_options.columnId, \"<input type='checkbox' checked='checked'>\", _options.toolTip);\n            }\n            else {\n                _grid.updateColumnHeader(_options.columnId, \"<input type='checkbox'>\", _options.toolTip);\n            }\n        }\n        function handleKeyDown(e, args) {\n            if (e.which == 32) {\n                if (_grid.getColumns()[args.cell].id === _options.columnId) {\n                    // if editing, try to commit\n                    if (!_grid.getEditorLock().isActive() || _grid.getEditorLock().commitCurrentEdit()) {\n                        toggleRowSelection(args.row);\n                    }\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                }\n            }\n        }\n        function handleClick(e, args) {\n            // clicking on a row select checkbox\n            if (_grid.getColumns()[args.cell].id === _options.columnId && $(e.target).is(\":checkbox\")) {\n                // if editing, try to commit\n                if (_grid.getEditorLock().isActive() && !_grid.getEditorLock().commitCurrentEdit()) {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    return;\n                }\n                toggleRowSelection(args.row);\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n        function toggleRowSelection(row) {\n            if (_selectedRowsLookup[row]) {\n                _grid.setSelectedRows($.grep(_grid.getSelectedRows(), function (n) {\n                    return n != row;\n                }));\n            }\n            else {\n                _grid.setSelectedRows(_grid.getSelectedRows().concat(row));\n            }\n        }\n        function selectRows(rowArray) {\n            var i, l = rowArray.length, addRows = [];\n            for (i = 0; i < l; i++) {\n                if (!_selectedRowsLookup[rowArray[i]]) {\n                    addRows[addRows.length] = rowArray[i];\n                }\n            }\n            _grid.setSelectedRows(_grid.getSelectedRows().concat(addRows));\n        }\n        function deSelectRows(rowArray) {\n            var i, l = rowArray.length, removeRows = [];\n            for (i = 0; i < l; i++) {\n                if (_selectedRowsLookup[rowArray[i]]) {\n                    removeRows[removeRows.length] = rowArray[i];\n                }\n            }\n            _grid.setSelectedRows($.grep(_grid.getSelectedRows(), function (n) {\n                return removeRows.indexOf(n) < 0;\n            }));\n        }\n        function handleHeaderClick(e, args) {\n            if (args.column.id == _options.columnId && $(e.target).is(\":checkbox\")) {\n                // if editing, try to commit\n                if (_grid.getEditorLock().isActive() && !_grid.getEditorLock().commitCurrentEdit()) {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    return;\n                }\n                if ($(e.target).is(\":checked\")) {\n                    var rows = [];\n                    for (var i = 0; i < _grid.getDataLength(); i++) {\n                        rows.push(i);\n                    }\n                    _grid.setSelectedRows(rows);\n                }\n                else {\n                    _grid.setSelectedRows([]);\n                }\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n            }\n        }\n        function getColumnDefinition() {\n            return {\n                id: _options.columnId,\n                name: \"<input type='checkbox'>\",\n                toolTip: _options.toolTip,\n                field: \"sel\",\n                width: _options.width,\n                resizable: false,\n                sortable: false,\n                cssClass: _options.cssClass,\n                formatter: checkboxSelectionFormatter\n            };\n        }\n        function checkboxSelectionFormatter(row, cell, value, columnDef, dataContext) {\n            if (dataContext) {\n                return _selectedRowsLookup[row]\n                    ? \"<input type='checkbox' checked='checked'>\"\n                    : \"<input type='checkbox'>\";\n            }\n            return null;\n        }\n        $.extend(this, {\n            \"init\": init,\n            \"destroy\": destroy,\n            \"deSelectRows\": deSelectRows,\n            \"selectRows\": selectRows,\n            \"getColumnDefinition\": getColumnDefinition\n        });\n    }\n    module.exports = {\n        \"CheckboxSelectColumn\": CheckboxSelectColumn\n    };\n}\n","/* slickgrid/plugins/slick.rowselectionmodel */ function _(require, module, exports) {\n    var $ = require(445) /* ../slick.jquery */;\n    var Slick = require(443) /* ../slick.core */;\n    function RowSelectionModel(options) {\n        var _grid;\n        var _ranges = [];\n        var _self = this;\n        var _handler = new Slick.EventHandler();\n        var _inHandler;\n        var _options;\n        var _defaults = {\n            selectActiveRow: true\n        };\n        function init(grid) {\n            _options = $.extend(true, {}, _defaults, options);\n            _grid = grid;\n            _handler.subscribe(_grid.onActiveCellChanged, wrapHandler(handleActiveCellChange));\n            _handler.subscribe(_grid.onKeyDown, wrapHandler(handleKeyDown));\n            _handler.subscribe(_grid.onClick, wrapHandler(handleClick));\n        }\n        function destroy() {\n            _handler.unsubscribeAll();\n        }\n        function wrapHandler(handler) {\n            return function () {\n                if (!_inHandler) {\n                    _inHandler = true;\n                    handler.apply(this, arguments);\n                    _inHandler = false;\n                }\n            };\n        }\n        function rangesToRows(ranges) {\n            var rows = [];\n            for (var i = 0; i < ranges.length; i++) {\n                for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n                    rows.push(j);\n                }\n            }\n            return rows;\n        }\n        function rowsToRanges(rows) {\n            var ranges = [];\n            var lastCell = _grid.getColumns().length - 1;\n            for (var i = 0; i < rows.length; i++) {\n                ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n            }\n            return ranges;\n        }\n        function getRowsRange(from, to) {\n            var i, rows = [];\n            for (i = from; i <= to; i++) {\n                rows.push(i);\n            }\n            for (i = to; i < from; i++) {\n                rows.push(i);\n            }\n            return rows;\n        }\n        function getSelectedRows() {\n            return rangesToRows(_ranges);\n        }\n        function setSelectedRows(rows) {\n            setSelectedRanges(rowsToRanges(rows));\n        }\n        function setSelectedRanges(ranges) {\n            // simle check for: empty selection didn't change, prevent firing onSelectedRangesChanged\n            if ((!_ranges || _ranges.length === 0) && (!ranges || ranges.length === 0)) {\n                return;\n            }\n            _ranges = ranges;\n            _self.onSelectedRangesChanged.notify(_ranges);\n        }\n        function getSelectedRanges() {\n            return _ranges;\n        }\n        function handleActiveCellChange(e, data) {\n            if (_options.selectActiveRow && data.row != null) {\n                setSelectedRanges([new Slick.Range(data.row, 0, data.row, _grid.getColumns().length - 1)]);\n            }\n        }\n        function handleKeyDown(e) {\n            var activeRow = _grid.getActiveCell();\n            if (activeRow && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && (e.which == 38 || e.which == 40)) {\n                var selectedRows = getSelectedRows();\n                selectedRows.sort(function (x, y) {\n                    return x - y;\n                });\n                if (!selectedRows.length) {\n                    selectedRows = [activeRow.row];\n                }\n                var top = selectedRows[0];\n                var bottom = selectedRows[selectedRows.length - 1];\n                var active;\n                if (e.which == 40) {\n                    active = activeRow.row < bottom || top == bottom ? ++bottom : ++top;\n                }\n                else {\n                    active = activeRow.row < bottom ? --bottom : --top;\n                }\n                if (active >= 0 && active < _grid.getDataLength()) {\n                    _grid.scrollRowIntoView(active);\n                    var tempRanges = rowsToRanges(getRowsRange(top, bottom));\n                    setSelectedRanges(tempRanges);\n                }\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n        function handleClick(e) {\n            var cell = _grid.getCellFromEvent(e);\n            if (!cell || !_grid.canCellBeActive(cell.row, cell.cell)) {\n                return false;\n            }\n            if (!_grid.getOptions().multiSelect || (!e.ctrlKey && !e.shiftKey && !e.metaKey)) {\n                return false;\n            }\n            var selection = rangesToRows(_ranges);\n            var idx = $.inArray(cell.row, selection);\n            if (idx === -1 && (e.ctrlKey || e.metaKey)) {\n                selection.push(cell.row);\n                _grid.setActiveCell(cell.row, cell.cell);\n            }\n            else if (idx !== -1 && (e.ctrlKey || e.metaKey)) {\n                selection = $.grep(selection, function (o, i) {\n                    return (o !== cell.row);\n                });\n                _grid.setActiveCell(cell.row, cell.cell);\n            }\n            else if (selection.length && e.shiftKey) {\n                var last = selection.pop();\n                var from = Math.min(cell.row, last);\n                var to = Math.max(cell.row, last);\n                selection = [];\n                for (var i = from; i <= to; i++) {\n                    if (i !== last) {\n                        selection.push(i);\n                    }\n                }\n                selection.push(last);\n                _grid.setActiveCell(cell.row, cell.cell);\n            }\n            var tempRanges = rowsToRanges(selection);\n            setSelectedRanges(tempRanges);\n            e.stopImmediatePropagation();\n            return true;\n        }\n        $.extend(this, {\n            \"getSelectedRows\": getSelectedRows,\n            \"setSelectedRows\": setSelectedRows,\n            \"getSelectedRanges\": getSelectedRanges,\n            \"setSelectedRanges\": setSelectedRanges,\n            \"init\": init,\n            \"destroy\": destroy,\n            \"onSelectedRangesChanged\": new Slick.Event()\n        });\n    }\n    module.exports = {\n        \"RowSelectionModel\": RowSelectionModel\n    };\n}\n","/* slickgrid/slick.core */ function _(require, module, exports) {\n    /***\n     * Contains core SlickGrid classes.\n     * @module Core\n     * @namespace Slick\n     */\n    /***\n     * An event object for passing data to event handlers and letting them control propagation.\n     * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n     * @class EventData\n     * @constructor\n     */\n    function EventData() {\n        var isPropagationStopped = false;\n        var isImmediatePropagationStopped = false;\n        /***\n         * Stops event from propagating up the DOM tree.\n         * @method stopPropagation\n         */\n        this.stopPropagation = function () {\n            isPropagationStopped = true;\n        };\n        /***\n         * Returns whether stopPropagation was called on this event object.\n         * @method isPropagationStopped\n         * @return {Boolean}\n         */\n        this.isPropagationStopped = function () {\n            return isPropagationStopped;\n        };\n        /***\n         * Prevents the rest of the handlers from being executed.\n         * @method stopImmediatePropagation\n         */\n        this.stopImmediatePropagation = function () {\n            isImmediatePropagationStopped = true;\n        };\n        /***\n         * Returns whether stopImmediatePropagation was called on this event object.\\\n         * @method isImmediatePropagationStopped\n         * @return {Boolean}\n         */\n        this.isImmediatePropagationStopped = function () {\n            return isImmediatePropagationStopped;\n        };\n    }\n    /***\n     * A simple publisher-subscriber implementation.\n     * @class Event\n     * @constructor\n     */\n    function Event() {\n        var handlers = [];\n        /***\n         * Adds an event handler to be called when the event is fired.\n         * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n         * object the event was fired with.<p>\n         * @method subscribe\n         * @param fn {Function} Event handler.\n         */\n        this.subscribe = function (fn) {\n            handlers.push(fn);\n        };\n        /***\n         * Removes an event handler added with <code>subscribe(fn)</code>.\n         * @method unsubscribe\n         * @param fn {Function} Event handler to be removed.\n         */\n        this.unsubscribe = function (fn) {\n            for (var i = handlers.length - 1; i >= 0; i--) {\n                if (handlers[i] === fn) {\n                    handlers.splice(i, 1);\n                }\n            }\n        };\n        /***\n         * Fires an event notifying all subscribers.\n         * @method notify\n         * @param args {Object} Additional data object to be passed to all handlers.\n         * @param e {EventData}\n         *      Optional.\n         *      An <code>EventData</code> object to be passed to all handlers.\n         *      For DOM events, an existing W3C/jQuery event object can be passed in.\n         * @param scope {Object}\n         *      Optional.\n         *      The scope (\"this\") within which the handler will be executed.\n         *      If not specified, the scope will be set to the <code>Event</code> instance.\n         */\n        this.notify = function (args, e, scope) {\n            e = e || new EventData();\n            scope = scope || this;\n            var returnValue;\n            for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n                returnValue = handlers[i].call(scope, e, args);\n            }\n            return returnValue;\n        };\n    }\n    function EventHandler() {\n        var handlers = [];\n        this.subscribe = function (event, handler) {\n            handlers.push({\n                event: event,\n                handler: handler\n            });\n            event.subscribe(handler);\n            return this; // allow chaining\n        };\n        this.unsubscribe = function (event, handler) {\n            var i = handlers.length;\n            while (i--) {\n                if (handlers[i].event === event &&\n                    handlers[i].handler === handler) {\n                    handlers.splice(i, 1);\n                    event.unsubscribe(handler);\n                    return;\n                }\n            }\n            return this; // allow chaining\n        };\n        this.unsubscribeAll = function () {\n            var i = handlers.length;\n            while (i--) {\n                handlers[i].event.unsubscribe(handlers[i].handler);\n            }\n            handlers = [];\n            return this; // allow chaining\n        };\n    }\n    /***\n     * A structure containing a range of cells.\n     * @class Range\n     * @constructor\n     * @param fromRow {Integer} Starting row.\n     * @param fromCell {Integer} Starting cell.\n     * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n     * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n     */\n    function Range(fromRow, fromCell, toRow, toCell) {\n        if (toRow === undefined && toCell === undefined) {\n            toRow = fromRow;\n            toCell = fromCell;\n        }\n        /***\n         * @property fromRow\n         * @type {Integer}\n         */\n        this.fromRow = Math.min(fromRow, toRow);\n        /***\n         * @property fromCell\n         * @type {Integer}\n         */\n        this.fromCell = Math.min(fromCell, toCell);\n        /***\n         * @property toRow\n         * @type {Integer}\n         */\n        this.toRow = Math.max(fromRow, toRow);\n        /***\n         * @property toCell\n         * @type {Integer}\n         */\n        this.toCell = Math.max(fromCell, toCell);\n        /***\n         * Returns whether a range represents a single row.\n         * @method isSingleRow\n         * @return {Boolean}\n         */\n        this.isSingleRow = function () {\n            return this.fromRow == this.toRow;\n        };\n        /***\n         * Returns whether a range represents a single cell.\n         * @method isSingleCell\n         * @return {Boolean}\n         */\n        this.isSingleCell = function () {\n            return this.fromRow == this.toRow && this.fromCell == this.toCell;\n        };\n        /***\n         * Returns whether a range contains a given cell.\n         * @method contains\n         * @param row {Integer}\n         * @param cell {Integer}\n         * @return {Boolean}\n         */\n        this.contains = function (row, cell) {\n            return row >= this.fromRow && row <= this.toRow &&\n                cell >= this.fromCell && cell <= this.toCell;\n        };\n        /***\n         * Returns a readable representation of a range.\n         * @method toString\n         * @return {String}\n         */\n        this.toString = function () {\n            if (this.isSingleCell()) {\n                return \"(\" + this.fromRow + \":\" + this.fromCell + \")\";\n            }\n            else {\n                return \"(\" + this.fromRow + \":\" + this.fromCell + \" - \" + this.toRow + \":\" + this.toCell + \")\";\n            }\n        };\n    }\n    /***\n     * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n     * @class NonDataItem\n     * @constructor\n     */\n    function NonDataItem() {\n        this.__nonDataRow = true;\n    }\n    /***\n     * Information about a group of rows.\n     * @class Group\n     * @extends Slick.NonDataItem\n     * @constructor\n     */\n    function Group() {\n        this.__group = true;\n        /**\n         * Grouping level, starting with 0.\n         * @property level\n         * @type {Number}\n         */\n        this.level = 0;\n        /***\n         * Number of rows in the group.\n         * @property count\n         * @type {Integer}\n         */\n        this.count = 0;\n        /***\n         * Grouping value.\n         * @property value\n         * @type {Object}\n         */\n        this.value = null;\n        /***\n         * Formatted display value of the group.\n         * @property title\n         * @type {String}\n         */\n        this.title = null;\n        /***\n         * Whether a group is collapsed.\n         * @property collapsed\n         * @type {Boolean}\n         */\n        this.collapsed = false;\n        /***\n         * Whether a group selection checkbox is checked.\n         * @property selectChecked\n         * @type {Boolean}\n         */\n        this.selectChecked = false;\n        /***\n         * GroupTotals, if any.\n         * @property totals\n         * @type {GroupTotals}\n         */\n        this.totals = null;\n        /**\n         * Rows that are part of the group.\n         * @property rows\n         * @type {Array}\n         */\n        this.rows = [];\n        /**\n         * Sub-groups that are part of the group.\n         * @property groups\n         * @type {Array}\n         */\n        this.groups = null;\n        /**\n         * A unique key used to identify the group.  This key can be used in calls to DataView\n         * collapseGroup() or expandGroup().\n         * @property groupingKey\n         * @type {Object}\n         */\n        this.groupingKey = null;\n    }\n    Group.prototype = new NonDataItem();\n    /***\n     * Compares two Group instances.\n     * @method equals\n     * @return {Boolean}\n     * @param group {Group} Group instance to compare to.\n     */\n    Group.prototype.equals = function (group) {\n        return this.value === group.value &&\n            this.count === group.count &&\n            this.collapsed === group.collapsed &&\n            this.title === group.title;\n    };\n    /***\n     * Information about group totals.\n     * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n     * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n     * formatters during the display.\n     * @class GroupTotals\n     * @extends Slick.NonDataItem\n     * @constructor\n     */\n    function GroupTotals() {\n        this.__groupTotals = true;\n        /***\n         * Parent Group.\n         * @param group\n         * @type {Group}\n         */\n        this.group = null;\n        /***\n         * Whether the totals have been fully initialized / calculated.\n         * Will be set to false for lazy-calculated group totals.\n         * @param initialized\n         * @type {Boolean}\n         */\n        this.initialized = false;\n    }\n    GroupTotals.prototype = new NonDataItem();\n    /***\n     * A locking helper to track the active edit controller and ensure that only a single controller\n     * can be active at a time.  This prevents a whole class of state and validation synchronization\n     * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n     * and attempt a commit or cancel before proceeding.\n     * @class EditorLock\n     * @constructor\n     */\n    function EditorLock() {\n        var activeEditController = null;\n        /***\n         * Returns true if a specified edit controller is active (has the edit lock).\n         * If the parameter is not specified, returns true if any edit controller is active.\n         * @method isActive\n         * @param editController {EditController}\n         * @return {Boolean}\n         */\n        this.isActive = function (editController) {\n            return (editController ? activeEditController === editController : activeEditController !== null);\n        };\n        /***\n         * Sets the specified edit controller as the active edit controller (acquire edit lock).\n         * If another edit controller is already active, and exception will be throw new Error(.\n         * @method activate\n         * @param editController {EditController} edit controller acquiring the lock\n         */\n        this.activate = function (editController) {\n            if (editController === activeEditController) { // already activated?\n                return;\n            }\n            if (activeEditController !== null) {\n                throw new Error(\"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\");\n            }\n            if (!editController.commitCurrentEdit) {\n                throw new Error(\"SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()\");\n            }\n            if (!editController.cancelCurrentEdit) {\n                throw new Error(\"SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()\");\n            }\n            activeEditController = editController;\n        };\n        /***\n         * Unsets the specified edit controller as the active edit controller (release edit lock).\n         * If the specified edit controller is not the active one, an exception will be throw new Error(.\n         * @method deactivate\n         * @param editController {EditController} edit controller releasing the lock\n         */\n        this.deactivate = function (editController) {\n            if (activeEditController !== editController) {\n                throw new Error(\"SlickGrid.EditorLock.deactivate: specified editController is not the currently active one\");\n            }\n            activeEditController = null;\n        };\n        /***\n         * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n         * controller and returns whether the commit attempt was successful (commit may fail due to validation\n         * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n         * and false otherwise.  If no edit controller is active, returns true.\n         * @method commitCurrentEdit\n         * @return {Boolean}\n         */\n        this.commitCurrentEdit = function () {\n            return (activeEditController ? activeEditController.commitCurrentEdit() : true);\n        };\n        /***\n         * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n         * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n         * active, returns true.\n         * @method cancelCurrentEdit\n         * @return {Boolean}\n         */\n        this.cancelCurrentEdit = function cancelCurrentEdit() {\n            return (activeEditController ? activeEditController.cancelCurrentEdit() : true);\n        };\n    }\n    module.exports = {\n        \"Event\": Event,\n        \"EventData\": EventData,\n        \"EventHandler\": EventHandler,\n        \"Range\": Range,\n        \"NonDataRow\": NonDataItem,\n        \"Group\": Group,\n        \"GroupTotals\": GroupTotals,\n        \"EditorLock\": EditorLock,\n        /***\n         * A global singleton editor lock.\n         * @class GlobalEditorLock\n         * @static\n         * @constructor\n         */\n        \"GlobalEditorLock\": new EditorLock(),\n        \"keyCode\": {\n            BACKSPACE: 8,\n            DELETE: 46,\n            DOWN: 40,\n            END: 35,\n            ENTER: 13,\n            ESCAPE: 27,\n            ESC: 27,\n            HOME: 36,\n            INSERT: 45,\n            LEFT: 37,\n            PAGE_DOWN: 34,\n            PAGE_UP: 33,\n            RIGHT: 39,\n            TAB: 9,\n            UP: 38,\n            C: 67,\n            V: 86\n        },\n        \"preClickClassName\": \"slick-edit-preclick\"\n    };\n}\n","/* slickgrid/slick.grid */ function _(require, module, exports) {\n    /**\n     * @license\n     * (c) 2009-2016 Michael Leibman\n     * michael{dot}leibman{at}gmail{dot}com\n     * http://github.com/mleibman/slickgrid\n     *\n     * Distributed under MIT license.\n     * All rights reserved.\n     *\n     * SlickGrid v2.3\n     *\n     * NOTES:\n     *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.\n     *     This increases the speed dramatically, but can only be done safely because there are no event handlers\n     *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()\n     *     and do proper cleanup.\n     */\n    var $ = require(445) /* ./slick.jquery */;\n    var Slick = require(443) /* ./slick.core */;\n    // shared across all grids on the page\n    var scrollbarDimensions;\n    var maxSupportedCssHeight; // browser's breaking point\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    // SlickGrid class implementation (available as Slick.Grid)\n    /**\n     * Creates a new instance of the grid.\n     * @class SlickGrid\n     * @constructor\n     * @param {Node}              container   Container node to create the grid in.\n     * @param {Array,Object}      data        An array of objects for databinding.\n     * @param {Array}             columns     An array of column definitions.\n     * @param {Object}            options     Grid options.\n     **/\n    function SlickGrid(container, data, columns, options) {\n        if (!$.fn.drag) {\n            require(439) /* ./lib/jquery.event.drag-2.3.0 */;\n        }\n        if (!$.fn.drop) {\n            require(440) /* ./lib/jquery.event.drop-2.3.0 */;\n        }\n        // settings\n        var defaults = {\n            explicitInitialization: false,\n            rowHeight: 25,\n            defaultColumnWidth: 80,\n            enableAddRow: false,\n            leaveSpaceForNewRows: false,\n            editable: false,\n            autoEdit: true,\n            enableCellNavigation: true,\n            enableColumnReorder: true,\n            asyncEditorLoading: false,\n            asyncEditorLoadDelay: 100,\n            forceFitColumns: false,\n            enableAsyncPostRender: false,\n            asyncPostRenderDelay: 50,\n            enableAsyncPostRenderCleanup: false,\n            asyncPostRenderCleanupDelay: 40,\n            autoHeight: false,\n            editorLock: Slick.GlobalEditorLock,\n            showHeaderRow: false,\n            headerRowHeight: 25,\n            createFooterRow: false,\n            showFooterRow: false,\n            footerRowHeight: 25,\n            createPreHeaderPanel: false,\n            showPreHeaderPanel: false,\n            preHeaderPanelHeight: 25,\n            showTopPanel: false,\n            topPanelHeight: 25,\n            formatterFactory: null,\n            editorFactory: null,\n            cellFlashingCssClass: \"flashing\",\n            selectedCellCssClass: \"selected\",\n            multiSelect: true,\n            enableTextSelectionOnCells: false,\n            dataItemColumnValueExtractor: null,\n            fullWidthRows: false,\n            multiColumnSort: false,\n            numberedMultiColumnSort: false,\n            tristateMultiColumnSort: false,\n            defaultFormatter: defaultFormatter,\n            forceSyncScrolling: false,\n            addNewRowCssClass: \"new-row\",\n            preserveCopiedSelectionOnPaste: false,\n            showCellSelection: true\n        };\n        var columnDefaults = {\n            name: \"\",\n            resizable: true,\n            sortable: false,\n            minWidth: 30,\n            rerenderOnResize: false,\n            headerCssClass: null,\n            defaultSortAsc: true,\n            focusable: true,\n            selectable: true\n        };\n        // scroller\n        var th; // virtual height\n        var h; // real scrollable height\n        var ph; // page height\n        var n; // number of pages\n        var cj; // \"jumpiness\" coefficient\n        var page = 0; // current page\n        var offset = 0; // current page offset\n        var vScrollDir = 1;\n        // private\n        var initialized = false;\n        var $container;\n        var uid = \"slickgrid_\" + Math.round(1000000 * Math.random());\n        var self = this;\n        var $focusSink, $focusSink2;\n        var $headerScroller;\n        var $headers;\n        var $headerRow, $headerRowScroller, $headerRowSpacer;\n        var $footerRow, $footerRowScroller, $footerRowSpacer;\n        var $preHeaderPanel, $preHeaderPanelScroller, $preHeaderPanelSpacer;\n        var $topPanelScroller;\n        var $topPanel;\n        var $viewport;\n        var $canvas;\n        var $style;\n        var $boundAncestors;\n        var stylesheet, columnCssRulesL, columnCssRulesR;\n        var viewportH, viewportW;\n        var canvasWidth;\n        var viewportHasHScroll, viewportHasVScroll;\n        var headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, // border+padding\n        cellWidthDiff = 0, cellHeightDiff = 0, jQueryNewWidthBehaviour = false;\n        var absoluteColumnMinWidth;\n        var sortIndicatorCssClass = \"slick-sort-indicator\";\n        var tabbingDirection = 1;\n        var activePosX;\n        var activeRow, activeCell;\n        var activeCellNode = null;\n        var currentEditor = null;\n        var serializedEditorValue;\n        var editController;\n        var rowsCache = {};\n        var renderedRows = 0;\n        var numVisibleRows;\n        var prevScrollTop = 0;\n        var scrollTop = 0;\n        var lastRenderedScrollTop = 0;\n        var lastRenderedScrollLeft = 0;\n        var prevScrollLeft = 0;\n        var scrollLeft = 0;\n        var selectionModel;\n        var selectedRows = [];\n        var plugins = [];\n        var cellCssClasses = {};\n        var columnsById = {};\n        var sortColumns = [];\n        var columnPosLeft = [];\n        var columnPosRight = [];\n        var pagingActive = false;\n        var pagingIsLastPage = false;\n        // async call handles\n        var h_editorLoader = null;\n        var h_render = null;\n        var h_postrender = null;\n        var h_postrenderCleanup = null;\n        var postProcessedRows = {};\n        var postProcessToRow = null;\n        var postProcessFromRow = null;\n        var postProcessedCleanupQueue = [];\n        var postProcessgroupId = 0;\n        // perf counters\n        var counter_rows_rendered = 0;\n        var counter_rows_removed = 0;\n        // These two variables work around a bug with inertial scrolling in Webkit/Blink on Mac.\n        // See http://crbug.com/312427.\n        var rowNodeFromLastMouseWheelEvent; // this node must not be deleted while inertial scrolling\n        var zombieRowNodeFromLastMouseWheelEvent; // node that was hidden instead of getting deleted\n        var zombieRowCacheFromLastMouseWheelEvent; // row cache for above node\n        var zombieRowPostProcessedFromLastMouseWheelEvent; // post processing references for above node\n        // store css attributes if display:none is active in container or parent\n        var cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' };\n        var $hiddenParents;\n        var oldProps = [];\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // Initialization\n        function init() {\n            if (container instanceof $) {\n                $container = container;\n            }\n            else {\n                $container = $(container);\n            }\n            if ($container.length < 1) {\n                throw new Error(\"SlickGrid requires a valid container, \" + container + \" does not exist in the DOM.\");\n            }\n            cacheCssForHiddenInit();\n            // calculate these only once and share between grid instances\n            maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();\n            scrollbarDimensions = scrollbarDimensions || measureScrollbar();\n            options = $.extend({}, defaults, options);\n            validateAndEnforceOptions();\n            columnDefaults.width = options.defaultColumnWidth;\n            columnsById = {};\n            for (var i = 0; i < columns.length; i++) {\n                var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n                columnsById[m.id] = i;\n                if (m.minWidth && m.width < m.minWidth) {\n                    m.width = m.minWidth;\n                }\n                if (m.maxWidth && m.width > m.maxWidth) {\n                    m.width = m.maxWidth;\n                }\n            }\n            // validate loaded JavaScript modules against requested options\n            if (options.enableColumnReorder && !$.fn.sortable) {\n                throw new Error(\"SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded\");\n            }\n            editController = {\n                \"commitCurrentEdit\": commitCurrentEdit,\n                \"cancelCurrentEdit\": cancelCurrentEdit\n            };\n            $container\n                .empty()\n                .css(\"overflow\", \"hidden\")\n                .css(\"outline\", 0)\n                .addClass(uid)\n                .addClass(\"ui-widget\");\n            // set up a positioning container if needed\n            if (!/relative|absolute|fixed/.test($container.css(\"position\"))) {\n                $container.css(\"position\", \"relative\");\n            }\n            $focusSink = $(\"<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>\").appendTo($container);\n            if (options.createPreHeaderPanel) {\n                $preHeaderPanelScroller = $(\"<div class='slick-preheader-panel ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n                $preHeaderPanel = $(\"<div />\").appendTo($preHeaderPanelScroller);\n                $preHeaderPanelSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n                    .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n                    .appendTo($preHeaderPanelScroller);\n                if (!options.showPreHeaderPanel) {\n                    $preHeaderPanelScroller.hide();\n                }\n            }\n            $headerScroller = $(\"<div class='slick-header ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n            $headers = $(\"<div class='slick-header-columns' style='left:-1000px' />\").appendTo($headerScroller);\n            $headers.width(getHeadersWidth());\n            $headerRowScroller = $(\"<div class='slick-headerrow ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n            $headerRow = $(\"<div class='slick-headerrow-columns' />\").appendTo($headerRowScroller);\n            $headerRowSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n                .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n                .appendTo($headerRowScroller);\n            $topPanelScroller = $(\"<div class='slick-top-panel-scroller ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n            $topPanel = $(\"<div class='slick-top-panel' style='width:10000px' />\").appendTo($topPanelScroller);\n            if (!options.showTopPanel) {\n                $topPanelScroller.hide();\n            }\n            if (!options.showHeaderRow) {\n                $headerRowScroller.hide();\n            }\n            $viewport = $(\"<div class='slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>\").appendTo($container);\n            $viewport.css(\"overflow-y\", options.autoHeight ? \"hidden\" : \"auto\");\n            $canvas = $(\"<div class='grid-canvas' />\").appendTo($viewport);\n            if (options.createFooterRow) {\n                $footerRowScroller = $(\"<div class='slick-footerrow ui-state-default' style='overflow:hidden;position:relative;' />\").appendTo($container);\n                $footerRow = $(\"<div class='slick-footerrow-columns' />\").appendTo($footerRowScroller);\n                $footerRowSpacer = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n                    .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n                    .appendTo($footerRowScroller);\n                if (!options.showFooterRow) {\n                    $footerRowScroller.hide();\n                }\n            }\n            if (options.numberedMultiColumnSort) {\n                sortIndicatorCssClass = \"slick-sort-indicator-numbered\";\n            }\n            $focusSink2 = $focusSink.clone().appendTo($container);\n            if (!options.explicitInitialization) {\n                finishInitialization();\n            }\n        }\n        function finishInitialization() {\n            if (!initialized) {\n                initialized = true;\n                viewportW = parseFloat($.css($container[0], \"width\", true));\n                // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)\n                // calculate the diff so we can set consistent sizes\n                measureCellPaddingAndBorder();\n                // for usability reasons, all text selection in SlickGrid is disabled\n                // with the exception of input and textarea elements (selection must\n                // be enabled there so that editors work as expected); note that\n                // selection in grid cells (grid body) is already unavailable in\n                // all browsers except IE\n                disableSelection($headers); // disable all text selection in header (including input and textarea)\n                if (!options.enableTextSelectionOnCells) {\n                    // disable text selection in grid cells except in input and textarea elements\n                    // (this is IE-specific, because selectstart event will only fire in IE)\n                    $viewport.on(\"selectstart.ui\", function (event) {\n                        return $(event.target).is(\"input,textarea\");\n                    });\n                }\n                updateColumnCaches();\n                createColumnHeaders();\n                setupColumnSort();\n                createCssRules();\n                resizeCanvas();\n                bindAncestorScrollEvents();\n                $container\n                    .on(\"resize.slickgrid\", resizeCanvas);\n                $viewport\n                    //.on(\"click\", handleClick)\n                    .on(\"scroll\", handleScroll);\n                $headerScroller\n                    .on(\"contextmenu\", handleHeaderContextMenu)\n                    .on(\"click\", handleHeaderClick)\n                    .on(\"mouseenter\", \".slick-header-column\", handleHeaderMouseEnter)\n                    .on(\"mouseleave\", \".slick-header-column\", handleHeaderMouseLeave);\n                $headerRowScroller\n                    .on(\"scroll\", handleHeaderRowScroll);\n                if (options.createFooterRow) {\n                    $footerRowScroller\n                        .on(\"scroll\", handleFooterRowScroll);\n                }\n                if (options.createPreHeaderPanel) {\n                    $preHeaderPanelScroller\n                        .on(\"scroll\", handlePreHeaderPanelScroll);\n                }\n                $focusSink.add($focusSink2)\n                    .on(\"keydown\", handleKeyDown);\n                $canvas\n                    .on(\"keydown\", handleKeyDown)\n                    .on(\"click\", handleClick)\n                    .on(\"dblclick\", handleDblClick)\n                    .on(\"contextmenu\", handleContextMenu)\n                    .on(\"draginit\", handleDragInit)\n                    .on(\"dragstart\", { distance: 3 }, handleDragStart)\n                    .on(\"drag\", handleDrag)\n                    .on(\"dragend\", handleDragEnd)\n                    .on(\"mouseenter\", \".slick-cell\", handleMouseEnter)\n                    .on(\"mouseleave\", \".slick-cell\", handleMouseLeave);\n                // Work around http://crbug.com/312427.\n                if (navigator.userAgent.toLowerCase().match(/webkit/) &&\n                    navigator.userAgent.toLowerCase().match(/macintosh/)) {\n                    $canvas.on(\"mousewheel\", handleMouseWheel);\n                }\n                restoreCssFromHiddenInit();\n            }\n        }\n        function cacheCssForHiddenInit() {\n            // handle display:none on container or container parents\n            $hiddenParents = $container.parents().addBack().not(':visible');\n            $hiddenParents.each(function () {\n                var old = {};\n                for (var name in cssShow) {\n                    old[name] = this.style[name];\n                    this.style[name] = cssShow[name];\n                }\n                oldProps.push(old);\n            });\n        }\n        function restoreCssFromHiddenInit() {\n            // finish handle display:none on container or container parents\n            // - put values back the way they were\n            $hiddenParents.each(function (i) {\n                var old = oldProps[i];\n                for (var name in cssShow) {\n                    this.style[name] = old[name];\n                }\n            });\n        }\n        function registerPlugin(plugin) {\n            plugins.unshift(plugin);\n            plugin.init(self);\n        }\n        function unregisterPlugin(plugin) {\n            for (var i = plugins.length; i >= 0; i--) {\n                if (plugins[i] === plugin) {\n                    if (plugins[i].destroy) {\n                        plugins[i].destroy();\n                    }\n                    plugins.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        function setSelectionModel(model) {\n            if (selectionModel) {\n                selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);\n                if (selectionModel.destroy) {\n                    selectionModel.destroy();\n                }\n            }\n            selectionModel = model;\n            if (selectionModel) {\n                selectionModel.init(self);\n                selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);\n            }\n        }\n        function getSelectionModel() {\n            return selectionModel;\n        }\n        function getCanvasNode() {\n            return $canvas[0];\n        }\n        function measureScrollbar() {\n            var $c = $(\"<div style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>\").appendTo(\"body\");\n            var dim = {\n                width: $c.width() - $c[0].clientWidth,\n                height: $c.height() - $c[0].clientHeight\n            };\n            $c.remove();\n            return dim;\n        }\n        function getColumnTotalWidth(includeScrollbar) {\n            var totalWidth = 0;\n            for (var i = 0, ii = columns.length; i < ii; i++) {\n                var width = columns[i].width;\n                totalWidth += width;\n            }\n            if (includeScrollbar) {\n                totalWidth += scrollbarDimensions.width;\n            }\n            return totalWidth;\n        }\n        function getHeadersWidth() {\n            var headersWidth = getColumnTotalWidth(true);\n            return Math.max(headersWidth, viewportW) + 1000;\n        }\n        function getCanvasWidth() {\n            var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n            var rowWidth = 0;\n            var i = columns.length;\n            while (i--) {\n                rowWidth += columns[i].width;\n            }\n            return options.fullWidthRows ? Math.max(rowWidth, availableWidth) : rowWidth;\n        }\n        function updateCanvasWidth(forceColumnWidthsUpdate) {\n            var oldCanvasWidth = canvasWidth;\n            canvasWidth = getCanvasWidth();\n            if (canvasWidth != oldCanvasWidth) {\n                $canvas.width(canvasWidth);\n                $headerRow.width(canvasWidth);\n                if (options.createFooterRow) {\n                    $footerRow.width(canvasWidth);\n                }\n                if (options.createPreHeaderPanel) {\n                    $preHeaderPanel.width(canvasWidth);\n                }\n                $headers.width(getHeadersWidth());\n                viewportHasHScroll = (canvasWidth > viewportW - scrollbarDimensions.width);\n            }\n            var w = canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0);\n            $headerRowSpacer.width(w);\n            if (options.createFooterRow) {\n                $footerRowSpacer.width(w);\n            }\n            if (options.createPreHeaderPanel) {\n                $preHeaderPanelSpacer.width(w);\n            }\n            if (canvasWidth != oldCanvasWidth || forceColumnWidthsUpdate) {\n                applyColumnWidths();\n            }\n        }\n        function disableSelection($target) {\n            if ($target && $target.jquery) {\n                $target\n                    .attr(\"unselectable\", \"on\")\n                    .css(\"MozUserSelect\", \"none\")\n                    .on(\"selectstart.ui\", function () {\n                    return false;\n                }); // from jquery:ui.core.js 1.7.2\n            }\n        }\n        function getMaxSupportedCssHeight() {\n            var supportedHeight = 1000000;\n            // FF reports the height back but still renders blank after ~6M px\n            var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n            var div = $(\"<div style='display:none' />\").appendTo(document.body);\n            while (true) {\n                var test = supportedHeight * 2;\n                div.css(\"height\", test);\n                if (test > testUpTo || div.height() !== test) {\n                    break;\n                }\n                else {\n                    supportedHeight = test;\n                }\n            }\n            div.remove();\n            return supportedHeight;\n        }\n        function getUID() {\n            return uid;\n        }\n        function getHeaderColumnWidthDiff() {\n            return headerColumnWidthDiff;\n        }\n        function getScrollbarDimensions() {\n            return scrollbarDimensions;\n        }\n        // TODO:  this is static.  need to handle page mutation.\n        function bindAncestorScrollEvents() {\n            var elem = $canvas[0];\n            while ((elem = elem.parentNode) != document.body && elem != null) {\n                // bind to scroll containers only\n                if (elem == $viewport[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {\n                    var $elem = $(elem);\n                    if (!$boundAncestors) {\n                        $boundAncestors = $elem;\n                    }\n                    else {\n                        $boundAncestors = $boundAncestors.add($elem);\n                    }\n                    $elem.on(\"scroll.\" + uid, handleActiveCellPositionChange);\n                }\n            }\n        }\n        function unbindAncestorScrollEvents() {\n            if (!$boundAncestors) {\n                return;\n            }\n            $boundAncestors.off(\"scroll.\" + uid);\n            $boundAncestors = null;\n        }\n        function updateColumnHeader(columnId, title, toolTip) {\n            if (!initialized) {\n                return;\n            }\n            var idx = getColumnIndex(columnId);\n            if (idx == null) {\n                return;\n            }\n            var columnDef = columns[idx];\n            var $header = $headers.children().eq(idx);\n            if ($header) {\n                if (title !== undefined) {\n                    columns[idx].name = title;\n                }\n                if (toolTip !== undefined) {\n                    columns[idx].toolTip = toolTip;\n                }\n                trigger(self.onBeforeHeaderCellDestroy, {\n                    \"node\": $header[0],\n                    \"column\": columnDef,\n                    \"grid\": self\n                });\n                $header\n                    .attr(\"title\", toolTip || \"\")\n                    .children().eq(0).html(title);\n                trigger(self.onHeaderCellRendered, {\n                    \"node\": $header[0],\n                    \"column\": columnDef,\n                    \"grid\": self\n                });\n            }\n        }\n        function getHeaderRow() {\n            return $headerRow[0];\n        }\n        function getFooterRow() {\n            return $footerRow[0];\n        }\n        function getPreHeaderPanel() {\n            return $preHeaderPanel[0];\n        }\n        function getHeaderRowColumn(columnId) {\n            var idx = getColumnIndex(columnId);\n            var $header = $headerRow.children().eq(idx);\n            return $header && $header[0];\n        }\n        function getFooterRowColumn(columnId) {\n            var idx = getColumnIndex(columnId);\n            var $footer = $footerRow.children().eq(idx);\n            return $footer && $footer[0];\n        }\n        function createColumnHeaders() {\n            function onMouseEnter() {\n                $(this).addClass(\"ui-state-hover\");\n            }\n            function onMouseLeave() {\n                $(this).removeClass(\"ui-state-hover\");\n            }\n            $headers.find(\".slick-header-column\")\n                .each(function () {\n                var columnDef = $(this).data(\"column\");\n                if (columnDef) {\n                    trigger(self.onBeforeHeaderCellDestroy, {\n                        \"node\": this,\n                        \"column\": columnDef,\n                        \"grid\": self\n                    });\n                }\n            });\n            $headers.empty();\n            $headers.width(getHeadersWidth());\n            $headerRow.find(\".slick-headerrow-column\")\n                .each(function () {\n                var columnDef = $(this).data(\"column\");\n                if (columnDef) {\n                    trigger(self.onBeforeHeaderRowCellDestroy, {\n                        \"node\": this,\n                        \"column\": columnDef,\n                        \"grid\": self\n                    });\n                }\n            });\n            $headerRow.empty();\n            if (options.createFooterRow) {\n                $footerRow.find(\".slick-footerrow-column\")\n                    .each(function () {\n                    var columnDef = $(this).data(\"column\");\n                    if (columnDef) {\n                        trigger(self.onBeforeFooterRowCellDestroy, {\n                            \"node\": this,\n                            \"column\": columnDef\n                        });\n                    }\n                });\n                $footerRow.empty();\n            }\n            for (var i = 0; i < columns.length; i++) {\n                var m = columns[i];\n                var header = $(\"<div class='ui-state-default slick-header-column' />\")\n                    .html(\"<span class='slick-column-name'>\" + m.name + \"</span>\")\n                    .width(m.width - headerColumnWidthDiff)\n                    .attr(\"id\", \"\" + uid + m.id)\n                    .attr(\"title\", m.toolTip || \"\")\n                    .data(\"column\", m)\n                    .addClass(m.headerCssClass || \"\")\n                    .appendTo($headers);\n                if (options.enableColumnReorder || m.sortable) {\n                    header\n                        .on('mouseenter', onMouseEnter)\n                        .on('mouseleave', onMouseLeave);\n                }\n                if (m.sortable) {\n                    header.addClass(\"slick-header-sortable\");\n                    header.append(\"<span class='\" + sortIndicatorCssClass + \"' />\");\n                }\n                trigger(self.onHeaderCellRendered, {\n                    \"node\": header[0],\n                    \"column\": m,\n                    \"grid\": self\n                });\n                if (options.showHeaderRow) {\n                    var headerRowCell = $(\"<div class='ui-state-default slick-headerrow-column l\" + i + \" r\" + i + \"'></div>\")\n                        .data(\"column\", m)\n                        .appendTo($headerRow);\n                    trigger(self.onHeaderRowCellRendered, {\n                        \"node\": headerRowCell[0],\n                        \"column\": m,\n                        \"grid\": self\n                    });\n                }\n                if (options.createFooterRow && options.showFooterRow) {\n                    var footerRowCell = $(\"<div class='ui-state-default slick-footerrow-column l\" + i + \" r\" + i + \"'></div>\")\n                        .data(\"column\", m)\n                        .appendTo($footerRow);\n                    trigger(self.onFooterRowCellRendered, {\n                        \"node\": footerRowCell[0],\n                        \"column\": m\n                    });\n                }\n            }\n            setSortColumns(sortColumns);\n            setupColumnResize();\n            if (options.enableColumnReorder) {\n                if (typeof options.enableColumnReorder == 'function') {\n                    options.enableColumnReorder(self, $headers, headerColumnWidthDiff, setColumns, setupColumnResize, columns, getColumnIndex, uid, trigger);\n                }\n                else {\n                    setupColumnReorder();\n                }\n            }\n        }\n        function setupColumnSort() {\n            $headers.click(function (e) {\n                // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)\n                e.metaKey = e.metaKey || e.ctrlKey;\n                if ($(e.target).hasClass(\"slick-resizable-handle\")) {\n                    return;\n                }\n                var $col = $(e.target).closest(\".slick-header-column\");\n                if (!$col.length) {\n                    return;\n                }\n                var column = $col.data(\"column\");\n                if (column.sortable) {\n                    if (!getEditorLock().commitCurrentEdit()) {\n                        return;\n                    }\n                    var sortColumn = null;\n                    var i = 0;\n                    for (; i < sortColumns.length; i++) {\n                        if (sortColumns[i].columnId == column.id) {\n                            sortColumn = sortColumns[i];\n                            sortColumn.sortAsc = !sortColumn.sortAsc;\n                            break;\n                        }\n                    }\n                    var hadSortCol = !!sortColumn;\n                    if (options.tristateMultiColumnSort) {\n                        if (!sortColumn) {\n                            sortColumn = { columnId: column.id, sortAsc: column.defaultSortAsc };\n                        }\n                        if (hadSortCol && sortColumn.sortAsc) {\n                            // three state: remove sort rather than go back to ASC\n                            sortColumns.splice(i, 1);\n                            sortColumn = null;\n                        }\n                        if (!options.multiColumnSort) {\n                            sortColumns = [];\n                        }\n                        if (sortColumn && (!hadSortCol || !options.multiColumnSort)) {\n                            sortColumns.push(sortColumn);\n                        }\n                    }\n                    else {\n                        // legacy behaviour\n                        if (e.metaKey && options.multiColumnSort) {\n                            if (sortColumn) {\n                                sortColumns.splice(i, 1);\n                            }\n                        }\n                        else {\n                            if ((!e.shiftKey && !e.metaKey) || !options.multiColumnSort) {\n                                sortColumns = [];\n                            }\n                            if (!sortColumn) {\n                                sortColumn = { columnId: column.id, sortAsc: column.defaultSortAsc };\n                                sortColumns.push(sortColumn);\n                            }\n                            else if (sortColumns.length == 0) {\n                                sortColumns.push(sortColumn);\n                            }\n                        }\n                    }\n                    setSortColumns(sortColumns);\n                    if (sortColumns.length > 0) {\n                        if (!options.multiColumnSort) {\n                            trigger(self.onSort, {\n                                multiColumnSort: false,\n                                sortCol: column,\n                                sortAsc: sortColumns[0].sortAsc,\n                                grid: self\n                            }, e);\n                        }\n                        else {\n                            trigger(self.onSort, {\n                                multiColumnSort: true,\n                                sortCols: $.map(sortColumns, function (col) {\n                                    return { sortCol: columns[getColumnIndex(col.columnId)], sortAsc: col.sortAsc };\n                                }),\n                                grid: self\n                            }, e);\n                        }\n                    }\n                }\n            });\n        }\n        function setupColumnReorder() {\n            $headers.filter(\":ui-sortable\").sortable(\"destroy\");\n            $headers.sortable({\n                containment: \"parent\",\n                distance: 3,\n                axis: \"x\",\n                cursor: \"default\",\n                tolerance: \"intersection\",\n                helper: \"clone\",\n                placeholder: \"slick-sortable-placeholder ui-state-default slick-header-column\",\n                start: function (e, ui) {\n                    ui.placeholder.width(ui.helper.outerWidth() - headerColumnWidthDiff);\n                    $(ui.helper).addClass(\"slick-header-column-active\");\n                },\n                beforeStop: function (e, ui) {\n                    $(ui.helper).removeClass(\"slick-header-column-active\");\n                },\n                stop: function (e) {\n                    if (!getEditorLock().commitCurrentEdit()) {\n                        $(this).sortable(\"cancel\");\n                        return;\n                    }\n                    var reorderedIds = $headers.sortable(\"toArray\");\n                    var reorderedColumns = [];\n                    for (var i = 0; i < reorderedIds.length; i++) {\n                        reorderedColumns.push(columns[getColumnIndex(reorderedIds[i].replace(uid, \"\"))]);\n                    }\n                    setColumns(reorderedColumns);\n                    trigger(self.onColumnsReordered, { grid: self });\n                    e.stopPropagation();\n                    setupColumnResize();\n                }\n            });\n        }\n        function setupColumnResize() {\n            var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;\n            columnElements = $headers.children();\n            columnElements.find(\".slick-resizable-handle\").remove();\n            columnElements.each(function (i, e) {\n                if (i >= columns.length) {\n                    return;\n                }\n                if (columns[i].resizable) {\n                    if (firstResizable === undefined) {\n                        firstResizable = i;\n                    }\n                    lastResizable = i;\n                }\n            });\n            if (firstResizable === undefined) {\n                return;\n            }\n            columnElements.each(function (i, e) {\n                if (i >= columns.length) {\n                    return;\n                }\n                if (i < firstResizable || (options.forceFitColumns && i >= lastResizable)) {\n                    return;\n                }\n                $col = $(e);\n                $(\"<div class='slick-resizable-handle' />\")\n                    .appendTo(e)\n                    .on(\"dragstart\", function (e, dd) {\n                    if (!getEditorLock().commitCurrentEdit()) {\n                        return false;\n                    }\n                    pageX = e.pageX;\n                    $(this).parent().addClass(\"slick-header-column-active\");\n                    var shrinkLeewayOnRight = null, stretchLeewayOnRight = null;\n                    // lock each column's width option to current width\n                    columnElements.each(function (i, e) {\n                        if (i >= columns.length) {\n                            return;\n                        }\n                        columns[i].previousWidth = $(e).outerWidth();\n                    });\n                    if (options.forceFitColumns) {\n                        shrinkLeewayOnRight = 0;\n                        stretchLeewayOnRight = 0;\n                        // colums on right affect maxPageX/minPageX\n                        for (j = i + 1; j < columns.length; j++) {\n                            c = columns[j];\n                            if (c.resizable) {\n                                if (stretchLeewayOnRight !== null) {\n                                    if (c.maxWidth) {\n                                        stretchLeewayOnRight += c.maxWidth - c.previousWidth;\n                                    }\n                                    else {\n                                        stretchLeewayOnRight = null;\n                                    }\n                                }\n                                shrinkLeewayOnRight += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                            }\n                        }\n                    }\n                    var shrinkLeewayOnLeft = 0, stretchLeewayOnLeft = 0;\n                    for (j = 0; j <= i; j++) {\n                        // columns on left only affect minPageX\n                        c = columns[j];\n                        if (c.resizable) {\n                            if (stretchLeewayOnLeft !== null) {\n                                if (c.maxWidth) {\n                                    stretchLeewayOnLeft += c.maxWidth - c.previousWidth;\n                                }\n                                else {\n                                    stretchLeewayOnLeft = null;\n                                }\n                            }\n                            shrinkLeewayOnLeft += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                        }\n                    }\n                    if (shrinkLeewayOnRight === null) {\n                        shrinkLeewayOnRight = 100000;\n                    }\n                    if (shrinkLeewayOnLeft === null) {\n                        shrinkLeewayOnLeft = 100000;\n                    }\n                    if (stretchLeewayOnRight === null) {\n                        stretchLeewayOnRight = 100000;\n                    }\n                    if (stretchLeewayOnLeft === null) {\n                        stretchLeewayOnLeft = 100000;\n                    }\n                    maxPageX = pageX + Math.min(shrinkLeewayOnRight, stretchLeewayOnLeft);\n                    minPageX = pageX - Math.min(shrinkLeewayOnLeft, stretchLeewayOnRight);\n                })\n                    .on(\"drag\", function (e, dd) {\n                    var actualMinWidth, d = Math.min(maxPageX, Math.max(minPageX, e.pageX)) - pageX, x;\n                    if (d < 0) { // shrink column\n                        x = d;\n                        for (j = i; j >= 0; j--) {\n                            c = columns[j];\n                            if (c.resizable) {\n                                actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                                if (x && c.previousWidth + x < actualMinWidth) {\n                                    x += c.previousWidth - actualMinWidth;\n                                    c.width = actualMinWidth;\n                                }\n                                else {\n                                    c.width = c.previousWidth + x;\n                                    x = 0;\n                                }\n                            }\n                        }\n                        if (options.forceFitColumns) {\n                            x = -d;\n                            for (j = i + 1; j < columns.length; j++) {\n                                c = columns[j];\n                                if (c.resizable) {\n                                    if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {\n                                        x -= c.maxWidth - c.previousWidth;\n                                        c.width = c.maxWidth;\n                                    }\n                                    else {\n                                        c.width = c.previousWidth + x;\n                                        x = 0;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else { // stretch column\n                        x = d;\n                        for (j = i; j >= 0; j--) {\n                            c = columns[j];\n                            if (c.resizable) {\n                                if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {\n                                    x -= c.maxWidth - c.previousWidth;\n                                    c.width = c.maxWidth;\n                                }\n                                else {\n                                    c.width = c.previousWidth + x;\n                                    x = 0;\n                                }\n                            }\n                        }\n                        if (options.forceFitColumns) {\n                            x = -d;\n                            for (j = i + 1; j < columns.length; j++) {\n                                c = columns[j];\n                                if (c.resizable) {\n                                    actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);\n                                    if (x && c.previousWidth + x < actualMinWidth) {\n                                        x += c.previousWidth - actualMinWidth;\n                                        c.width = actualMinWidth;\n                                    }\n                                    else {\n                                        c.width = c.previousWidth + x;\n                                        x = 0;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    applyColumnHeaderWidths();\n                    if (options.syncColumnCellResize) {\n                        applyColumnWidths();\n                    }\n                })\n                    .on(\"dragend\", function (e, dd) {\n                    var newWidth;\n                    $(this).parent().removeClass(\"slick-header-column-active\");\n                    for (j = 0; j < columns.length; j++) {\n                        c = columns[j];\n                        newWidth = $(columnElements[j]).outerWidth();\n                        if (c.previousWidth !== newWidth && c.rerenderOnResize) {\n                            invalidateAllRows();\n                        }\n                    }\n                    updateCanvasWidth(true);\n                    render();\n                    trigger(self.onColumnsResized, { grid: self });\n                });\n            });\n        }\n        function getVBoxDelta($el) {\n            var p = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n            var delta = 0;\n            $.each(p, function (n, val) {\n                delta += parseFloat($el.css(val)) || 0;\n            });\n            return delta;\n        }\n        function measureCellPaddingAndBorder() {\n            var el;\n            var h = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"];\n            var v = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n            // jquery prior to version 1.8 handles .width setter/getter as a direct css write/read\n            // jquery 1.8 changed .width to read the true inner element width if box-sizing is set to border-box, and introduced a setter for .outerWidth\n            // so for equivalent functionality, prior to 1.8 use .width, and after use .outerWidth\n            var verArray = $.fn.jquery.split('.');\n            jQueryNewWidthBehaviour = (verArray[0] == 1 && verArray[1] >= 8) || verArray[0] >= 2;\n            el = $(\"<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>\").appendTo($headers);\n            headerColumnWidthDiff = headerColumnHeightDiff = 0;\n            if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n                $.each(h, function (n, val) {\n                    headerColumnWidthDiff += parseFloat(el.css(val)) || 0;\n                });\n                $.each(v, function (n, val) {\n                    headerColumnHeightDiff += parseFloat(el.css(val)) || 0;\n                });\n            }\n            el.remove();\n            var r = $(\"<div class='slick-row' />\").appendTo($canvas);\n            el = $(\"<div class='slick-cell' id='' style='visibility:hidden'>-</div>\").appendTo(r);\n            cellWidthDiff = cellHeightDiff = 0;\n            if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n                $.each(h, function (n, val) {\n                    cellWidthDiff += parseFloat(el.css(val)) || 0;\n                });\n                $.each(v, function (n, val) {\n                    cellHeightDiff += parseFloat(el.css(val)) || 0;\n                });\n            }\n            r.remove();\n            absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);\n        }\n        function createCssRules() {\n            $style = $(\"<style type='text/css' rel='stylesheet' />\").appendTo($(\"head\"));\n            var rowHeight = (options.rowHeight - cellHeightDiff);\n            var rules = [\n                \".\" + uid + \" .slick-header-column { left: 1000px; }\",\n                \".\" + uid + \" .slick-top-panel { height:\" + options.topPanelHeight + \"px; }\",\n                \".\" + uid + \" .slick-preheader-panel { height:\" + options.preHeaderPanelHeight + \"px; }\",\n                \".\" + uid + \" .slick-headerrow-columns { height:\" + options.headerRowHeight + \"px; }\",\n                \".\" + uid + \" .slick-footerrow-columns { height:\" + options.footerRowHeight + \"px; }\",\n                \".\" + uid + \" .slick-cell { height:\" + rowHeight + \"px; }\",\n                \".\" + uid + \" .slick-row { height:\" + options.rowHeight + \"px; }\"\n            ];\n            for (var i = 0; i < columns.length; i++) {\n                rules.push(\".\" + uid + \" .l\" + i + \" { }\");\n                rules.push(\".\" + uid + \" .r\" + i + \" { }\");\n            }\n            if ($style[0].styleSheet) { // IE\n                $style[0].styleSheet.cssText = rules.join(\" \");\n            }\n            else {\n                $style[0].appendChild(document.createTextNode(rules.join(\" \")));\n            }\n        }\n        function getColumnCssRules(idx) {\n            var i;\n            if (!stylesheet) {\n                var sheets = document.styleSheets;\n                for (i = 0; i < sheets.length; i++) {\n                    if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {\n                        stylesheet = sheets[i];\n                        break;\n                    }\n                }\n                if (!stylesheet) {\n                    throw new Error(\"Cannot find stylesheet.\");\n                }\n                // find and cache column CSS rules\n                columnCssRulesL = [];\n                columnCssRulesR = [];\n                var cssRules = (stylesheet.cssRules || stylesheet.rules);\n                var matches, columnIdx;\n                for (i = 0; i < cssRules.length; i++) {\n                    var selector = cssRules[i].selectorText;\n                    if (matches = /\\.l\\d+/.exec(selector)) {\n                        columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n                        columnCssRulesL[columnIdx] = cssRules[i];\n                    }\n                    else if (matches = /\\.r\\d+/.exec(selector)) {\n                        columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n                        columnCssRulesR[columnIdx] = cssRules[i];\n                    }\n                }\n            }\n            return {\n                \"left\": columnCssRulesL[idx],\n                \"right\": columnCssRulesR[idx]\n            };\n        }\n        function removeCssRules() {\n            $style.remove();\n            stylesheet = null;\n        }\n        function destroy() {\n            getEditorLock().cancelCurrentEdit();\n            trigger(self.onBeforeDestroy, { grid: self });\n            var i = plugins.length;\n            while (i--) {\n                unregisterPlugin(plugins[i]);\n            }\n            if (options.enableColumnReorder) {\n                $headers.filter(\":ui-sortable\").sortable(\"destroy\");\n            }\n            unbindAncestorScrollEvents();\n            $container.off(\".slickgrid\");\n            removeCssRules();\n            $canvas.off(\"draginit dragstart dragend drag\");\n            $container.empty().removeClass(uid);\n        }\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // General\n        function trigger(evt, args, e) {\n            e = e || new Slick.EventData();\n            args = args || {};\n            args.grid = self;\n            return evt.notify(args, e, self);\n        }\n        function getEditorLock() {\n            return options.editorLock;\n        }\n        function getEditController() {\n            return editController;\n        }\n        function getColumnIndex(id) {\n            return columnsById[id];\n        }\n        function autosizeColumns() {\n            var i, c, widths = [], shrinkLeeway = 0, total = 0, prevTotal, availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n            for (i = 0; i < columns.length; i++) {\n                c = columns[i];\n                widths.push(c.width);\n                total += c.width;\n                if (c.resizable) {\n                    shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);\n                }\n            }\n            // shrink\n            prevTotal = total;\n            while (total > availWidth && shrinkLeeway) {\n                var shrinkProportion = (total - availWidth) / shrinkLeeway;\n                for (i = 0; i < columns.length && total > availWidth; i++) {\n                    c = columns[i];\n                    var width = widths[i];\n                    if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {\n                        continue;\n                    }\n                    var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);\n                    var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;\n                    shrinkSize = Math.min(shrinkSize, width - absMinWidth);\n                    total -= shrinkSize;\n                    shrinkLeeway -= shrinkSize;\n                    widths[i] -= shrinkSize;\n                }\n                if (prevTotal <= total) { // avoid infinite loop\n                    break;\n                }\n                prevTotal = total;\n            }\n            // grow\n            prevTotal = total;\n            while (total < availWidth) {\n                var growProportion = availWidth / total;\n                for (i = 0; i < columns.length && total < availWidth; i++) {\n                    c = columns[i];\n                    var currentWidth = widths[i];\n                    var growSize;\n                    if (!c.resizable || c.maxWidth <= currentWidth) {\n                        growSize = 0;\n                    }\n                    else {\n                        growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, (c.maxWidth - currentWidth) || 1000000) || 1;\n                    }\n                    total += growSize;\n                    widths[i] += (total <= availWidth ? growSize : 0);\n                }\n                if (prevTotal >= total) { // avoid infinite loop\n                    break;\n                }\n                prevTotal = total;\n            }\n            var reRender = false;\n            for (i = 0; i < columns.length; i++) {\n                if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {\n                    reRender = true;\n                }\n                columns[i].width = widths[i];\n            }\n            applyColumnHeaderWidths();\n            updateCanvasWidth(true);\n            if (reRender) {\n                invalidateAllRows();\n                render();\n            }\n        }\n        function applyColumnHeaderWidths() {\n            if (!initialized) {\n                return;\n            }\n            var h;\n            for (var i = 0, headers = $headers.children(), ii = columns.length; i < ii; i++) {\n                h = $(headers[i]);\n                if (jQueryNewWidthBehaviour) {\n                    if (h.outerWidth() !== columns[i].width) {\n                        h.outerWidth(columns[i].width);\n                    }\n                }\n                else {\n                    if (h.width() !== columns[i].width - headerColumnWidthDiff) {\n                        h.width(columns[i].width - headerColumnWidthDiff);\n                    }\n                }\n            }\n            updateColumnCaches();\n        }\n        function applyColumnWidths() {\n            var x = 0, w, rule;\n            for (var i = 0; i < columns.length; i++) {\n                w = columns[i].width;\n                rule = getColumnCssRules(i);\n                rule.left.style.left = x + \"px\";\n                rule.right.style.right = (canvasWidth - x - w) + \"px\";\n                x += columns[i].width;\n            }\n        }\n        function setSortColumn(columnId, ascending) {\n            setSortColumns([{ columnId: columnId, sortAsc: ascending }]);\n        }\n        function setSortColumns(cols) {\n            sortColumns = cols;\n            var numberCols = options.numberedMultiColumnSort && sortColumns.length > 1;\n            var headerColumnEls = $headers.children();\n            var sortIndicatorEl = headerColumnEls\n                .removeClass(\"slick-header-column-sorted\")\n                .find(\".\" + sortIndicatorCssClass)\n                .removeClass(\"slick-sort-indicator-asc slick-sort-indicator-desc\");\n            if (numberCols) {\n                sortIndicatorEl.text('');\n            }\n            $.each(sortColumns, function (i, col) {\n                if (col.sortAsc == null) {\n                    col.sortAsc = true;\n                }\n                var columnIndex = getColumnIndex(col.columnId);\n                if (columnIndex != null) {\n                    sortIndicatorEl = headerColumnEls.eq(columnIndex)\n                        .addClass(\"slick-header-column-sorted\")\n                        .find(\".\" + sortIndicatorCssClass)\n                        .addClass(col.sortAsc ? \"slick-sort-indicator-asc\" : \"slick-sort-indicator-desc\");\n                    if (numberCols) {\n                        sortIndicatorEl.text(i + 1);\n                    }\n                }\n            });\n        }\n        function getSortColumns() {\n            return sortColumns;\n        }\n        function handleSelectedRangesChanged(e, ranges) {\n            selectedRows = [];\n            var hash = {};\n            for (var i = 0; i < ranges.length; i++) {\n                for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n                    if (!hash[j]) { // prevent duplicates\n                        selectedRows.push(j);\n                        hash[j] = {};\n                    }\n                    for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {\n                        if (canCellBeSelected(j, k)) {\n                            hash[j][columns[k].id] = options.selectedCellCssClass;\n                        }\n                    }\n                }\n            }\n            setCellCssStyles(options.selectedCellCssClass, hash);\n            trigger(self.onSelectedRowsChanged, { rows: getSelectedRows(), grid: self }, e);\n        }\n        function getColumns() {\n            return columns;\n        }\n        function updateColumnCaches() {\n            // Pre-calculate cell boundaries.\n            columnPosLeft = [];\n            columnPosRight = [];\n            var x = 0;\n            for (var i = 0, ii = columns.length; i < ii; i++) {\n                columnPosLeft[i] = x;\n                columnPosRight[i] = x + columns[i].width;\n                x += columns[i].width;\n            }\n        }\n        function setColumns(columnDefinitions) {\n            columns = columnDefinitions;\n            columnsById = {};\n            for (var i = 0; i < columns.length; i++) {\n                var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n                columnsById[m.id] = i;\n                if (m.minWidth && m.width < m.minWidth) {\n                    m.width = m.minWidth;\n                }\n                if (m.maxWidth && m.width > m.maxWidth) {\n                    m.width = m.maxWidth;\n                }\n            }\n            updateColumnCaches();\n            if (initialized) {\n                invalidateAllRows();\n                createColumnHeaders();\n                removeCssRules();\n                createCssRules();\n                resizeCanvas();\n                applyColumnWidths();\n                handleScroll();\n            }\n        }\n        function getOptions() {\n            return options;\n        }\n        function setOptions(args, suppressRender) {\n            if (!getEditorLock().commitCurrentEdit()) {\n                return;\n            }\n            makeActiveCellNormal();\n            if (options.enableAddRow !== args.enableAddRow) {\n                invalidateRow(getDataLength());\n            }\n            options = $.extend(options, args);\n            validateAndEnforceOptions();\n            $viewport.css(\"overflow-y\", options.autoHeight ? \"hidden\" : \"auto\");\n            if (!suppressRender) {\n                render();\n            }\n        }\n        function validateAndEnforceOptions() {\n            if (options.autoHeight) {\n                options.leaveSpaceForNewRows = false;\n            }\n        }\n        function setData(newData, scrollToTop) {\n            data = newData;\n            invalidateAllRows();\n            updateRowCount();\n            if (scrollToTop) {\n                scrollTo(0);\n            }\n        }\n        function getData() {\n            return data;\n        }\n        function getDataLength() {\n            if (data.getLength) {\n                return data.getLength();\n            }\n            else {\n                return data.length;\n            }\n        }\n        function getDataLengthIncludingAddNew() {\n            return getDataLength() + (!options.enableAddRow ? 0\n                : (!pagingActive || pagingIsLastPage ? 1 : 0));\n        }\n        function getDataItem(i) {\n            if (data.getItem) {\n                return data.getItem(i);\n            }\n            else {\n                return data[i];\n            }\n        }\n        function getTopPanel() {\n            return $topPanel[0];\n        }\n        function setTopPanelVisibility(visible) {\n            if (options.showTopPanel != visible) {\n                options.showTopPanel = visible;\n                if (visible) {\n                    $topPanelScroller.slideDown(\"fast\", resizeCanvas);\n                }\n                else {\n                    $topPanelScroller.slideUp(\"fast\", resizeCanvas);\n                }\n            }\n        }\n        function setHeaderRowVisibility(visible) {\n            if (options.showHeaderRow != visible) {\n                options.showHeaderRow = visible;\n                if (visible) {\n                    $headerRowScroller.slideDown(\"fast\", resizeCanvas);\n                }\n                else {\n                    $headerRowScroller.slideUp(\"fast\", resizeCanvas);\n                }\n            }\n        }\n        function setFooterRowVisibility(visible) {\n            if (options.showFooterRow != visible) {\n                options.showFooterRow = visible;\n                if (visible) {\n                    $footerRowScroller.slideDown(\"fast\", resizeCanvas);\n                }\n                else {\n                    $footerRowScroller.slideUp(\"fast\", resizeCanvas);\n                }\n            }\n        }\n        function setPreHeaderPanelVisibility(visible) {\n            if (options.showPreHeaderPanel != visible) {\n                options.showPreHeaderPanel = visible;\n                if (visible) {\n                    $preHeaderPanelScroller.slideDown(\"fast\", resizeCanvas);\n                }\n                else {\n                    $preHeaderPanelScroller.slideUp(\"fast\", resizeCanvas);\n                }\n            }\n        }\n        function getContainerNode() {\n            return $container.get(0);\n        }\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // Rendering / Scrolling\n        function getRowTop(row) {\n            return options.rowHeight * row - offset;\n        }\n        function getRowFromPosition(y) {\n            return Math.floor((y + offset) / options.rowHeight);\n        }\n        function scrollTo(y) {\n            y = Math.max(y, 0);\n            y = Math.min(y, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0));\n            var oldOffset = offset;\n            page = Math.min(n - 1, Math.floor(y / ph));\n            offset = Math.round(page * cj);\n            var newScrollTop = y - offset;\n            if (offset != oldOffset) {\n                var range = getVisibleRange(newScrollTop);\n                cleanupRows(range);\n                updateRowPositions();\n            }\n            if (prevScrollTop != newScrollTop) {\n                vScrollDir = (prevScrollTop + oldOffset < newScrollTop + offset) ? 1 : -1;\n                $viewport[0].scrollTop = (lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop);\n                trigger(self.onViewportChanged, { grid: self });\n            }\n        }\n        function defaultFormatter(row, cell, value, columnDef, dataContext) {\n            if (value == null) {\n                return \"\";\n            }\n            else {\n                return (value + \"\").replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n            }\n        }\n        function getFormatter(row, column) {\n            var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n            // look up by id, then index\n            var columnOverrides = rowMetadata &&\n                rowMetadata.columns &&\n                (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);\n            return (columnOverrides && columnOverrides.formatter) ||\n                (rowMetadata && rowMetadata.formatter) ||\n                column.formatter ||\n                (options.formatterFactory && options.formatterFactory.getFormatter(column)) ||\n                options.defaultFormatter;\n        }\n        function getEditor(row, cell) {\n            var column = columns[cell];\n            var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n            var columnMetadata = rowMetadata && rowMetadata.columns;\n            if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined) {\n                return columnMetadata[column.id].editor;\n            }\n            if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined) {\n                return columnMetadata[cell].editor;\n            }\n            return column.editor || (options.editorFactory && options.editorFactory.getEditor(column));\n        }\n        function getDataItemValueForColumn(item, columnDef) {\n            if (options.dataItemColumnValueExtractor) {\n                return options.dataItemColumnValueExtractor(item, columnDef);\n            }\n            return item[columnDef.field];\n        }\n        function appendRowHtml(stringArray, row, range, dataLength) {\n            var d = getDataItem(row);\n            var dataLoading = row < dataLength && !d;\n            var rowCss = \"slick-row\" +\n                (dataLoading ? \" loading\" : \"\") +\n                (row === activeRow ? \" active\" : \"\") +\n                (row % 2 == 1 ? \" odd\" : \" even\");\n            if (!d) {\n                rowCss += \" \" + options.addNewRowCssClass;\n            }\n            var metadata = data.getItemMetadata && data.getItemMetadata(row);\n            if (metadata && metadata.cssClasses) {\n                rowCss += \" \" + metadata.cssClasses;\n            }\n            stringArray.push(\"<div class='ui-widget-content \" + rowCss + \"' style='top:\" + getRowTop(row) + \"px'>\");\n            var colspan, m;\n            for (var i = 0, ii = columns.length; i < ii; i++) {\n                m = columns[i];\n                colspan = 1;\n                if (metadata && metadata.columns) {\n                    var columnData = metadata.columns[m.id] || metadata.columns[i];\n                    colspan = (columnData && columnData.colspan) || 1;\n                    if (colspan === \"*\") {\n                        colspan = ii - i;\n                    }\n                }\n                // Do not render cells outside of the viewport.\n                if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n                    if (columnPosLeft[i] > range.rightPx) {\n                        // All columns to the right are outside the range.\n                        break;\n                    }\n                    appendCellHtml(stringArray, row, i, colspan, d);\n                }\n                if (colspan > 1) {\n                    i += (colspan - 1);\n                }\n            }\n            stringArray.push(\"</div>\");\n        }\n        function appendCellHtml(stringArray, row, cell, colspan, item) {\n            // stringArray: stringBuilder containing the HTML parts\n            // row, cell: row and column index\n            // colspan: HTML colspan\n            // item: grid data for row\n            var m = columns[cell];\n            var cellCss = \"slick-cell l\" + cell + \" r\" + Math.min(columns.length - 1, cell + colspan - 1) +\n                (m.cssClass ? \" \" + m.cssClass : \"\");\n            if (row === activeRow && cell === activeCell) {\n                cellCss += (\" active\");\n            }\n            // TODO:  merge them together in the setter\n            for (var key in cellCssClasses) {\n                if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {\n                    cellCss += (\" \" + cellCssClasses[key][row][m.id]);\n                }\n            }\n            var value = null;\n            if (item) {\n                value = getDataItemValueForColumn(item, m);\n            }\n            var formatterResult = getFormatter(row, m)(row, cell, value, m, item);\n            // get addl css class names from object type formatter return and from string type return of onBeforeAppendCell\n            var addlCssClasses = trigger(self.onBeforeAppendCell, { row: row, cell: cell, grid: self, value: value, dataContext: item }) || '';\n            addlCssClasses += (formatterResult.addClasses ? (addlCssClasses ? ' ' : '') + formatterResult.addClasses : '');\n            stringArray.push(\"<div class='\" + cellCss + (addlCssClasses ? ' ' + addlCssClasses : '') + \"'>\");\n            // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)\n            if (item) {\n                stringArray.push(typeof formatterResult !== 'object' ? formatterResult : formatterResult.text);\n            }\n            stringArray.push(\"</div>\");\n            rowsCache[row].cellRenderQueue.push(cell);\n            rowsCache[row].cellColSpans[cell] = colspan;\n        }\n        function cleanupRows(rangeToKeep) {\n            for (var i in rowsCache) {\n                if (((i = parseInt(i, 10)) !== activeRow) && (i < rangeToKeep.top || i > rangeToKeep.bottom)) {\n                    removeRowFromCache(i);\n                }\n            }\n            if (options.enableAsyncPostRenderCleanup) {\n                startPostProcessingCleanup();\n            }\n        }\n        function invalidate() {\n            updateRowCount();\n            invalidateAllRows();\n            render();\n        }\n        function invalidateAllRows() {\n            if (currentEditor) {\n                makeActiveCellNormal();\n            }\n            for (var row in rowsCache) {\n                removeRowFromCache(row);\n            }\n            if (options.enableAsyncPostRenderCleanup) {\n                startPostProcessingCleanup();\n            }\n        }\n        function queuePostProcessedRowForCleanup(cacheEntry, postProcessedRow, rowIdx) {\n            postProcessgroupId++;\n            // store and detach node for later async cleanup\n            for (var columnIdx in postProcessedRow) {\n                if (postProcessedRow.hasOwnProperty(columnIdx)) {\n                    postProcessedCleanupQueue.push({\n                        actionType: 'C',\n                        groupId: postProcessgroupId,\n                        node: cacheEntry.cellNodesByColumnIdx[columnIdx | 0],\n                        columnIdx: columnIdx | 0,\n                        rowIdx: rowIdx\n                    });\n                }\n            }\n            postProcessedCleanupQueue.push({\n                actionType: 'R',\n                groupId: postProcessgroupId,\n                node: cacheEntry.rowNode\n            });\n            $(cacheEntry.rowNode).detach();\n        }\n        function queuePostProcessedCellForCleanup(cellnode, columnIdx, rowIdx) {\n            postProcessedCleanupQueue.push({\n                actionType: 'C',\n                groupId: postProcessgroupId,\n                node: cellnode,\n                columnIdx: columnIdx,\n                rowIdx: rowIdx\n            });\n            $(cellnode).detach();\n        }\n        function removeRowFromCache(row) {\n            var cacheEntry = rowsCache[row];\n            if (!cacheEntry) {\n                return;\n            }\n            if (rowNodeFromLastMouseWheelEvent === cacheEntry.rowNode) {\n                cacheEntry.rowNode.style.display = 'none';\n                zombieRowNodeFromLastMouseWheelEvent = rowNodeFromLastMouseWheelEvent;\n                zombieRowCacheFromLastMouseWheelEvent = cacheEntry;\n                zombieRowPostProcessedFromLastMouseWheelEvent = postProcessedRows[row];\n                // ignore post processing cleanup in this case - it will be dealt with later\n            }\n            else {\n                if (options.enableAsyncPostRenderCleanup && postProcessedRows[row]) {\n                    queuePostProcessedRowForCleanup(cacheEntry, postProcessedRows[row], row);\n                }\n                else {\n                    $canvas[0].removeChild(cacheEntry.rowNode);\n                }\n            }\n            delete rowsCache[row];\n            delete postProcessedRows[row];\n            renderedRows--;\n            counter_rows_removed++;\n        }\n        function invalidateRows(rows) {\n            var i, rl;\n            if (!rows || !rows.length) {\n                return;\n            }\n            vScrollDir = 0;\n            rl = rows.length;\n            for (i = 0; i < rl; i++) {\n                if (currentEditor && activeRow === rows[i]) {\n                    makeActiveCellNormal();\n                }\n                if (rowsCache[rows[i]]) {\n                    removeRowFromCache(rows[i]);\n                }\n            }\n            if (options.enableAsyncPostRenderCleanup) {\n                startPostProcessingCleanup();\n            }\n        }\n        function invalidateRow(row) {\n            invalidateRows([row]);\n        }\n        function applyFormatResultToCellNode(formatterResult, cellNode, suppressRemove) {\n            if (typeof formatterResult !== 'object') {\n                cellNode.innerHTML = formatterResult;\n                return;\n            }\n            cellNode.innerHTML = formatterResult.text;\n            if (formatterResult.removeClasses && !suppressRemove) {\n                cellNode.removeClass(formatterResult.removeClasses);\n            }\n            if (formatterResult.addClasses) {\n                cellNode.addClass(formatterResult.addClasses);\n            }\n        }\n        function updateCell(row, cell) {\n            var cellNode = getCellNode(row, cell);\n            if (!cellNode) {\n                return;\n            }\n            var m = columns[cell], d = getDataItem(row);\n            if (currentEditor && activeRow === row && activeCell === cell) {\n                currentEditor.loadValue(d);\n            }\n            else {\n                var formatterResult = d ? getFormatter(row, m)(row, cell, getDataItemValueForColumn(d, m), m, d) : \"\";\n                applyFormatResultToCellNode(formatterResult, cellNode);\n                invalidatePostProcessingResults(row);\n            }\n        }\n        function updateRow(row) {\n            var cacheEntry = rowsCache[row];\n            if (!cacheEntry) {\n                return;\n            }\n            ensureCellNodesInRowsCache(row);\n            var formatterResult, d = getDataItem(row);\n            for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n                if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n                    continue;\n                }\n                columnIdx = columnIdx | 0;\n                var m = columns[columnIdx], node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n                if (row === activeRow && columnIdx === activeCell && currentEditor) {\n                    currentEditor.loadValue(d);\n                }\n                else if (d) {\n                    formatterResult = getFormatter(row, m)(row, columnIdx, getDataItemValueForColumn(d, m), m, d);\n                    applyFormatResultToCellNode(formatterResult, node);\n                }\n                else {\n                    node.innerHTML = \"\";\n                }\n            }\n            invalidatePostProcessingResults(row);\n        }\n        function getViewportHeight() {\n            return parseFloat($.css($container[0], \"height\", true)) -\n                parseFloat($.css($container[0], \"paddingTop\", true)) -\n                parseFloat($.css($container[0], \"paddingBottom\", true)) -\n                parseFloat($.css($headerScroller[0], \"height\")) - getVBoxDelta($headerScroller) -\n                (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) -\n                (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0) -\n                (options.createFooterRow && options.showFooterRow ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0) -\n                (options.createPreHeaderPanel && options.showPreHeaderPanel ? options.preHeaderPanelHeight + getVBoxDelta($preHeaderPanelScroller) : 0);\n        }\n        function resizeCanvas() {\n            if (!initialized) {\n                return;\n            }\n            if (options.autoHeight) {\n                viewportH = options.rowHeight * getDataLengthIncludingAddNew();\n            }\n            else {\n                viewportH = getViewportHeight();\n            }\n            numVisibleRows = Math.ceil(viewportH / options.rowHeight);\n            viewportW = parseFloat($.css($container[0], \"width\", true));\n            if (!options.autoHeight) {\n                $viewport.height(viewportH);\n            }\n            if (options.forceFitColumns) {\n                autosizeColumns();\n            }\n            updateRowCount();\n            handleScroll();\n            // Since the width has changed, force the render() to reevaluate virtually rendered cells.\n            lastRenderedScrollLeft = -1;\n            render();\n        }\n        function updatePagingStatusFromView(pagingInfo) {\n            pagingActive = (pagingInfo.pageSize !== 0);\n            pagingIsLastPage = (pagingInfo.pageNum == pagingInfo.totalPages - 1);\n        }\n        function updateRowCount() {\n            if (!initialized) {\n                return;\n            }\n            var dataLength = getDataLength();\n            var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n            var numberOfRows = dataLengthIncludingAddNew +\n                (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);\n            var oldViewportHasVScroll = viewportHasVScroll;\n            // with autoHeight, we do not need to accommodate the vertical scroll bar\n            viewportHasVScroll = !options.autoHeight && (numberOfRows * options.rowHeight > viewportH);\n            viewportHasHScroll = (canvasWidth > viewportW - scrollbarDimensions.width);\n            makeActiveCellNormal();\n            // remove the rows that are now outside of the data range\n            // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows\n            var r1 = dataLength - 1;\n            for (var i in rowsCache) {\n                if (i > r1) {\n                    removeRowFromCache(i);\n                }\n            }\n            if (options.enableAsyncPostRenderCleanup) {\n                startPostProcessingCleanup();\n            }\n            if (activeCellNode && activeRow > r1) {\n                resetActiveCell();\n            }\n            var oldH = h;\n            th = Math.max(options.rowHeight * numberOfRows, viewportH - scrollbarDimensions.height);\n            if (th < maxSupportedCssHeight) {\n                // just one page\n                h = ph = th;\n                n = 1;\n                cj = 0;\n            }\n            else {\n                // break into pages\n                h = maxSupportedCssHeight;\n                ph = h / 100;\n                n = Math.floor(th / ph);\n                cj = (th - h) / (n - 1);\n            }\n            if (h !== oldH) {\n                $canvas.css(\"height\", h);\n                scrollTop = $viewport[0].scrollTop;\n            }\n            var oldScrollTopInRange = (scrollTop + offset <= th - viewportH);\n            if (th == 0 || scrollTop == 0) {\n                page = offset = 0;\n            }\n            else if (oldScrollTopInRange) {\n                // maintain virtual position\n                scrollTo(scrollTop + offset);\n            }\n            else {\n                // scroll to bottom\n                scrollTo(th - viewportH);\n            }\n            if (h != oldH && options.autoHeight) {\n                resizeCanvas();\n            }\n            if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll) {\n                autosizeColumns();\n            }\n            updateCanvasWidth(false);\n        }\n        function getVisibleRange(viewportTop, viewportLeft) {\n            if (viewportTop == null) {\n                viewportTop = scrollTop;\n            }\n            if (viewportLeft == null) {\n                viewportLeft = scrollLeft;\n            }\n            return {\n                top: getRowFromPosition(viewportTop),\n                bottom: getRowFromPosition(viewportTop + viewportH) + 1,\n                leftPx: viewportLeft,\n                rightPx: viewportLeft + viewportW\n            };\n        }\n        function getRenderedRange(viewportTop, viewportLeft) {\n            var range = getVisibleRange(viewportTop, viewportLeft);\n            var buffer = Math.round(viewportH / options.rowHeight);\n            var minBuffer = 3;\n            if (vScrollDir == -1) {\n                range.top -= buffer;\n                range.bottom += minBuffer;\n            }\n            else if (vScrollDir == 1) {\n                range.top -= minBuffer;\n                range.bottom += buffer;\n            }\n            else {\n                range.top -= minBuffer;\n                range.bottom += minBuffer;\n            }\n            range.top = Math.max(0, range.top);\n            range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);\n            range.leftPx -= viewportW;\n            range.rightPx += viewportW;\n            range.leftPx = Math.max(0, range.leftPx);\n            range.rightPx = Math.min(canvasWidth, range.rightPx);\n            return range;\n        }\n        function ensureCellNodesInRowsCache(row) {\n            var cacheEntry = rowsCache[row];\n            if (cacheEntry) {\n                if (cacheEntry.cellRenderQueue.length) {\n                    var lastChild = cacheEntry.rowNode.lastChild;\n                    while (cacheEntry.cellRenderQueue.length) {\n                        var columnIdx = cacheEntry.cellRenderQueue.pop();\n                        cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild;\n                        lastChild = lastChild.previousSibling;\n                    }\n                }\n            }\n        }\n        function cleanUpCells(range, row) {\n            var totalCellsRemoved = 0;\n            var cacheEntry = rowsCache[row];\n            // Remove cells outside the range.\n            var cellsToRemove = [];\n            for (var i in cacheEntry.cellNodesByColumnIdx) {\n                // I really hate it when people mess with Array.prototype.\n                if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {\n                    continue;\n                }\n                // This is a string, so it needs to be cast back to a number.\n                i = i | 0;\n                var colspan = cacheEntry.cellColSpans[i];\n                if (columnPosLeft[i] > range.rightPx ||\n                    columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx) {\n                    if (!(row == activeRow && i == activeCell)) {\n                        cellsToRemove.push(i);\n                    }\n                }\n            }\n            var cellToRemove, node;\n            postProcessgroupId++;\n            while ((cellToRemove = cellsToRemove.pop()) != null) {\n                node = cacheEntry.cellNodesByColumnIdx[cellToRemove];\n                if (options.enableAsyncPostRenderCleanup && postProcessedRows[row] && postProcessedRows[row][cellToRemove]) {\n                    queuePostProcessedCellForCleanup(node, cellToRemove, row);\n                }\n                else {\n                    cacheEntry.rowNode.removeChild(node);\n                }\n                delete cacheEntry.cellColSpans[cellToRemove];\n                delete cacheEntry.cellNodesByColumnIdx[cellToRemove];\n                if (postProcessedRows[row]) {\n                    delete postProcessedRows[row][cellToRemove];\n                }\n                totalCellsRemoved++;\n            }\n        }\n        function cleanUpAndRenderCells(range) {\n            var cacheEntry;\n            var stringArray = [];\n            var processedRows = [];\n            var cellsAdded;\n            var totalCellsAdded = 0;\n            var colspan;\n            for (var row = range.top, btm = range.bottom; row <= btm; row++) {\n                cacheEntry = rowsCache[row];\n                if (!cacheEntry) {\n                    continue;\n                }\n                // cellRenderQueue populated in renderRows() needs to be cleared first\n                ensureCellNodesInRowsCache(row);\n                cleanUpCells(range, row);\n                // Render missing cells.\n                cellsAdded = 0;\n                var metadata = data.getItemMetadata && data.getItemMetadata(row);\n                metadata = metadata && metadata.columns;\n                var d = getDataItem(row);\n                // TODO:  shorten this loop (index? heuristics? binary search?)\n                for (var i = 0, ii = columns.length; i < ii; i++) {\n                    // Cells to the right are outside the range.\n                    if (columnPosLeft[i] > range.rightPx) {\n                        break;\n                    }\n                    // Already rendered.\n                    if ((colspan = cacheEntry.cellColSpans[i]) != null) {\n                        i += (colspan > 1 ? colspan - 1 : 0);\n                        continue;\n                    }\n                    colspan = 1;\n                    if (metadata) {\n                        var columnData = metadata[columns[i].id] || metadata[i];\n                        colspan = (columnData && columnData.colspan) || 1;\n                        if (colspan === \"*\") {\n                            colspan = ii - i;\n                        }\n                    }\n                    if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n                        appendCellHtml(stringArray, row, i, colspan, d);\n                        cellsAdded++;\n                    }\n                    i += (colspan > 1 ? colspan - 1 : 0);\n                }\n                if (cellsAdded) {\n                    totalCellsAdded += cellsAdded;\n                    processedRows.push(row);\n                }\n            }\n            if (!stringArray.length) {\n                return;\n            }\n            var x = document.createElement(\"div\");\n            x.innerHTML = stringArray.join(\"\");\n            var processedRow;\n            var node;\n            while ((processedRow = processedRows.pop()) != null) {\n                cacheEntry = rowsCache[processedRow];\n                var columnIdx;\n                while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {\n                    node = x.lastChild;\n                    cacheEntry.rowNode.appendChild(node);\n                    cacheEntry.cellNodesByColumnIdx[columnIdx] = node;\n                }\n            }\n        }\n        function renderRows(range) {\n            var parentNode = $canvas[0], stringArray = [], rows = [], needToReselectCell = false, dataLength = getDataLength();\n            for (var i = range.top, ii = range.bottom; i <= ii; i++) {\n                if (rowsCache[i]) {\n                    continue;\n                }\n                renderedRows++;\n                rows.push(i);\n                // Create an entry right away so that appendRowHtml() can\n                // start populatating it.\n                rowsCache[i] = {\n                    \"rowNode\": null,\n                    // ColSpans of rendered cells (by column idx).\n                    // Can also be used for checking whether a cell has been rendered.\n                    \"cellColSpans\": [],\n                    // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().\n                    \"cellNodesByColumnIdx\": [],\n                    // Column indices of cell nodes that have been rendered, but not yet indexed in\n                    // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the\n                    // end of the row.\n                    \"cellRenderQueue\": []\n                };\n                appendRowHtml(stringArray, i, range, dataLength);\n                if (activeCellNode && activeRow === i) {\n                    needToReselectCell = true;\n                }\n                counter_rows_rendered++;\n            }\n            if (!rows.length) {\n                return;\n            }\n            var x = document.createElement(\"div\");\n            x.innerHTML = stringArray.join(\"\");\n            for (var i = 0, ii = rows.length; i < ii; i++) {\n                rowsCache[rows[i]].rowNode = parentNode.appendChild(x.firstChild);\n            }\n            if (needToReselectCell) {\n                activeCellNode = getCellNode(activeRow, activeCell);\n            }\n        }\n        function startPostProcessing() {\n            if (!options.enableAsyncPostRender) {\n                return;\n            }\n            clearTimeout(h_postrender);\n            h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n        }\n        function startPostProcessingCleanup() {\n            if (!options.enableAsyncPostRenderCleanup) {\n                return;\n            }\n            clearTimeout(h_postrenderCleanup);\n            h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay);\n        }\n        function invalidatePostProcessingResults(row) {\n            // change status of columns to be re-rendered\n            for (var columnIdx in postProcessedRows[row]) {\n                if (postProcessedRows[row].hasOwnProperty(columnIdx)) {\n                    postProcessedRows[row][columnIdx] = 'C';\n                }\n            }\n            postProcessFromRow = Math.min(postProcessFromRow, row);\n            postProcessToRow = Math.max(postProcessToRow, row);\n            startPostProcessing();\n        }\n        function updateRowPositions() {\n            for (var row in rowsCache) {\n                rowsCache[row].rowNode.style.top = getRowTop(row) + \"px\";\n            }\n        }\n        function render() {\n            if (!initialized) {\n                return;\n            }\n            var visible = getVisibleRange();\n            var rendered = getRenderedRange();\n            // remove rows no longer in the viewport\n            cleanupRows(rendered);\n            // add new rows & missing cells in existing rows\n            if (lastRenderedScrollLeft != scrollLeft) {\n                cleanUpAndRenderCells(rendered);\n            }\n            // render missing rows\n            renderRows(rendered);\n            postProcessFromRow = visible.top;\n            postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);\n            startPostProcessing();\n            lastRenderedScrollTop = scrollTop;\n            lastRenderedScrollLeft = scrollLeft;\n            h_render = null;\n        }\n        function handleHeaderRowScroll() {\n            var scrollLeft = $headerRowScroller[0].scrollLeft;\n            if (scrollLeft != $viewport[0].scrollLeft) {\n                $viewport[0].scrollLeft = scrollLeft;\n            }\n        }\n        function handleFooterRowScroll() {\n            var scrollLeft = $footerRowScroller[0].scrollLeft;\n            if (scrollLeft != $viewport[0].scrollLeft) {\n                $viewport[0].scrollLeft = scrollLeft;\n            }\n        }\n        function handlePreHeaderPanelScroll() {\n            var scrollLeft = $preHeaderPanelScroller[0].scrollLeft;\n            if (scrollLeft != $viewport[0].scrollLeft) {\n                $viewport[0].scrollLeft = scrollLeft;\n            }\n        }\n        function handleScroll() {\n            scrollTop = $viewport[0].scrollTop;\n            scrollLeft = $viewport[0].scrollLeft;\n            var vScrollDist = Math.abs(scrollTop - prevScrollTop);\n            var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);\n            if (hScrollDist) {\n                prevScrollLeft = scrollLeft;\n                $headerScroller[0].scrollLeft = scrollLeft;\n                $topPanelScroller[0].scrollLeft = scrollLeft;\n                $headerRowScroller[0].scrollLeft = scrollLeft;\n                if (options.createFooterRow) {\n                    $footerRowScroller[0].scrollLeft = scrollLeft;\n                }\n                if (options.createPreHeaderPanel) {\n                    $preHeaderPanelScroller[0].scrollLeft = scrollLeft;\n                }\n            }\n            if (vScrollDist) {\n                vScrollDir = prevScrollTop < scrollTop ? 1 : -1;\n                prevScrollTop = scrollTop;\n                // switch virtual pages if needed\n                if (vScrollDist < viewportH) {\n                    scrollTo(scrollTop + offset);\n                }\n                else {\n                    var oldOffset = offset;\n                    if (h == viewportH) {\n                        page = 0;\n                    }\n                    else {\n                        page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));\n                    }\n                    offset = Math.round(page * cj);\n                    if (oldOffset != offset) {\n                        invalidateAllRows();\n                    }\n                }\n            }\n            if (hScrollDist || vScrollDist) {\n                if (h_render) {\n                    clearTimeout(h_render);\n                }\n                if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 ||\n                    Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {\n                    if (options.forceSyncScrolling || (Math.abs(lastRenderedScrollTop - scrollTop) < viewportH &&\n                        Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW)) {\n                        render();\n                    }\n                    else {\n                        h_render = setTimeout(render, 50);\n                    }\n                    trigger(self.onViewportChanged, { grid: self });\n                }\n            }\n            trigger(self.onScroll, { scrollLeft: scrollLeft, scrollTop: scrollTop, grid: self });\n        }\n        function asyncPostProcessRows() {\n            var dataLength = getDataLength();\n            while (postProcessFromRow <= postProcessToRow) {\n                var row = (vScrollDir >= 0) ? postProcessFromRow++ : postProcessToRow--;\n                var cacheEntry = rowsCache[row];\n                if (!cacheEntry || row >= dataLength) {\n                    continue;\n                }\n                if (!postProcessedRows[row]) {\n                    postProcessedRows[row] = {};\n                }\n                ensureCellNodesInRowsCache(row);\n                for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n                    if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n                        continue;\n                    }\n                    columnIdx = columnIdx | 0;\n                    var m = columns[columnIdx];\n                    var processedStatus = postProcessedRows[row][columnIdx]; // C=cleanup and re-render, R=rendered\n                    if (m.asyncPostRender && processedStatus !== 'R') {\n                        var node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n                        if (node) {\n                            m.asyncPostRender(node, row, getDataItem(row), m, (processedStatus === 'C'));\n                        }\n                        postProcessedRows[row][columnIdx] = 'R';\n                    }\n                }\n                h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n                return;\n            }\n        }\n        function asyncPostProcessCleanupRows() {\n            if (postProcessedCleanupQueue.length > 0) {\n                var groupId = postProcessedCleanupQueue[0].groupId;\n                // loop through all queue members with this groupID\n                while (postProcessedCleanupQueue.length > 0 && postProcessedCleanupQueue[0].groupId == groupId) {\n                    var entry = postProcessedCleanupQueue.shift();\n                    if (entry.actionType == 'R') {\n                        $(entry.node).remove();\n                    }\n                    if (entry.actionType == 'C') {\n                        var column = columns[entry.columnIdx];\n                        if (column.asyncPostRenderCleanup && entry.node) {\n                            // cleanup must also remove element\n                            column.asyncPostRenderCleanup(entry.node, entry.rowIdx, column);\n                        }\n                    }\n                }\n                // call this function again after the specified delay\n                h_postrenderCleanup = setTimeout(asyncPostProcessCleanupRows, options.asyncPostRenderCleanupDelay);\n            }\n        }\n        function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {\n            var node, columnId, addedRowHash, removedRowHash;\n            for (var row in rowsCache) {\n                removedRowHash = removedHash && removedHash[row];\n                addedRowHash = addedHash && addedHash[row];\n                if (removedRowHash) {\n                    for (columnId in removedRowHash) {\n                        if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n                            node = getCellNode(row, getColumnIndex(columnId));\n                            if (node) {\n                                $(node).removeClass(removedRowHash[columnId]);\n                            }\n                        }\n                    }\n                }\n                if (addedRowHash) {\n                    for (columnId in addedRowHash) {\n                        if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n                            node = getCellNode(row, getColumnIndex(columnId));\n                            if (node) {\n                                $(node).addClass(addedRowHash[columnId]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function addCellCssStyles(key, hash) {\n            if (cellCssClasses[key]) {\n                throw new Error(\"addCellCssStyles: cell CSS hash with key '\" + key + \"' already exists.\");\n            }\n            cellCssClasses[key] = hash;\n            updateCellCssStylesOnRenderedRows(hash, null);\n            trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": hash, \"grid\": self });\n        }\n        function removeCellCssStyles(key) {\n            if (!cellCssClasses[key]) {\n                return;\n            }\n            updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);\n            delete cellCssClasses[key];\n            trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": null, \"grid\": self });\n        }\n        function setCellCssStyles(key, hash) {\n            var prevHash = cellCssClasses[key];\n            cellCssClasses[key] = hash;\n            updateCellCssStylesOnRenderedRows(hash, prevHash);\n            trigger(self.onCellCssStylesChanged, { \"key\": key, \"hash\": hash, \"grid\": self });\n        }\n        function getCellCssStyles(key) {\n            return cellCssClasses[key];\n        }\n        function flashCell(row, cell, speed) {\n            speed = speed || 100;\n            if (rowsCache[row]) {\n                var $cell = $(getCellNode(row, cell));\n                var toggleCellClass = function (times) {\n                    if (!times) {\n                        return;\n                    }\n                    setTimeout(function () {\n                        $cell.queue(function () {\n                            $cell.toggleClass(options.cellFlashingCssClass).dequeue();\n                            toggleCellClass(times - 1);\n                        });\n                    }, speed);\n                };\n                toggleCellClass(4);\n            }\n        }\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // Interactivity\n        function handleMouseWheel(e) {\n            var rowNode = $(e.target).closest(\".slick-row\")[0];\n            if (rowNode != rowNodeFromLastMouseWheelEvent) {\n                if (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent != rowNode) {\n                    if (options.enableAsyncPostRenderCleanup && zombieRowPostProcessedFromLastMouseWheelEvent) {\n                        queuePostProcessedRowForCleanup(zombieRowCacheFromLastMouseWheelEvent, zombieRowPostProcessedFromLastMouseWheelEvent);\n                    }\n                    else {\n                        $canvas[0].removeChild(zombieRowNodeFromLastMouseWheelEvent);\n                    }\n                    zombieRowNodeFromLastMouseWheelEvent = null;\n                    zombieRowCacheFromLastMouseWheelEvent = null;\n                    zombieRowPostProcessedFromLastMouseWheelEvent = null;\n                    if (options.enableAsyncPostRenderCleanup) {\n                        startPostProcessingCleanup();\n                    }\n                }\n                rowNodeFromLastMouseWheelEvent = rowNode;\n            }\n        }\n        function handleDragInit(e, dd) {\n            var cell = getCellFromEvent(e);\n            if (!cell || !cellExists(cell.row, cell.cell)) {\n                return false;\n            }\n            var retval = trigger(self.onDragInit, dd, e);\n            if (e.isImmediatePropagationStopped()) {\n                return retval;\n            }\n            // if nobody claims to be handling drag'n'drop by stopping immediate propagation,\n            // cancel out of it\n            return false;\n        }\n        function handleDragStart(e, dd) {\n            var cell = getCellFromEvent(e);\n            if (!cell || !cellExists(cell.row, cell.cell)) {\n                return false;\n            }\n            var retval = trigger(self.onDragStart, dd, e);\n            if (e.isImmediatePropagationStopped()) {\n                return retval;\n            }\n            return false;\n        }\n        function handleDrag(e, dd) {\n            return trigger(self.onDrag, dd, e);\n        }\n        function handleDragEnd(e, dd) {\n            trigger(self.onDragEnd, dd, e);\n        }\n        function handleKeyDown(e) {\n            trigger(self.onKeyDown, { row: activeRow, cell: activeCell, grid: self }, e);\n            var handled = e.isImmediatePropagationStopped();\n            var keyCode = Slick.keyCode;\n            if (!handled) {\n                if (!e.shiftKey && !e.altKey && !e.ctrlKey) {\n                    // editor may specify an array of keys to bubble\n                    if (options.editable && currentEditor && currentEditor.keyCaptureList) {\n                        if (currentEditor.keyCaptureList.indexOf(e.which) > -1) {\n                            return;\n                        }\n                    }\n                    if (e.which == keyCode.ESCAPE) {\n                        if (!getEditorLock().isActive()) {\n                            return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)\n                        }\n                        cancelEditAndSetFocus();\n                    }\n                    else if (e.which == keyCode.PAGE_DOWN) {\n                        navigatePageDown();\n                        handled = true;\n                    }\n                    else if (e.which == keyCode.PAGE_UP) {\n                        navigatePageUp();\n                        handled = true;\n                    }\n                    else if (e.which == keyCode.LEFT) {\n                        handled = navigateLeft();\n                    }\n                    else if (e.which == keyCode.RIGHT) {\n                        handled = navigateRight();\n                    }\n                    else if (e.which == keyCode.UP) {\n                        handled = navigateUp();\n                    }\n                    else if (e.which == keyCode.DOWN) {\n                        handled = navigateDown();\n                    }\n                    else if (e.which == keyCode.TAB) {\n                        handled = navigateNext();\n                    }\n                    else if (e.which == keyCode.ENTER) {\n                        if (options.editable) {\n                            if (currentEditor) {\n                                // adding new row\n                                if (activeRow === getDataLength()) {\n                                    navigateDown();\n                                }\n                                else {\n                                    commitEditAndSetFocus();\n                                }\n                            }\n                            else {\n                                if (getEditorLock().commitCurrentEdit()) {\n                                    makeActiveCellEditable();\n                                }\n                            }\n                        }\n                        handled = true;\n                    }\n                }\n                else if (e.which == keyCode.TAB && e.shiftKey && !e.ctrlKey && !e.altKey) {\n                    handled = navigatePrev();\n                }\n            }\n            if (handled) {\n                // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it\n                e.stopPropagation();\n                e.preventDefault();\n                try {\n                    e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)\n                }\n                // ignore exceptions - setting the original event's keycode throws access denied exception for \"Ctrl\"\n                // (hitting control key only, nothing else), \"Shift\" (maybe others)\n                catch (error) {\n                }\n            }\n        }\n        function handleClick(e) {\n            if (!currentEditor) {\n                // if this click resulted in some cell child node getting focus,\n                // don't steal it back - keyboard events will still bubble up\n                // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.\n                if (e.target != document.activeElement || $(e.target).hasClass(\"slick-cell\")) {\n                    setFocus();\n                }\n            }\n            var cell = getCellFromEvent(e);\n            if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {\n                return;\n            }\n            trigger(self.onClick, { row: cell.row, cell: cell.cell, grid: self }, e);\n            if (e.isImmediatePropagationStopped()) {\n                return;\n            }\n            // this optimisation causes trouble - MLeibman #329\n            //if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {\n            if (canCellBeActive(cell.row, cell.cell)) {\n                if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {\n                    scrollRowIntoView(cell.row, false);\n                    var preClickModeOn = (e.target && e.target.className === Slick.preClickClassName);\n                    setActiveCellInternal(getCellNode(cell.row, cell.cell), null, preClickModeOn);\n                }\n            }\n        }\n        function handleContextMenu(e) {\n            var $cell = $(e.target).closest(\".slick-cell\", $canvas);\n            if ($cell.length === 0) {\n                return;\n            }\n            // are we editing this cell?\n            if (activeCellNode === $cell[0] && currentEditor !== null) {\n                return;\n            }\n            trigger(self.onContextMenu, { grid: self }, e);\n        }\n        function handleDblClick(e) {\n            var cell = getCellFromEvent(e);\n            if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {\n                return;\n            }\n            trigger(self.onDblClick, { row: cell.row, cell: cell.cell, grid: self }, e);\n            if (e.isImmediatePropagationStopped()) {\n                return;\n            }\n            if (options.editable) {\n                gotoCell(cell.row, cell.cell, true);\n            }\n        }\n        function handleHeaderMouseEnter(e) {\n            trigger(self.onHeaderMouseEnter, {\n                \"column\": $(this).data(\"column\"),\n                \"grid\": self\n            }, e);\n        }\n        function handleHeaderMouseLeave(e) {\n            trigger(self.onHeaderMouseLeave, {\n                \"column\": $(this).data(\"column\"),\n                \"grid\": self\n            }, e);\n        }\n        function handleHeaderContextMenu(e) {\n            var $header = $(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n            var column = $header && $header.data(\"column\");\n            trigger(self.onHeaderContextMenu, { column: column, grid: self }, e);\n        }\n        function handleHeaderClick(e) {\n            var $header = $(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n            var column = $header && $header.data(\"column\");\n            if (column) {\n                trigger(self.onHeaderClick, { column: column, grid: self }, e);\n            }\n        }\n        function handleMouseEnter(e) {\n            trigger(self.onMouseEnter, { grid: self }, e);\n        }\n        function handleMouseLeave(e) {\n            trigger(self.onMouseLeave, { grid: self }, e);\n        }\n        function cellExists(row, cell) {\n            return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);\n        }\n        function getCellFromPoint(x, y) {\n            var row = getRowFromPosition(y);\n            var cell = 0;\n            var w = 0;\n            for (var i = 0; i < columns.length && w < x; i++) {\n                w += columns[i].width;\n                cell++;\n            }\n            if (cell < 0) {\n                cell = 0;\n            }\n            return { row: row, cell: cell - 1 };\n        }\n        function getCellFromNode(cellNode) {\n            // read column number from .l<columnNumber> CSS class\n            var cls = /l\\d+/.exec(cellNode.className);\n            if (!cls) {\n                throw new Error(\"getCellFromNode: cannot get cell - \" + cellNode.className);\n            }\n            return parseInt(cls[0].substr(1, cls[0].length - 1), 10);\n        }\n        function getRowFromNode(rowNode) {\n            for (var row in rowsCache) {\n                if (rowsCache[row].rowNode === rowNode) {\n                    return row | 0;\n                }\n            }\n            return null;\n        }\n        function getCellFromEvent(e) {\n            var $cell = $(e.target).closest(\".slick-cell\", $canvas);\n            if (!$cell.length) {\n                return null;\n            }\n            var row = getRowFromNode($cell[0].parentNode);\n            var cell = getCellFromNode($cell[0]);\n            if (row == null || cell == null) {\n                return null;\n            }\n            else {\n                return {\n                    \"row\": row,\n                    \"cell\": cell\n                };\n            }\n        }\n        function getCellNodeBox(row, cell) {\n            if (!cellExists(row, cell)) {\n                return null;\n            }\n            var y1 = getRowTop(row);\n            var y2 = y1 + options.rowHeight - 1;\n            var x1 = 0;\n            for (var i = 0; i < cell; i++) {\n                x1 += columns[i].width;\n            }\n            var x2 = x1 + columns[cell].width;\n            return {\n                top: y1,\n                left: x1,\n                bottom: y2,\n                right: x2\n            };\n        }\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // Cell switching\n        function resetActiveCell() {\n            setActiveCellInternal(null, false);\n        }\n        function setFocus() {\n            if (tabbingDirection == -1) {\n                $focusSink[0].focus();\n            }\n            else {\n                $focusSink2[0].focus();\n            }\n        }\n        function scrollCellIntoView(row, cell, doPaging) {\n            scrollRowIntoView(row, doPaging);\n            var colspan = getColspan(row, cell);\n            internalScrollColumnIntoView(columnPosLeft[cell], columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)]);\n        }\n        function internalScrollColumnIntoView(left, right) {\n            var scrollRight = scrollLeft + viewportW;\n            if (left < scrollLeft) {\n                $viewport.scrollLeft(left);\n                handleScroll();\n                render();\n            }\n            else if (right > scrollRight) {\n                $viewport.scrollLeft(Math.min(left, right - $viewport[0].clientWidth));\n                handleScroll();\n                render();\n            }\n        }\n        function scrollColumnIntoView(cell) {\n            internalScrollColumnIntoView(columnPosLeft[cell], columnPosRight[cell]);\n        }\n        function setActiveCellInternal(newCell, opt_editMode, preClickModeOn, suppressActiveCellChangedEvent) {\n            if (activeCellNode !== null) {\n                makeActiveCellNormal();\n                $(activeCellNode).removeClass(\"active\");\n                if (rowsCache[activeRow]) {\n                    $(rowsCache[activeRow].rowNode).removeClass(\"active\");\n                }\n            }\n            var activeCellChanged = (activeCellNode !== newCell);\n            activeCellNode = newCell;\n            if (activeCellNode != null) {\n                activeRow = getRowFromNode(activeCellNode.parentNode);\n                activeCell = activePosX = getCellFromNode(activeCellNode);\n                if (opt_editMode == null) {\n                    opt_editMode = (activeRow == getDataLength()) || options.autoEdit;\n                }\n                if (options.showCellSelection) {\n                    $(activeCellNode).addClass(\"active\");\n                    $(rowsCache[activeRow].rowNode).addClass(\"active\");\n                }\n                if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {\n                    clearTimeout(h_editorLoader);\n                    if (options.asyncEditorLoading) {\n                        h_editorLoader = setTimeout(function () {\n                            makeActiveCellEditable(undefined, preClickModeOn);\n                        }, options.asyncEditorLoadDelay);\n                    }\n                    else {\n                        makeActiveCellEditable(undefined, preClickModeOn);\n                    }\n                }\n            }\n            else {\n                activeRow = activeCell = null;\n            }\n            // this optimisation causes trouble - MLeibman #329\n            //if (activeCellChanged) {\n            if (!suppressActiveCellChangedEvent) {\n                trigger(self.onActiveCellChanged, getActiveCell());\n            }\n            //}\n        }\n        function clearTextSelection() {\n            if (document.selection && document.selection.empty) {\n                try {\n                    //IE fails here if selected element is not in dom\n                    document.selection.empty();\n                }\n                catch (e) { }\n            }\n            else if (window.getSelection) {\n                var sel = window.getSelection();\n                if (sel && sel.removeAllRanges) {\n                    sel.removeAllRanges();\n                }\n            }\n        }\n        function isCellPotentiallyEditable(row, cell) {\n            var dataLength = getDataLength();\n            // is the data for this row loaded?\n            if (row < dataLength && !getDataItem(row)) {\n                return false;\n            }\n            // are we in the Add New row?  can we create new from this cell?\n            if (columns[cell].cannotTriggerInsert && row >= dataLength) {\n                return false;\n            }\n            // does this cell have an editor?\n            if (!getEditor(row, cell)) {\n                return false;\n            }\n            return true;\n        }\n        function makeActiveCellNormal() {\n            if (!currentEditor) {\n                return;\n            }\n            trigger(self.onBeforeCellEditorDestroy, { editor: currentEditor, grid: self });\n            currentEditor.destroy();\n            currentEditor = null;\n            if (activeCellNode) {\n                var d = getDataItem(activeRow);\n                $(activeCellNode).removeClass(\"editable invalid\");\n                if (d) {\n                    var column = columns[activeCell];\n                    var formatter = getFormatter(activeRow, column);\n                    var formatterResult = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d, self);\n                    applyFormatResultToCellNode(formatterResult, activeCellNode);\n                    invalidatePostProcessingResults(activeRow);\n                }\n            }\n            // if there previously was text selected on a page (such as selected text in the edit cell just removed),\n            // IE can't set focus to anything else correctly\n            if (navigator.userAgent.toLowerCase().match(/msie/)) {\n                clearTextSelection();\n            }\n            getEditorLock().deactivate(editController);\n        }\n        function makeActiveCellEditable(editor, preClickModeOn) {\n            if (!activeCellNode) {\n                return;\n            }\n            if (!options.editable) {\n                throw new Error(\"Grid : makeActiveCellEditable : should never get called when options.editable is false\");\n            }\n            // cancel pending async call if there is one\n            clearTimeout(h_editorLoader);\n            if (!isCellPotentiallyEditable(activeRow, activeCell)) {\n                return;\n            }\n            var columnDef = columns[activeCell];\n            var item = getDataItem(activeRow);\n            if (trigger(self.onBeforeEditCell, { row: activeRow, cell: activeCell, item: item, column: columnDef, grid: self }) === false) {\n                setFocus();\n                return;\n            }\n            getEditorLock().activate(editController);\n            $(activeCellNode).addClass(\"editable\");\n            var useEditor = editor || getEditor(activeRow, activeCell);\n            // don't clear the cell if a custom editor is passed through\n            if (!editor && !useEditor.suppressClearOnEdit) {\n                activeCellNode.innerHTML = \"\";\n            }\n            currentEditor = new useEditor({\n                grid: self,\n                gridPosition: absBox($container[0]),\n                position: absBox(activeCellNode),\n                container: activeCellNode,\n                column: columnDef,\n                item: item || {},\n                commitChanges: commitEditAndSetFocus,\n                cancelChanges: cancelEditAndSetFocus\n            });\n            if (item) {\n                currentEditor.loadValue(item);\n                if (preClickModeOn && currentEditor.preClick) {\n                    currentEditor.preClick();\n                }\n            }\n            serializedEditorValue = currentEditor.serializeValue();\n            if (currentEditor.position) {\n                handleActiveCellPositionChange();\n            }\n        }\n        function commitEditAndSetFocus() {\n            // if the commit fails, it would do so due to a validation error\n            // if so, do not steal the focus from the editor\n            if (getEditorLock().commitCurrentEdit()) {\n                setFocus();\n                if (options.autoEdit) {\n                    navigateDown();\n                }\n            }\n        }\n        function cancelEditAndSetFocus() {\n            if (getEditorLock().cancelCurrentEdit()) {\n                setFocus();\n            }\n        }\n        function absBox(elem) {\n            var box = {\n                top: elem.offsetTop,\n                left: elem.offsetLeft,\n                bottom: 0,\n                right: 0,\n                width: $(elem).outerWidth(),\n                height: $(elem).outerHeight(),\n                visible: true\n            };\n            box.bottom = box.top + box.height;\n            box.right = box.left + box.width;\n            // walk up the tree\n            var offsetParent = elem.offsetParent;\n            while ((elem = elem.parentNode) != document.body) {\n                if (elem == null)\n                    break;\n                if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css(\"overflowY\") != \"visible\") {\n                    box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;\n                }\n                if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css(\"overflowX\") != \"visible\") {\n                    box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;\n                }\n                box.left -= elem.scrollLeft;\n                box.top -= elem.scrollTop;\n                if (elem === offsetParent) {\n                    box.left += elem.offsetLeft;\n                    box.top += elem.offsetTop;\n                    offsetParent = elem.offsetParent;\n                }\n                box.bottom = box.top + box.height;\n                box.right = box.left + box.width;\n            }\n            return box;\n        }\n        function getActiveCellPosition() {\n            return absBox(activeCellNode);\n        }\n        function getGridPosition() {\n            return absBox($container[0]);\n        }\n        function handleActiveCellPositionChange() {\n            if (!activeCellNode) {\n                return;\n            }\n            trigger(self.onActiveCellPositionChanged, { grid: self });\n            if (currentEditor) {\n                var cellBox = getActiveCellPosition();\n                if (currentEditor.show && currentEditor.hide) {\n                    if (!cellBox.visible) {\n                        currentEditor.hide();\n                    }\n                    else {\n                        currentEditor.show();\n                    }\n                }\n                if (currentEditor.position) {\n                    currentEditor.position(cellBox);\n                }\n            }\n        }\n        function getCellEditor() {\n            return currentEditor;\n        }\n        function getActiveCell() {\n            if (!activeCellNode) {\n                return null;\n            }\n            else {\n                return { row: activeRow, cell: activeCell, grid: self };\n            }\n        }\n        function getActiveCellNode() {\n            return activeCellNode;\n        }\n        function scrollRowIntoView(row, doPaging) {\n            var rowAtTop = row * options.rowHeight;\n            var rowAtBottom = (row + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0);\n            // need to page down?\n            if ((row + 1) * options.rowHeight > scrollTop + viewportH + offset) {\n                scrollTo(doPaging ? rowAtTop : rowAtBottom);\n                render();\n            }\n            // or page up?\n            else if (row * options.rowHeight < scrollTop + offset) {\n                scrollTo(doPaging ? rowAtBottom : rowAtTop);\n                render();\n            }\n        }\n        function scrollRowToTop(row) {\n            scrollTo(row * options.rowHeight);\n            render();\n        }\n        function scrollPage(dir) {\n            var deltaRows = dir * numVisibleRows;\n            scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);\n            render();\n            if (options.enableCellNavigation && activeRow != null) {\n                var row = activeRow + deltaRows;\n                var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n                if (row >= dataLengthIncludingAddNew) {\n                    row = dataLengthIncludingAddNew - 1;\n                }\n                if (row < 0) {\n                    row = 0;\n                }\n                var cell = 0, prevCell = null;\n                var prevActivePosX = activePosX;\n                while (cell <= activePosX) {\n                    if (canCellBeActive(row, cell)) {\n                        prevCell = cell;\n                    }\n                    cell += getColspan(row, cell);\n                }\n                if (prevCell !== null) {\n                    setActiveCellInternal(getCellNode(row, prevCell));\n                    activePosX = prevActivePosX;\n                }\n                else {\n                    resetActiveCell();\n                }\n            }\n        }\n        function navigatePageDown() {\n            scrollPage(1);\n        }\n        function navigatePageUp() {\n            scrollPage(-1);\n        }\n        function getColspan(row, cell) {\n            var metadata = data.getItemMetadata && data.getItemMetadata(row);\n            if (!metadata || !metadata.columns) {\n                return 1;\n            }\n            var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];\n            var colspan = (columnData && columnData.colspan);\n            if (colspan === \"*\") {\n                colspan = columns.length - cell;\n            }\n            else {\n                colspan = colspan || 1;\n            }\n            return colspan;\n        }\n        function findFirstFocusableCell(row) {\n            var cell = 0;\n            while (cell < columns.length) {\n                if (canCellBeActive(row, cell)) {\n                    return cell;\n                }\n                cell += getColspan(row, cell);\n            }\n            return null;\n        }\n        function findLastFocusableCell(row) {\n            var cell = 0;\n            var lastFocusableCell = null;\n            while (cell < columns.length) {\n                if (canCellBeActive(row, cell)) {\n                    lastFocusableCell = cell;\n                }\n                cell += getColspan(row, cell);\n            }\n            return lastFocusableCell;\n        }\n        function gotoRight(row, cell, posX) {\n            if (cell >= columns.length) {\n                return null;\n            }\n            do {\n                cell += getColspan(row, cell);\n            } while (cell < columns.length && !canCellBeActive(row, cell));\n            if (cell < columns.length) {\n                return {\n                    \"row\": row,\n                    \"cell\": cell,\n                    \"posX\": cell\n                };\n            }\n            return null;\n        }\n        function gotoLeft(row, cell, posX) {\n            if (cell <= 0) {\n                return null;\n            }\n            var firstFocusableCell = findFirstFocusableCell(row);\n            if (firstFocusableCell === null || firstFocusableCell >= cell) {\n                return null;\n            }\n            var prev = {\n                \"row\": row,\n                \"cell\": firstFocusableCell,\n                \"posX\": firstFocusableCell\n            };\n            var pos;\n            while (true) {\n                pos = gotoRight(prev.row, prev.cell, prev.posX);\n                if (!pos) {\n                    return null;\n                }\n                if (pos.cell >= cell) {\n                    return prev;\n                }\n                prev = pos;\n            }\n        }\n        function gotoDown(row, cell, posX) {\n            var prevCell;\n            var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n            while (true) {\n                if (++row >= dataLengthIncludingAddNew) {\n                    return null;\n                }\n                prevCell = cell = 0;\n                while (cell <= posX) {\n                    prevCell = cell;\n                    cell += getColspan(row, cell);\n                }\n                if (canCellBeActive(row, prevCell)) {\n                    return {\n                        \"row\": row,\n                        \"cell\": prevCell,\n                        \"posX\": posX\n                    };\n                }\n            }\n        }\n        function gotoUp(row, cell, posX) {\n            var prevCell;\n            while (true) {\n                if (--row < 0) {\n                    return null;\n                }\n                prevCell = cell = 0;\n                while (cell <= posX) {\n                    prevCell = cell;\n                    cell += getColspan(row, cell);\n                }\n                if (canCellBeActive(row, prevCell)) {\n                    return {\n                        \"row\": row,\n                        \"cell\": prevCell,\n                        \"posX\": posX\n                    };\n                }\n            }\n        }\n        function gotoNext(row, cell, posX) {\n            if (row == null && cell == null) {\n                row = cell = posX = 0;\n                if (canCellBeActive(row, cell)) {\n                    return {\n                        \"row\": row,\n                        \"cell\": cell,\n                        \"posX\": cell\n                    };\n                }\n            }\n            var pos = gotoRight(row, cell, posX);\n            if (pos) {\n                return pos;\n            }\n            var firstFocusableCell = null;\n            var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n            // if at last row, cycle through columns rather than get stuck in the last one\n            if (row === dataLengthIncludingAddNew - 1) {\n                row--;\n            }\n            while (++row < dataLengthIncludingAddNew) {\n                firstFocusableCell = findFirstFocusableCell(row);\n                if (firstFocusableCell !== null) {\n                    return {\n                        \"row\": row,\n                        \"cell\": firstFocusableCell,\n                        \"posX\": firstFocusableCell\n                    };\n                }\n            }\n            return null;\n        }\n        function gotoPrev(row, cell, posX) {\n            if (row == null && cell == null) {\n                row = getDataLengthIncludingAddNew() - 1;\n                cell = posX = columns.length - 1;\n                if (canCellBeActive(row, cell)) {\n                    return {\n                        \"row\": row,\n                        \"cell\": cell,\n                        \"posX\": cell\n                    };\n                }\n            }\n            var pos;\n            var lastSelectableCell;\n            while (!pos) {\n                pos = gotoLeft(row, cell, posX);\n                if (pos) {\n                    break;\n                }\n                if (--row < 0) {\n                    return null;\n                }\n                cell = 0;\n                lastSelectableCell = findLastFocusableCell(row);\n                if (lastSelectableCell !== null) {\n                    pos = {\n                        \"row\": row,\n                        \"cell\": lastSelectableCell,\n                        \"posX\": lastSelectableCell\n                    };\n                }\n            }\n            return pos;\n        }\n        function navigateRight() {\n            return navigate(\"right\");\n        }\n        function navigateLeft() {\n            return navigate(\"left\");\n        }\n        function navigateDown() {\n            return navigate(\"down\");\n        }\n        function navigateUp() {\n            return navigate(\"up\");\n        }\n        function navigateNext() {\n            return navigate(\"next\");\n        }\n        function navigatePrev() {\n            return navigate(\"prev\");\n        }\n        /**\n         * @param {string} dir Navigation direction.\n         * @return {boolean} Whether navigation resulted in a change of active cell.\n         */\n        function navigate(dir) {\n            if (!options.enableCellNavigation) {\n                return false;\n            }\n            if (!activeCellNode && dir != \"prev\" && dir != \"next\") {\n                return false;\n            }\n            if (!getEditorLock().commitCurrentEdit()) {\n                return true;\n            }\n            setFocus();\n            var tabbingDirections = {\n                \"up\": -1,\n                \"down\": 1,\n                \"left\": -1,\n                \"right\": 1,\n                \"prev\": -1,\n                \"next\": 1\n            };\n            tabbingDirection = tabbingDirections[dir];\n            var stepFunctions = {\n                \"up\": gotoUp,\n                \"down\": gotoDown,\n                \"left\": gotoLeft,\n                \"right\": gotoRight,\n                \"prev\": gotoPrev,\n                \"next\": gotoNext\n            };\n            var stepFn = stepFunctions[dir];\n            var pos = stepFn(activeRow, activeCell, activePosX);\n            if (pos) {\n                var isAddNewRow = (pos.row == getDataLength());\n                scrollCellIntoView(pos.row, pos.cell, !isAddNewRow);\n                setActiveCellInternal(getCellNode(pos.row, pos.cell));\n                activePosX = pos.posX;\n                return true;\n            }\n            else {\n                setActiveCellInternal(getCellNode(activeRow, activeCell));\n                return false;\n            }\n        }\n        function getCellNode(row, cell) {\n            if (rowsCache[row]) {\n                ensureCellNodesInRowsCache(row);\n                return rowsCache[row].cellNodesByColumnIdx[cell];\n            }\n            return null;\n        }\n        function setActiveCell(row, cell, opt_editMode, preClickModeOn, suppressActiveCellChangedEvent) {\n            if (!initialized) {\n                return;\n            }\n            if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n                return;\n            }\n            if (!options.enableCellNavigation) {\n                return;\n            }\n            scrollCellIntoView(row, cell, false);\n            setActiveCellInternal(getCellNode(row, cell), opt_editMode, preClickModeOn, suppressActiveCellChangedEvent);\n        }\n        function canCellBeActive(row, cell) {\n            if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() ||\n                row < 0 || cell >= columns.length || cell < 0) {\n                return false;\n            }\n            var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n            if (rowMetadata && typeof rowMetadata.focusable === \"boolean\") {\n                return rowMetadata.focusable;\n            }\n            var columnMetadata = rowMetadata && rowMetadata.columns;\n            if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === \"boolean\") {\n                return columnMetadata[columns[cell].id].focusable;\n            }\n            if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === \"boolean\") {\n                return columnMetadata[cell].focusable;\n            }\n            return columns[cell].focusable;\n        }\n        function canCellBeSelected(row, cell) {\n            if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n                return false;\n            }\n            var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n            if (rowMetadata && typeof rowMetadata.selectable === \"boolean\") {\n                return rowMetadata.selectable;\n            }\n            var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);\n            if (columnMetadata && typeof columnMetadata.selectable === \"boolean\") {\n                return columnMetadata.selectable;\n            }\n            return columns[cell].selectable;\n        }\n        function gotoCell(row, cell, forceEdit) {\n            if (!initialized) {\n                return;\n            }\n            if (!canCellBeActive(row, cell)) {\n                return;\n            }\n            if (!getEditorLock().commitCurrentEdit()) {\n                return;\n            }\n            scrollCellIntoView(row, cell, false);\n            var newCell = getCellNode(row, cell);\n            // if selecting the 'add new' row, start editing right away\n            setActiveCellInternal(newCell, forceEdit || (row === getDataLength()) || options.autoEdit);\n            // if no editor was created, set the focus back on the grid\n            if (!currentEditor) {\n                setFocus();\n            }\n        }\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // IEditor implementation for the editor lock\n        function commitCurrentEdit() {\n            var item = getDataItem(activeRow);\n            var column = columns[activeCell];\n            if (currentEditor) {\n                if (currentEditor.isValueChanged()) {\n                    var validationResults = currentEditor.validate();\n                    if (validationResults.valid) {\n                        if (activeRow < getDataLength()) {\n                            var editCommand = {\n                                row: activeRow,\n                                cell: activeCell,\n                                editor: currentEditor,\n                                serializedValue: currentEditor.serializeValue(),\n                                prevSerializedValue: serializedEditorValue,\n                                execute: function () {\n                                    this.editor.applyValue(item, this.serializedValue);\n                                    updateRow(this.row);\n                                    trigger(self.onCellChange, {\n                                        row: activeRow,\n                                        cell: activeCell,\n                                        item: item,\n                                        grid: self\n                                    });\n                                },\n                                undo: function () {\n                                    this.editor.applyValue(item, this.prevSerializedValue);\n                                    updateRow(this.row);\n                                    trigger(self.onCellChange, {\n                                        row: activeRow,\n                                        cell: activeCell,\n                                        item: item,\n                                        grid: self\n                                    });\n                                }\n                            };\n                            if (options.editCommandHandler) {\n                                makeActiveCellNormal();\n                                options.editCommandHandler(item, column, editCommand);\n                            }\n                            else {\n                                editCommand.execute();\n                                makeActiveCellNormal();\n                            }\n                        }\n                        else {\n                            var newItem = {};\n                            currentEditor.applyValue(newItem, currentEditor.serializeValue());\n                            makeActiveCellNormal();\n                            trigger(self.onAddNewRow, { item: newItem, column: column, grid: self });\n                        }\n                        // check whether the lock has been re-acquired by event handlers\n                        return !getEditorLock().isActive();\n                    }\n                    else {\n                        // Re-add the CSS class to trigger transitions, if any.\n                        $(activeCellNode).removeClass(\"invalid\");\n                        $(activeCellNode).width(); // force layout\n                        $(activeCellNode).addClass(\"invalid\");\n                        trigger(self.onValidationError, {\n                            editor: currentEditor,\n                            cellNode: activeCellNode,\n                            validationResults: validationResults,\n                            row: activeRow,\n                            cell: activeCell,\n                            column: column,\n                            grid: self\n                        });\n                        currentEditor.focus();\n                        return false;\n                    }\n                }\n                makeActiveCellNormal();\n            }\n            return true;\n        }\n        function cancelCurrentEdit() {\n            makeActiveCellNormal();\n            return true;\n        }\n        function rowsToRanges(rows) {\n            var ranges = [];\n            var lastCell = columns.length - 1;\n            for (var i = 0; i < rows.length; i++) {\n                ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n            }\n            return ranges;\n        }\n        function getSelectedRows() {\n            if (!selectionModel) {\n                throw new Error(\"Selection model is not set\");\n            }\n            return selectedRows;\n        }\n        function setSelectedRows(rows) {\n            if (!selectionModel) {\n                throw new Error(\"Selection model is not set\");\n            }\n            selectionModel.setSelectedRanges(rowsToRanges(rows));\n        }\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // Debug\n        this.debug = function () {\n            var s = \"\";\n            s += (\"\\n\" + \"counter_rows_rendered:  \" + counter_rows_rendered);\n            s += (\"\\n\" + \"counter_rows_removed:  \" + counter_rows_removed);\n            s += (\"\\n\" + \"renderedRows:  \" + renderedRows);\n            s += (\"\\n\" + \"numVisibleRows:  \" + numVisibleRows);\n            s += (\"\\n\" + \"maxSupportedCssHeight:  \" + maxSupportedCssHeight);\n            s += (\"\\n\" + \"n(umber of pages):  \" + n);\n            s += (\"\\n\" + \"(current) page:  \" + page);\n            s += (\"\\n\" + \"page height (ph):  \" + ph);\n            s += (\"\\n\" + \"vScrollDir:  \" + vScrollDir);\n            alert(s);\n        };\n        // a debug helper to be able to access private members\n        this.eval = function (expr) {\n            return eval(expr);\n        };\n        //////////////////////////////////////////////////////////////////////////////////////////////\n        // Public API\n        $.extend(this, {\n            \"slickGridVersion\": \"2.3.4\",\n            // Events\n            \"onScroll\": new Slick.Event(),\n            \"onSort\": new Slick.Event(),\n            \"onHeaderMouseEnter\": new Slick.Event(),\n            \"onHeaderMouseLeave\": new Slick.Event(),\n            \"onHeaderContextMenu\": new Slick.Event(),\n            \"onHeaderClick\": new Slick.Event(),\n            \"onHeaderCellRendered\": new Slick.Event(),\n            \"onBeforeHeaderCellDestroy\": new Slick.Event(),\n            \"onHeaderRowCellRendered\": new Slick.Event(),\n            \"onFooterRowCellRendered\": new Slick.Event(),\n            \"onBeforeHeaderRowCellDestroy\": new Slick.Event(),\n            \"onBeforeFooterRowCellDestroy\": new Slick.Event(),\n            \"onMouseEnter\": new Slick.Event(),\n            \"onMouseLeave\": new Slick.Event(),\n            \"onClick\": new Slick.Event(),\n            \"onDblClick\": new Slick.Event(),\n            \"onContextMenu\": new Slick.Event(),\n            \"onKeyDown\": new Slick.Event(),\n            \"onAddNewRow\": new Slick.Event(),\n            \"onBeforeAppendCell\": new Slick.Event(),\n            \"onValidationError\": new Slick.Event(),\n            \"onViewportChanged\": new Slick.Event(),\n            \"onColumnsReordered\": new Slick.Event(),\n            \"onColumnsResized\": new Slick.Event(),\n            \"onCellChange\": new Slick.Event(),\n            \"onBeforeEditCell\": new Slick.Event(),\n            \"onBeforeCellEditorDestroy\": new Slick.Event(),\n            \"onBeforeDestroy\": new Slick.Event(),\n            \"onActiveCellChanged\": new Slick.Event(),\n            \"onActiveCellPositionChanged\": new Slick.Event(),\n            \"onDragInit\": new Slick.Event(),\n            \"onDragStart\": new Slick.Event(),\n            \"onDrag\": new Slick.Event(),\n            \"onDragEnd\": new Slick.Event(),\n            \"onSelectedRowsChanged\": new Slick.Event(),\n            \"onCellCssStylesChanged\": new Slick.Event(),\n            // Methods\n            \"registerPlugin\": registerPlugin,\n            \"unregisterPlugin\": unregisterPlugin,\n            \"getColumns\": getColumns,\n            \"setColumns\": setColumns,\n            \"getColumnIndex\": getColumnIndex,\n            \"updateColumnHeader\": updateColumnHeader,\n            \"setSortColumn\": setSortColumn,\n            \"setSortColumns\": setSortColumns,\n            \"getSortColumns\": getSortColumns,\n            \"autosizeColumns\": autosizeColumns,\n            \"getOptions\": getOptions,\n            \"setOptions\": setOptions,\n            \"getData\": getData,\n            \"getDataLength\": getDataLength,\n            \"getDataItem\": getDataItem,\n            \"setData\": setData,\n            \"getSelectionModel\": getSelectionModel,\n            \"setSelectionModel\": setSelectionModel,\n            \"getSelectedRows\": getSelectedRows,\n            \"setSelectedRows\": setSelectedRows,\n            \"getContainerNode\": getContainerNode,\n            \"updatePagingStatusFromView\": updatePagingStatusFromView,\n            \"render\": render,\n            \"invalidate\": invalidate,\n            \"invalidateRow\": invalidateRow,\n            \"invalidateRows\": invalidateRows,\n            \"invalidateAllRows\": invalidateAllRows,\n            \"updateCell\": updateCell,\n            \"updateRow\": updateRow,\n            \"getViewport\": getVisibleRange,\n            \"getRenderedRange\": getRenderedRange,\n            \"resizeCanvas\": resizeCanvas,\n            \"updateRowCount\": updateRowCount,\n            \"scrollRowIntoView\": scrollRowIntoView,\n            \"scrollRowToTop\": scrollRowToTop,\n            \"scrollCellIntoView\": scrollCellIntoView,\n            \"scrollColumnIntoView\": scrollColumnIntoView,\n            \"getCanvasNode\": getCanvasNode,\n            \"getUID\": getUID,\n            \"getHeaderColumnWidthDiff\": getHeaderColumnWidthDiff,\n            \"getScrollbarDimensions\": getScrollbarDimensions,\n            \"getHeadersWidth\": getHeadersWidth,\n            \"getCanvasWidth\": getCanvasWidth,\n            \"focus\": setFocus,\n            \"getCellFromPoint\": getCellFromPoint,\n            \"getCellFromEvent\": getCellFromEvent,\n            \"getActiveCell\": getActiveCell,\n            \"setActiveCell\": setActiveCell,\n            \"getActiveCellNode\": getActiveCellNode,\n            \"getActiveCellPosition\": getActiveCellPosition,\n            \"resetActiveCell\": resetActiveCell,\n            \"editActiveCell\": makeActiveCellEditable,\n            \"getCellEditor\": getCellEditor,\n            \"getCellNode\": getCellNode,\n            \"getCellNodeBox\": getCellNodeBox,\n            \"canCellBeSelected\": canCellBeSelected,\n            \"canCellBeActive\": canCellBeActive,\n            \"navigatePrev\": navigatePrev,\n            \"navigateNext\": navigateNext,\n            \"navigateUp\": navigateUp,\n            \"navigateDown\": navigateDown,\n            \"navigateLeft\": navigateLeft,\n            \"navigateRight\": navigateRight,\n            \"navigatePageUp\": navigatePageUp,\n            \"navigatePageDown\": navigatePageDown,\n            \"gotoCell\": gotoCell,\n            \"getTopPanel\": getTopPanel,\n            \"setTopPanelVisibility\": setTopPanelVisibility,\n            \"getPreHeaderPanel\": getPreHeaderPanel,\n            \"setPreHeaderPanelVisibility\": setPreHeaderPanelVisibility,\n            \"setHeaderRowVisibility\": setHeaderRowVisibility,\n            \"getHeaderRow\": getHeaderRow,\n            \"getHeaderRowColumn\": getHeaderRowColumn,\n            \"setFooterRowVisibility\": setFooterRowVisibility,\n            \"getFooterRow\": getFooterRow,\n            \"getFooterRowColumn\": getFooterRowColumn,\n            \"getGridPosition\": getGridPosition,\n            \"flashCell\": flashCell,\n            \"addCellCssStyles\": addCellCssStyles,\n            \"setCellCssStyles\": setCellCssStyles,\n            \"removeCellCssStyles\": removeCellCssStyles,\n            \"getCellCssStyles\": getCellCssStyles,\n            \"init\": finishInitialization,\n            \"destroy\": destroy,\n            // IEditor implementation\n            \"getEditorLock\": getEditorLock,\n            \"getEditController\": getEditController\n        });\n        init();\n    }\n    module.exports = {\n        Grid: SlickGrid\n    };\n}\n","/* slickgrid/slick.jquery */ function _(require, module, exports) {\n    module.exports = (typeof $ !== \"undefined\") ? $ : require(438) /* jquery */;\n}\n","/* underscore.template/lib/index */ function _(require, module, exports) {\n    var _ = require(447) /* ./underscore.template */;\n    var UnderscoreTemplate = _.template;\n    function Template(text, data, settings) {\n        return UnderscoreTemplate(text, data, settings);\n    }\n    Template._ = _;\n    module.exports = Template;\n    // If we're in the browser,\n    // define it if we're using AMD, otherwise leak a global.\n    if (typeof define === 'function' && define.amd) {\n        define(function () {\n            return Template;\n        });\n    }\n    else if (typeof window !== 'undefined' || typeof navigator !== 'undefined') {\n        window.UnderscoreTemplate = Template;\n    }\n}\n","/* underscore.template/lib/underscore.template */ function _(require, module, exports) {\n    //     Underscore.js 1.5.2\n    //     http://underscorejs.org\n    //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n    //     Underscore may be freely distributed under the MIT license.\n    // Establish the object that gets returned to break out of a loop iteration.\n    var breaker = {};\n    // Save bytes in the minified (but not gzipped) version:\n    var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n    // Create quick reference variables for speed access to core prototypes.\n    var slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;\n    // All **ECMAScript 5** native function implementations that we hope to use\n    // are declared here.\n    var nativeForEach = ArrayProto.forEach, nativeKeys = Object.keys, nativeIsArray = Array.isArray;\n    // Create a safe reference to the Underscore object for use below.\n    var _ = function () { };\n    // Collection Functions\n    // --------------------\n    // The cornerstone, an `each` implementation, aka `forEach`.\n    // Handles objects with the built-in `forEach`, arrays, and raw objects.\n    // Delegates to **ECMAScript 5**'s native `forEach` if available.\n    var each = _.each = _.forEach = function (obj, iterator, context) {\n        if (obj == null)\n            return;\n        if (nativeForEach && obj.forEach === nativeForEach) {\n            obj.forEach(iterator, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, length = obj.length; i < length; i++) {\n                if (iterator.call(context, obj[i], i, obj) === breaker)\n                    return;\n            }\n        }\n        else {\n            var keys = _.keys(obj);\n            for (var i = 0, length = keys.length; i < length; i++) {\n                if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)\n                    return;\n            }\n        }\n    };\n    // Object Functions\n    // ----------------\n    // Retrieve the names of an object's properties.\n    // Delegates to **ECMAScript 5**'s native `Object.keys`\n    _.keys = nativeKeys || function (obj) {\n        if (obj !== Object(obj))\n            throw new TypeError('Invalid object');\n        var keys = [];\n        for (var key in obj)\n            if (_.has(obj, key))\n                keys.push(key);\n        return keys;\n    };\n    // Fill in a given object with default properties.\n    _.defaults = function (obj) {\n        each(slice.call(arguments, 1), function (source) {\n            if (source) {\n                for (var prop in source) {\n                    if (obj[prop] === void 0)\n                        obj[prop] = source[prop];\n                }\n            }\n        });\n        return obj;\n    };\n    // Is a given value an array?\n    // Delegates to ECMA5's native Array.isArray\n    _.isArray = nativeIsArray || function (obj) {\n        return toString.call(obj) === '[object Array]';\n    };\n    // Shortcut function for checking if an object has a given property directly\n    // on itself (in other words, not on a prototype).\n    _.has = function (obj, path) {\n        if (!_.isArray(path)) {\n            return obj != null && hasOwnProperty.call(obj, path);\n        }\n        var length = path.length;\n        for (var i = 0; i < length; i++) {\n            var key = path[i];\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n            obj = obj[key];\n        }\n        return !!length;\n    };\n    // List of HTML entities for escaping.\n    var entityMap = {\n        escape: {\n            '&': '&amp;',\n            '<': '&lt;',\n            '>': '&gt;',\n            '\"': '&quot;',\n            \"'\": '&#x27;'\n        }\n    };\n    // Regexes containing the keys and values listed immediately above.\n    var entityRegexes = {\n        escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g')\n    };\n    // Functions for escaping and unescaping strings to/from HTML interpolation.\n    _.each(['escape'], function (method) {\n        _[method] = function (string) {\n            if (string == null)\n                return '';\n            return ('' + string).replace(entityRegexes[method], function (match) {\n                return entityMap[method][match];\n            });\n        };\n    });\n    // By default, Underscore uses ERB-style template delimiters, change the\n    // following template settings to use alternative delimiters.\n    _.templateSettings = {\n        evaluate: /<%([\\s\\S]+?)%>/g,\n        interpolate: /<%=([\\s\\S]+?)%>/g,\n        escape: /<%-([\\s\\S]+?)%>/g\n    };\n    // When customizing `templateSettings`, if you don't want to define an\n    // interpolation, evaluation or escaping regex, we need one that is\n    // guaranteed not to match.\n    var noMatch = /(.)^/;\n    // Certain characters need to be escaped so that they can be put into a\n    // string literal.\n    var escapes = {\n        \"'\": \"'\",\n        '\\\\': '\\\\',\n        '\\r': 'r',\n        '\\n': 'n',\n        '\\t': 't',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    };\n    var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n    // JavaScript micro-templating, similar to John Resig's implementation.\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\n    // and correctly escapes quotes within interpolated code.\n    _.template = function (text, data, settings) {\n        var render;\n        settings = _.defaults({}, settings, _.templateSettings);\n        // Combine delimiters into one regular expression via alternation.\n        var matcher = new RegExp([\n            (settings.escape || noMatch).source,\n            (settings.interpolate || noMatch).source,\n            (settings.evaluate || noMatch).source\n        ].join('|') + '|$', 'g');\n        // Compile the template source, escaping string literals appropriately.\n        var index = 0;\n        var source = \"__p+='\";\n        text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {\n            source += text.slice(index, offset)\n                .replace(escaper, function (match) { return '\\\\' + escapes[match]; });\n            if (escape) {\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n            }\n            if (interpolate) {\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n            }\n            if (evaluate) {\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\n            }\n            index = offset + match.length;\n            return match;\n        });\n        source += \"';\\n\";\n        // If a variable is not specified, place data values in local scope.\n        if (!settings.variable)\n            source = 'with(obj||{}){\\n' + source + '}\\n';\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n            source + \"return __p;\\n\";\n        try {\n            render = new Function(settings.variable || 'obj', '_', source);\n        }\n        catch (e) {\n            e.source = source;\n            throw e;\n        }\n        if (data)\n            return render(data, _);\n        var template = function (data) {\n            return render.call(this, data, _);\n        };\n        // Provide the compiled function source as a convenience for precompilation.\n        template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n        return template;\n    };\n    module.exports = _;\n}\n"]}